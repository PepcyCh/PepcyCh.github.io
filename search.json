[{"title":"用 Unity 学习 PBR（二）法线分布项","url":"/用-Unity-学习-PBR（二）法线分布项/","content":"\n本文先简单介绍了法线分布函数（Normal Distribution Function，NDF）的基本性质，之后描述了 Blinn-Phong、Beckmann、GGX / TR、GTR 等分布函数，简单介绍了 NDF 的形状不变性与各向异性的 NDF，最后给出了在 Unity 中各个 NDF 的可视化结果。\n\n参考\n\n* [基于物理的渲染（PBR）白皮书 - 毛星云](https://github.com/QianMo/PBR-White-Paper)\n* [Physically Based Rendering Algorithms: A Comprehensive Study In Unity3D](https://www.jordanstevenstechart.com/physically-based-rendering)\n* 《Real Time Rendering, 4th》- Chap. 9\n\n<!-- more -->\n\n## 基本性质\n\n法线分布函数（Normal Distribution Function，NDF）描述了各个微平面法向方向的占比，可以认为是，这一块宏平面下微平面法向为某个值的微平面的面积，其满足如下归一化条件：\n$$\n\\int_{\\Omega} D(m) (m \\cdot n) \\mathrm{d}m = 1\n$$\n即所有微平面的投影面积是宏平面面积。更加推广一些的式子是：\n$$\n\\int_{\\Omega} D(m) (m \\cdot v) \\mathrm{d} m = (v \\cdot n)\n$$\n即所有微平面在某个方向的投影面积是宏平面在这个方向上的投影面积。其中 $D(m) (m \\cdot v)$ 可能会有负值，但是会有相应的正值与之抵消。\n\n另外，因为 $D(m)$ 是一个分布函数，它也满足 $D(m) \\geq 0$。\n\n如果 $D(m)$ 的表达式里只有 $(n \\cdot m)$ 而且是各向同性的话，那这个积分会相对好算很多（有时要算归一化系数，得算一下积分）：\n$$\n\\int_{\\Omega} g(n \\cdot m) (n \\cdot m) \\mathrm{d}m = \\int_{0}^{2\\pi} \\mathrm{d}\\varphi \\int_{0}^{\\pi / 2} g(\\cos \\theta) \\cos \\theta \\sin \\theta \\mathrm{d} \\theta = 2 \\pi \\int_{0}^{1} xg(x) \\mathrm{d} x\n$$\n\n## Blinn-Phong\n\nBlinn-Phong 光照模型大家应该都知道，其镜面反射部分是 $(n \\cdot m)^{\\alpha_p}$，但是直接用该式作为 NDF 的话，其积分不是 1，所以需要进行归一化：\n$$\nD(m) = \\chi^+(n \\cdot m) \\frac{2 + \\alpha_p}{2 \\pi} (n \\cdot m)^{\\alpha_p}\n$$\n其中 $\\chi^+(x) = [x > 0]$。写代码的时候我们都会写 `NdotM = max(0, dot(norm, half))`，相当于起到了 $\\chi^+(n \\cdot m)$ 的作用。该项严谨一点的话在公式中写上可能比较好，不过不写大家也应该知道是这么个意思。\n\n$\\alpha_p$ 是描述平面光滑程度的因子，取值为 $0 \\sim \\infin$，值越大则越光滑。它与我们 $0 \\sim 1$ 的粗糙度参数 $\\alpha$ 可以用如下的方式对应：\n\n* $\\alpha_p = 2 \\alpha^{-2} - 2$（我在代码中选择的方式）\n* $\\alpha_p = K(1 - \\alpha)$\n* ……\n\nHLSL 实现：\n\n```c\nfloat BlinnPhongNDF(float NdotH, float ap) {\n    return pow(NdotH, ap) * (2 + ap) / (2 * PI);\n}\n// ...\nfloat NDF = BlinnPhongNDF(NdotH, 2 / max(roughnessSqr, EPS) - 2);\n```\n\n为了便于调试与观察 NDF，把 `float4(NDF, NDF, NDF, 1)` 直接作为片段着色器的输出。\n\n## Beckmann\n\nBeckmann NDF 的提出其实比 Blinn-Phong 还要早些，其公式为：\n$$\nD(m) = \\frac{\\chi^+(n \\cdot m)}{\\pi \\alpha^2 (n \\cdot m)^4} \\exp(\\frac{(n \\cdot m)^2 - 1}{\\alpha^2 (n \\cdot m)^2})\n$$\nBeckmann NDF 在比较粗糙时，最大值并不在 $(n \\cdot m) = 1$ 时取到。\n\n当 Blinn-Phong 中的 $\\alpha_p$ 选用 $2 \\alpha^{-2} - 2$ 、粗糙度较低时，二者的曲线很接近。\n\nHLSL 实现：\n\n```c\nfloat BeckmannNDF(float NdotH, float a2) {\n    float NdotHSqr = NdotH * NdotH;\n    return exp((NdotHSqr - 1) / (a2 * NdotHSqr)) / max(EPS, PI * a2 * NdotHSqr * NdotHSqr);\n}\n// ...\nfloat NDF = BeckmannNDF(NdotH, roughnessSqr);\n```\n\n## GGX / Trowbridge-Reitz\n\nGGX NDF 或 TR NDF，目前比较流行的分布，先于上个世纪七十年代由 Trowbridge-Reitz 提出，后在 2007 年由 Walter 等人独立重新发现并命名为GGX（GGX 一词本身好像并没有什么意思），其公式为：\n$$\nD(m) = \\frac{\\alpha^2 \\chi^+(n \\cdot m)}{\\pi ((n \\cdot m)^2(\\alpha^2 -1) + 1)^2}\n$$\nWalter 等人的论文中使用了不同的形式。不过推一推会发现二者是一样的，而且上面这个式子实现起来计算起来要更方便一些。\n$$\nD(m) = \\frac{\\alpha^2 \\chi^+(n \\cdot m)}{\\pi (n \\cdot m)^4 (\\alpha^2 + \\tan^2(\\angle(n, m))^2}\n$$\nHLSL 实现：\n\n```c\nfloat GGXNDF(float NdotH, float a2) {\n    return a2 / max(EPS, PI * sqr(NdotH * NdotH * (a2 - 1) + 1));\n}\n// ...\nfloat NDF = GGXNDF(NdotH, roughnessSqr);\n```\n\n需要注意的是，该实现在光的背面也会是非 0 的值（也就是说没有实现 $\\chi^+$）。\n\n## GTR（Generalized Trowbridge-Reitz）\n\n从名字上可以看出来，该 NDF 是 GGX/TR 的推广，目前比较流行的分布，其公式为：\n$$\nD(m) = \\frac{c \\chi^+(n \\cdot m)}{(1 + (n \\cdot m)^2 (\\alpha^2 - 1))^{\\gamma}}\n$$\n$c$ 是归一化系数（需要积分求解归一化系数，不过这个分布还挺好积的）。对于参数 $\\gamma$：\n\n* $\\gamma = 1$，是一个在这之前已有的分布 Berry 分布，$c = (\\alpha^2 - 1) / (\\pi \\ln(\\alpha^2))$\n* $\\gamma = 2$，就是 GGX/TR 分布，$c = \\alpha^2 / \\pi$\n\n随着 $\\gamma$ 的增大，高光尾部会变长。\n\n这里给出 GTR1 和 GTR2 的实现：\n\n```c\nfloat GTR2NDF(float NdotH, float a2) {\n    float c = a2 / PI;\n    return c / max(EPS, sqr(NdotH * NdotH * (a2 - 1) + 1));\n}\n\nfloat GTR1NDF(float NdotH, float a2) {\n    float temp = a2 - 1;\n    float c = temp / PI / log(a2);\n    return c / max(EPS, 1 + NdotH * NdotH * temp);\n}\n```\n\n## 形状不变性（shape-invariant）与各向异性 NDF\n\n如果一个 NDF 可以被重写为一下形式，则称其为具有形状不变性（shape-invariant）：\n$$\nD(m) = \\frac{1}{\\alpha^2 (n \\cdot m)^4} g\\left( \\frac{\\sqrt{1 - (n \\cdot m)^2}}{\\alpha (n \\cdot m)} \\right)\n$$\n以上提到的各个分布中，GGX/TR 与 Beckmann 分布具有形状不变性，其余几个则没有。\n\n具有形状不变性的 NDF 在 $\\alpha$ 变化时，相当于微平面拉伸或收缩。\n\n具有形状不变性的 NDF 可以方便的得到其各向异性的版本，也方便推导对应的几何项。一个具有形状不变性的 NDF 的相应的各向异性的版本为：\n$$\nD = \\frac{1}{\\alpha_x \\alpha_y (n \\cdot m)^4} g\\left( \\frac{\\sqrt{(t \\cdot m)^2 / \\alpha_x^2 + (b \\cdot m)^2 / \\alpha_y^2}}{(n \\cdot m)} \\right)\n$$\n其中 $\\alpha_x$ 与 $\\alpha_y$ 是两个方向上的粗糙度（X 指切线方向，Y 指副切线方向），相当于两个垂直的方向上是同一分布但是是不同的拉伸因子。当 $\\alpha_x = \\alpha_y$ 时，退化为各向同性（注意到 $(t \\cdot m)^2 + (b \\cdot m)^2 + (n \\cdot m)^2 = 1$）。\n\n各向异性的 Beckmann 分布：\n$$\nD = \\frac{1}{\\pi \\alpha_x \\alpha_y (n \\cdot m)^4} \\exp(- \\frac{(t \\cdot m)^2 / \\alpha_x^2 + (b \\cdot m)^2 / \\alpha_y^2}{(n \\cdot m)^2})\n$$\n各向异性的 GGX/TR 分布：\n$$\nD = \\frac{1}{\\pi \\alpha_x \\alpha_y ((t \\cdot m)^2 / \\alpha_x^2 + (b \\cdot m)^2 / \\alpha_y^2 + (n \\cdot m)^2)^2}\n$$\n为了描述各向异性平面，可以直接使用两个粗糙度参数，或者使用一个粗糙度参数与一个各向异性参数 $k_{\\mathrm{aniso}}$，由其得到两个粗糙度的方法是（Disney）：\n$$\nk_{\\mathrm{aspect}} = \\sqrt{1 - 0.9 k_{\\mathrm{aniso}}} \\\\\n\\alpha_x = \\frac{\\alpha}{k_{\\mathrm{aspect}}} \\\\\n\\alpha_y = \\alpha k_{\\mathrm{aspect}}\n$$\n两个方向的粗糙度比值范围为 $[1, 10]$。或（Sony Imageworks）：\n$$\n\\alpha_x = \\alpha (1 + k_{\\mathrm{aniso}}) \\\\\n\\alpha_y = \\alpha (1 - k_{\\mathrm{aniso}}) \\\\\n$$\n两个方向的粗糙度比值范围为 $[1, \\infin]$。\n\n（《Real Time Rendering, 4th》中（毛神的 PBR 白皮书是基于其的）中给出的式子使用 $r^2$，但我以为写成 $\\alpha$ 更能直接地说明退化的状况）\n\nStevens 的教程中使用上者的公式，但扩大了 $k_{\\mathrm{aniso}}$ 的范围为 $[-20, 1]$，但我以为如果要扩大也应该是扩大到 $[-10, 1]$。当范围为 $[-10, 1]$ 时，两个方向的粗糙度比值范围扩大为 $[0.1, 10]$。不知道 Stevens 的教程选择 $-20$ 是何用意。 \n\nGGX/TR 分布与 Beckmann 分布相应的各向异性分布的 HLSL 实现：\n\n```c\nfloat BeckmannAnisoNDF(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n    float NdotHSqr = NdotH * NdotH;\n    return exp(-(sqr(HdotX / ax) + sqr(HdotY / ay)) / NdotHSqr)\n        / max(EPS, PI * ax * ay * NdotHSqr * NdotHSqr);\n}\nfloat GGXAnisoNDF(float NdotH, float HdotX, float HdotY, float ax, float ay) {\n    return 1.0 / max(EPS, PI * ax * ay * sqr(sqr(HdotX / ax) + sqr(HdotY / ay) + sqr(NdotH)));\n}\n// ...\nfloat kaspect = sqrt(1 - 0.9 * _Anisotropic);\nfloat roughnessX = max(EPS, roughness / kaspect);\nfloat roughnessY = max(EPS, roughness * kaspect);\nfloat HdotX = dot(halfDir, i.worldTangent);\nfloat HdotY = dot(halfDir, i.worldBitangent);\n// float NDF = BeckmannAnisoNDF(NdotH, HdotX, HdotY, roughnessX, roughnessY);\nfloat NDF = GGXAnisoNDF(NdotH, HdotX, HdotY, roughnessX, roughnessY);\n```\n\n## 可视化结果\n\n让片段着色器以灰色直接输出 NDF 的值，结果如下：\n\n![02-ndf.png](https://i.loli.net/2021/02/14/NAbdczUR2a6kjwF.png)","tags":["学习笔记","CG","PBR","Unity"],"categories":["学习笔记（CG）"]},{"title":"用 Unity 学习 PBR（一）基础和准备","url":"/用-Unity-学习-PBR（一）基础和准备/","content":"\n想着学一下 Unity 的 ShaderLab，一是提升引擎的使用能力，二是通过使用实际的引擎来反思自己的玩具渲染器应该怎样改进或重构。找到了用 Unity 搞 PBR 的教程，正好能巩固和深入学习一下以前只在 Learn OpenGL 学过一次的 PBR 的那套东西。\n\n参考\n\n* [基于物理的渲染（PBR）白皮书 - 毛星云](https://github.com/QianMo/PBR-White-Paper)\n* [Physically Based Rendering Algorithms: A Comprehensive Study In Unity3D](https://www.jordanstevenstechart.com/physically-based-rendering)\n\n<!-- more -->\n\n## PBR 理论基础\n\n只有反射的渲染方程\n$$\nL_o = \\int_{\\Omega} f_r(w_i, w_o) L_i(w_i) (w_i \\cdot n) \\mathrm{d}w_i\n$$\n对于间接光照，使用基于图像的光照（IBL）；对于直接光照，积分就是对所有光源计算求和。\n\nBRDF $f_r$ 拆解为漫反射（diffuse）与镜面反射（specular）。\n\n漫反射项最经典的公式是 Lambert，也有一些其他更物理一些的公式。\n\n镜面反射项，由 Cook-Torrance 提出的基于微平面（microfacet）的公式：\n$$\nf(l, v) = \\frac{F(v, h) G(l, v, h) D(h)}{4 (n \\cdot l) (n \\cdot v)}\n$$\n其中：\n\n* $n$ 即 normal，宏平面法向\n* $l$ 即 light，渲染方程中的 $w_i$，光源方向\n* $v$ 即 view，渲染方程中的 $w_o$，观察方向\n* $h$ 即 half，光源方向与观察方向的中间方向\n* $F$ 为菲涅尔项，描述出射光中镜面反射占比随视角的变化\n* $D$ 为法线分布，描述微平面法向 $m$ 中有多少与 $h$ 平行，即宏平面的多少部分能为镜面反射提供贡献\n* $G$ 为几何项，描述与 $h$ 平行的微平面法向中，有多少未因遮挡（masking，挡住入光）或阴影（shadowing，挡住出光）导致实际未能提供贡献\n\n$F$、$D$、$G$ 使用一些参数来描述真实世界的各种表面材质，Disney 原则的 BRDF 提出，各个参数应在 0 ~ 1 内并能够线性地插值两端的结果，以便于美术人员对材质的修改。实现最简单的 PBR 需要的参数有：\n\n* 粗糙度（roughness），主要影响 $D$ 与 $G$，即越光滑的表面，微平面法向就越更多地接近宏平面法向，也更少出现微平面的相互遮挡。在公式中一般用 $\\alpha$ 表示，$\\alpha$ 与暴露给外部的粗糙度通常并不是同一数值。一个常用的映射是 $\\alpha = r^2$，Stevens 的教程中则使用了 $\\alpha = (1 - (1 - r)^2)^2$\n* 金属度（metallic），通过对金属（导体）与非金属（电介质）的插值来更灵活地描述一些材质。金属没有漫反射成分，且会有与非金属较大区别的菲涅尔项\n* F0，入射角为 0（正对着表面入射）时镜面反射光的比例，常用的菲涅尔项的公式都是以 F0 为基础算出其他入射角下的镜面反射比例。金属的 F0 基本上就是金属自身的颜色，而非金属的 F0 一般 RGB 相同且不超过 0.1x。不过，直接提供 F0 作为参数并不是那么直观（即使有 F0 数据库的存在）；镜面发射颜色（specular color）可以认为是 F0\n\n## Unity 准备\n\n在 Unity 中新建一个 Unlit Shader，在其中修改我们需要的熟悉，编写我们自己的顶点与片段着色器（其实新建哪个着色器没有关系，只是选 Unlit Shader 会给一个使用顶点与片段着色器的模板）。\n\nUnity 使用 ShaderLab 语言描述一个 Unity 着色器。在其中，我们主要会用到的部分是属性的编辑与 Cg/HLSL 着色器的编写。\n\n属性的话，我们添加如下属性：\n\n```\nProperties\n{\n    _Color (\"Color\", Color) = (1, 1, 1 ,1)\n    _MainTex (\"Texture\", 2D) = \"white\" {}\n    _SpecularColor (\"Specular Color\", Color) = (1, 1, 1, 1)\n    _Roughness (\"Roughness\", Range(0, 1)) = 0\n    _Metallic (\"Metallic\", Range(0, 1)) = 0\n    _Anisotropic (\"Anisotropic\", Range(0, 1)) = 1\n}\n```\n\n并且在着色器代码中添加这些属性对应变量的定义：\n\n```c\nfloat4 _Color;\nsampler2D _MainTex;\nfloat4 _MainTex_ST;\nfloat4 _SpecularColor;\nfloat _Roughness;\nfloat _Metallic;\nfloat _Anisotropic;\n```\n\n着色器代码包含以下头文件：\n\n```c\n#include \"UnityCG.cginc\"\n#include \"AutoLight.cginc\"\n#include \"Lighting.cginc\"\n```\n\n修改顶点着色器的输入和输出如下：\n\n```c\nstruct appdata {\n    float4 vertex : POSITION;\n    float3 normal : NORMAL;\n    float3 tangent : TANGENT;\n    float2 uv : TEXCOORD0;\n};\n\nstruct v2f {\n    float2 uv : TEXCOORD0;\n    UNITY_FOG_COORDS(1)\n    float4 vertex : SV_POSITION;\n\n    float3 worldPos : TEXCOORD3;\n    float3 worldNormal : TEXCOORD4;\n    float3 worldTangent : TEXCOORD5;\n    float3 worldBitangent : TEXCOORD6;\n};\n```\n\n并相应修改顶点着色器：\n\n```c\nv2f vert(appdata v) {\n    v2f o;\n    o.vertex = UnityObjectToClipPos(v.vertex);\n    o.uv = TRANSFORM_TEX(v.uv, _MainTex);\n    UNITY_TRANSFER_FOG(o,o.vertex);\n\n    o.worldPos = mul(unity_ObjectToWorld, v.vertex);\n    o.worldNormal = UnityObjectToWorldNormal(v.normal);\n    o.worldTangent = normalize(mul(unity_ObjectToWorld, v.tangent));\n    o.worldBitangent = normalize(cross(o.worldNormal, o.worldTangent));\n\n    return o;\n}\n```\n\n片段着色器部分，我们先做一些准备工作，包括纹理采样、得到各个需要的向量、计算各个需要的点积、处理粗糙度转换等：\n\n```c\nfloat4 frag(v2f i) : SV_Target {\n    // main color\n    float4 mainTexColor = tex2D(_MainTex, i.uv);\n    float3 mainColor = mainTexColor.rgb * _Color.rgb * (1 - _Metallic);\n\n    // vectors\n    float3 normalDir = normalize(i.worldNormal);\n    float3 viewDir = normalize(_WorldSpaceCameraPos.xyz - i.worldPos);\n    float3 lightDir = normalize(\n        lerp(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz - i.worldPos,\n             _WorldSpaceLightPos0.w));\n    float3 lightReflectDir = reflect(-lightDir, normalDir);\n    float3 viewReflectDir = reflect(-viewDir, normalDir);\n    float3 halfDir = normalize((viewDir + lightDir) * 0.5);\n\n    // dot\n    float NdotL = max(0, dot(normalDir, lightDir));\n    float NdotH = max(0, dot(normalDir, halfDir));\n    float NdotV = max(0, dot(normalDir, viewDir));\n    float VdotH = max(0, dot(viewDir, halfDir));\n    float LdotH = max(0, dot(lightDir, halfDir));\n    float LdotV = max(0, dot(lightDir, viewDir));\n    float RdotV = max(0, dot(lightReflectDir, viewDir));\n\n    // roughnees\n    float roughness = _Roughness * _Roughness;\n    float roughnessSqr = roughness * roughness;\n\n    // light attenuation\n    float attenuation = LIGHT_ATTENUATION(i);\n    float3 attenColor = attenuation * _LightColor0.rgb;\n    \n    // ...\n}\n```\n\n同时新建一个材质，让材质绑定到新建的着色器上。\n\n最后在场景中添加一个几何体，比如球什么的，使用刚刚新建的材质。这样我们在材质中修改参数或修改着色器的效果就可以直接在场景中的这个几何体上看到了。","tags":["学习笔记","CG","PBR","Unity"],"categories":["学习笔记（CG）"]},{"title":"DirectX 12 学习笔记（一）","url":"/DirectX-12-学习笔记（一）/","content":"\n因为觉着 DirectX 12 和 Vulkan（还有 Metal）作为所谓现代的图形 API，有必要依次学一学，因为之前学的是 OpenGL 3.3。\n\n总之先从 DirectX 12 开始，用的教程是 Frank Luna 的书《Introduction to 3D Game Programming with DirectX12》，没有中文的样子，搞到的电子版有 1200 页。。。有三部分，第一部分（前三章）是数学，跳过了；第二部分（4~14 章）是 DirectX 12 基础，也就是本笔记时看过去的部分；第三部分（15~23 章）算是专题，比如法线贴图、第一人称摄像机、AO 等，之后会继续看下去。\n\n书有一个配套的代码仓库：[d3dcoder/d3d12book](https://github.com/d3dcoder/d3d12book)\n\n我也是跟着书和这个仓库每章也写了，大部分是一样的，但也改了一些部分，比如 DDS 材质的加载使用 DirectXTK12 库，而书中是作者自己魔改的 DirectXTK11。另一点，处于个人喜好，没有用 Visual Studio 的项目，还是用的 VS Code + CMake。代码仓库是：[PepcyCh/learn-directx12](https://github.com/PepcyCh/learn-directx12)\n\n此外，在知乎上看到了一个 ID 为「[卡卡](https://www.zhihu.com/people/qia-qia-80-99-20)」的人也在跟这本书，并且会用心做每一个练习（相比之下我就太囫囵了。。。），安利一下。\n\n（这可能并不是一篇看能就能够入门的笔记，只是我来列出原书第二部分的学习后，对整个部分一个总结概括性质的个人笔记）\n\n<!-- more -->\n\n## 每章代码简介\n\n### chap. 4 - initialization\n\nWindows 窗口及 DirectX 12 必要的初始化，程序运行得到的是一个能显示 FPS 以外只有纯色背景的窗口。\n\n### chap. 6 - drawing I\n\nDirectX 12 绘制最基本的内容，绘制一个彩色立方体。\n\n`ch06_box` 是跟着原书和仓库来的，`ch06_box_extra` 是书上这一章的习题 2，并且从原来的左手系改成了自己更习惯的右手系。\n\n### chap. 7 - drawing II\n\n引入了「帧资源（Frame Resource）」与「渲染物体（Render Item）」进行渲染，同时向 `Common` 内加入了一个 `GeometryGenerator` 来生成立方体、圆柱（圆台）、经纬球、几何球等集合体。\n\n`ch07_shape` 是绘制 Geometry Generator 生成的几何体（把一侧的经纬球改成了几何球），并通过「1」键开启或关闭线框模式。\n\n`ch07_land_wave` 是以平面为基础绘制「山川河流」，大部分后续代码也是由此改来。\n\n### chap. 8 - lighting\n\n使用 Blinn-Phong 光照绘制山川河流的例子。这个 Blinn-Phong 和当时在 Learn OpenGL 学的有所区别，用到的参数分别是漫反射（diffuse）、环境光（ambient）、粗糙度（roughness）和正射时的菲涅尔系数。\n\n### chap. 9 - texturing\n\n在山川河流的例子中加入材质，使用 DDS 材质。\n\n### chap. 10 - blending\n\n在山川河流的例子中，使用混合绘制半透明的水。\n\n### chap. 11 - stenciling\n\n使用模板来模拟镜子的效果，加入了练习中的地板镜像。同时实现了 Learn OpenGL 那边讲过的用模板实现的物体轮廓，通过「1」键来开启或关闭。\n\n### chap. 12 - geometry shader\n\n在山川河流的例子中，使用几何着色器实现的告示板（Billboard）技术来绘制树木。\n\n### chap. 13 - compute shader\n\n`ch13_wave` 是在山川河流的例子中，使用计算着色器更新水面的水波。\n\n`ch13_blur` 是通过计算着色器对山川河流的渲染结果进行高斯模糊。\n\n`ch13_sobel` 是使用 Sobel 算子对山川河流的渲染结果进行边缘检测，并通过一次渲染屏幕四边形来为渲染结果加入描边的效果。我在代码中结合了光照章节中的练习 6（一种卡通渲染方法）。\n\n### chap. 14 - tessellation\n\n`ch14_tessellation_basic` 是通过细分来生成山川河流中的山的顶点，根据到观察点的距离决定细分系数以实现一种 LOD。\n\n`ch14_tessellation_bezier` 通过细分生成贝塞尔曲面。\n\n## Win32 窗口\n\n通过一个 `WNDCLASS` 对象来设定窗口的一些特性（如图标、光标样式、事件处理函数）并通过 `RegisterClass()` 来注册这一类窗口；然后通过 `CreateWindow()` 来创建真正的窗口。\n\n其中，这个事件处理函数的签名大致如下 `LRESULT CALLBACK (HWND win, UINT msg, WPARAM w_param, LPARAM l_param)`，其中 `HWND win` 就是窗口的句柄（指针），虽然我们把它存了起来，但还是需要以参数的形式提供在其中，可能会觉得有些没有必要。其实，在 `CreateWindow()` 的期间就会触发事件处理函数，而我们存的句柄来自 `CreateWindow()` 的返回值，这时还是无效的，所以需要把那个有效的句柄以参数的形式传入。在编写具体函数体的时候也要注意要使用参数中的句柄而不是存储的变量。\n\n## DirectX 12 渲染管线\n\nDirectX 12 一次渲染经过一下步骤：\n\n* Input Assemble（IA）\n* Vertex Shader（VS）\n* Hull Shader（HS）\n* Tessellation\n* Domain Shader（DS）\n* Geometry Shader（GS）\n* Rasterizer（RS）\n* Pixel Shader（PS）\n* Output Merger（OM）\n\n其中 IA、Tessellation 和 RS 是不可编程的。此外，还有一个可单独使用的 Computer Shader（CS），不在渲染管线之中。\n\n## DirectX 12 的元素\n\n### `ComPtr<T>`\n\nDirectX 12 中的许多对象都是通过一个工厂方法来创建，而这些对象都是 Windows 的 COM（Component Object Model）对象，要通过智能指针的方式管理这些对象就得用 WRL（Windows Runtime Library）的 `ComPtr<T>`，它会在最后调用 COM 对象具体子类实现的一个释放对象的函数。如果把非 COM 的类作为模板参数给 `ComPtr<T>`，就会报错说 `T` 没有那个释放函数（当然，你按着那个签名实现一个也成吧……）；如果把 COM 的类用 C++ 自己的智能指针管理，可能会有问题（[Using std::unique_ptr for managing COM objects](https://stackoverflow.com/questions/21820301/using-stdunique-ptr-for-managing-com-objects)）。\n\n这些 COM 对象的基类可以根据类名的前缀分为 2 种：\n\n* `IDXGIXxx` ：DXGI（DirectX Graphics Interface），一些各个 DirectX 版本、无论 2D、3D 都会用到的东西。\n* `ID3D12Xxx` ：DirectX 12 自己的东西。\n\n### D3D12 调试层\n\n对应的接口基类为 `ID3D12Debug`，通过开启调试层，可以在调试模式下（如 `gdb` 中）看到更详细的错误或警告信息，方便调试。\n\n### `IDXGIFactory` & `ID3D12Device`\n\n这两个类是创建 DXGI / DirectX 12 对象的工厂。一般我们在创建完窗口后就会创建这两个对象。\n\n*PS：代码中实际使用的基类是 `IDXGIFactory4`。*\n\n### `D3D12_XXX_DESC`\n\n在使用 `ID3D12Device` 对象的工厂方法创建对象时，经常需要填写一个 `D3D12_XXX_DESC` 对象并作为参数传给工厂方法。这些对象中记录了创建对象时的一些配置。为了方便编程，微软提供了 `d3dx12.h` 的头文件（不自带，需要去 GitHub 之类的地方搞一份），一些比较复杂的类有相应的 `CD3DX12_XXX_DESC` 类，它们继承自相应的 `D3D12_XXX_DESC` 类，没有新增任何成员变量，但新增了一些方便方法，以简便地填写一个对象。\n\n除了以 `_DESC` 结尾地类，还有一些其他的东西，如 `D3D12_RESOURCE_BARRIER` 有着类似的情况，只不过不是用于创建对象。\n\n### Swap Chain\n\n一般我们渲染时为了使画面稳定，显示的缓冲和绘制目标会分开来，等绘制完毕后，让它去显示，而原来显示的缓冲成为下一帧绘制的目标。这样的机制成为交换链（Swap Chain，对应的接口基类为 `IDXGISwapChain`），一般会使用 2 个或 3 个缓冲。\n\n在相应的配置类 `DXGI_SWAP_CHAIN_DESC` 中，有一项 `SwapEffect` 应当设置为 `DXGI_SWAP_EFFECT_FLIP_DISCARD` 或 `DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL`，这个时候，尝试建立一个 MSAA 的交换链会 RE，所以，原书及相应仓库中的 MSAA 代码是不能跑的。\n\n*PS：代码中实际使用的基类是 `IDXGISwapChain1` 和 `DXGI_SWAP_CHAIN_DESC1`。*\n\n### Command Allocator、Queue and List\n\n在 DirectX 12 中，并不是 CPU 提交指令给 GPU 让它直接执行，然后等 GPU 执行完毕后再运行 CPU 侧的下一条指令，而是先把一些命令存起来，然后再一起交给 GPU 让它去执行，并且 CPU 可以继续执行后续的代码。\n\n这些命令由命令列表（Command List，对应的接口基类为 `ID3D12CommandList`）对象的方法添加到列表之中；而列表使用的空间来自命令分配器（Command Allocator，对应的接口基类为 `ID3D12CommandAllocator`）；命令队列（Command Queue，对应的接口基类为 `ID3D12CommandQueue`）则负责把列表里的命令提交给 GPU，也负责一些 CPU 与 GPU 的同步。\n\n使用列表的方法添加命令时，必须先调用一次 `Reset()`，其中还会指明使用的分配器和 PSO（之后会说），等命令添加完了，调用一次 `Close()`，之后才能让队列去交给 GPU 执行。\n\n因为 CPU 与 GPU 是并行的，CPU 在运行后续代码时可能 GPU 还在执行列表里的命令，这里就要保障分配器对象不变（因为命令的数据所占的空间由分配器管着）。\n\n### Fence\n\nCPU 与 GPU 是并行的，因此需要一个机制来让 CPU 知道 GPU 有没有完成某些工作，已让 CPU 部分可以安全地继续执行下去。\n\nFence 可以认为是插入到命令之间的一个整数，一般我们会让这个整数随插入次数每次加一，我们可以通过最近见到的一个 Fence 的数字是多少来判断它某个 Fence 之前的命令有没有全部完成。\n\n一般，我们会在每一帧的结束，命令队列把命令提交后，使用队列的 `Signal()` 方法将 Fence 插入。根据 Fence 等待命令执行完的操作被称为刷新队列（flush command queue）。\n\n我们需要一个 Fence 对象（对应的接口基类为 `ID3D12Fence`），它会记录最近一个 Fence 的数字。\n\n### 资源、描述子、描述子堆\n\nDirectX 12 中，资源（Resource，相应的接口基类为 `ID3D12Resource`）大致可以分为两大类，缓冲（buffer）和材质（texture）。\n\n资源通过描述子（Descriptor，因历史原因也叫 View）来描述，一个资源上可以有多个描述子。描述有三（五）类，分别是：\n\n* RTV（Render Target View）- 渲染目标\n* DSV（Depth Stencil View）- 深度与模板\n* CBV（Constant Buffer View）、SRV（Shader Resource View）、UAV（Unordered Access View）\n  * CBV - 类似于 OpenGL 的 uniform，在一次着色器程序运行中不变的数据，如光源、变换矩阵等\n  * SRV - 对着色器程序来说只读的资源，如漫反射贴图、法线贴图等\n  * UAV - 对着色器程序来说可读写的资源，如计算着色器要写入的目标\n\n描述子存储在描述子堆（Descriptor Heap）中，一个堆更类似于一个定长数组，在创建时需要指定大小。一个堆中只能存储同一类的描述子（CBV、SRV、UAV 可以在同一个堆中）。在堆中创建描述子时，需要给出堆的 CPU 句柄（CPU Descriptor Handle）；而 GPU 使用其中的描述子时，需要的是 GPU 句柄（GPU Descriptor Handle）。有时，可以直接把资源的 GPU 虚拟地址（GPU Virtual Address）让 GPU 访问。\n\n在创建资源时，需要传入一个 `D3D12_HEAP_PROPERTIES` 的对象，关于这一块内容的具体描述，可以看 [Walking through the heap properties in DirectX 12](https://zhangdoa.com/posts/walking-through-the-heap-properties-in-directx-12)。\n\n### 资源状态 & Barrier\n\n我们可能会让一个着色器程序先写入一个材质，再让另一个着色器程序读取写入的数据（这是非常常见的场景），在第二个着色器程序开始之前，必须要保证第一个着色器程序已经把材质写好。我们确实可以通过 flush 的方法先等待第一个操作完毕再运行第二个着色器，不过，在更复杂的场景中，这样做一是人自己要 flush 会比较麻烦，二是有些对材质的操作其实是可以并行的，我们 flush 还会减慢运行速度，这时就需要一个新的机制来处理同步的问题，就是 Barrier。\n\n每个资源都会有一个资源状态（Resource State），在资源需要切换状态时，需要插入一个对应的状态转换 Barrier，它会根据资源的前后状态来考虑需要以怎样的方式来同步，而且只会影响使用该资源的命令。\n\n关于 Barrier，有一系列比较好的文章，现在在知乎上有人在翻译：\n\n[【译】拆解D3D12和Vulkan中的Barrier（1）](https://zhuanlan.zhihu.com/p/164491130)（后续几篇的链接就不贴出来了，毕竟挺多的……）\n\n资源状态不会影响命令的执行与否，比如，对只读资源使用有写入的命令也是可以执行的，只是同步上会有一些问题。\n\n一些比较常用的状态有：Common、Generic Read、Unordered Access、Render Target、Copy Source/Destination、Resolve Source/Destination 等。虽然代码中经常有转换到 Generic Read 的代码，但官方文档上似乎并不推荐这样做。\n\n### Vertex Buffer & Index Buffer\n\nDirectX 12 中，顶点与索引的缓冲也是一种资源，它们的描述子类型是 VBV（Vertex Buffer View）与 IBV（Index Buffer View），不过这两个描述子与之前提到的五种不他一样，VBV 与 IBV 不存在描述子堆中，也不是通过 GPU 句柄访问，而是直接把 `D3D12_VERTEX_BUFFER_VIEW` 与 `D3D12_INDEX_BUFFER_VIEW` 对象传给命令列表的 `DrawInstanced()` 或 `DrawIndexedInstanced()` 中。\n\n在 `DrawIndexedInstanced()` 中，还有两个参数 `StartIndexLocation` 和 `BaseVertexLocation`，前者指 Index Buffer 中起始的位置，后者指索引中的每一项要加上的一个数值（比如把多个小的几何体的 Vertex/Index Buffer 拼成一个时，需要设置这个值）。\n\n### 着色器（Shader）\n\n不像 OpenGL，可以把 VS、PS 等全都写在同一个 HLSL 文件内，DirectX 12 提供的函数可以传入各自的入口函数；此外，也可以通过函数传入宏定义。比起 GLSL，HLSL 的感觉更像 C++ 一些，不过矩阵乘法要用 `mul()`，使用 `*` 表示的则是分量乘法，这一点稍微有点难受。\n\n着色器程序的一些输入输出会有一个语义名（Semantic Name），其中一些有特殊意义的语义名均以 `SV_` 开头。当我们把 VS 与 PS 分开写的时候，HLSL 通过语义名来判断哪两个变量是同一个，即使它们的变量名不同，不像 GLSL 中使用变量名来判断。\n\n### Input Layout\n\nVS 需要知道 Vertex Buffer 中每个顶点中每一项的语义名、大小、位置、步长（stride），描述这些东西的叫做输入布局（Input Layout），有点类似于 OpenGL 的 Vertex Attribute。\n\n在输入布局的参数中，还有一个指定输入槽（slot），一个般一个槽对应一个 Vertex Buffer，比如位置一个缓冲、法线另一个缓冲，把它们放在两个槽上。原书代码中基本上只是用一个槽，我也只在其中一个练习中使用了多于一个槽。\n\n### 根签名 & CBV、SRV、UAV、Static Sampler\n\n如在描述子那里说的那样，通过 CBV 向着色器传递诸如光源、变换矩阵之类的东西，通过 SRV 向着色器传递只读材质，通过 UAV 传入可写材质。在着色器程序中，还需要为它们指明使用的寄存器，CBV 使用 `bx`（指 `b0`、`b1`……这样，后同），SRV 使用 `tx`，UAV 使用 `ux`。此外，还有一个称作静态采样器（Static Sampler）的东西，使用寄存器 `sx`，它的作用是采样材质。与 OpenGL 不同，OpenGL 把线性插值还是最邻近采样、越界处理放在对材质的设置中，DirectX 12 则把它们单独出来成为采样器。\n\n使用着色器时，需要有一个东西说明我们使用了几个 CBV/SRV/UAV/Static Sampler，这样的东西称为根签名（Root Signature）。一个根签名通过一个根参数（Root Parameter）的数组和可选的静态采样器的数组创建，根参数数组则依次描述使用的 CBV/SRV/UAV，每一个根参数可以是：\n\n* 描述子表（Descriptor Table）- 连续的一段同一类描述子的寄存器，比如 `b0`-`b2`、`u1`-`u1`（也就是只有一个），通过描述子堆的 GPU 句柄传入，着色器需要经历“句柄-地址-资源”的步骤访问到资源，但只占用 32bit。\n* 根描述子（Root Descriptor）- 单个 CBV/SRV/UAV，通过资源的虚拟地址传入，着色器需要经历“地址-资源”的步骤访问到资源，占用 64bit，不过只能以此传入缓冲（buffer），不能传入材质（texture）。\n* 根常数（Root Constant）- 一个或多个 32bit 常数，着色器能直接访问到数据，每有一个常数就占用 32bit。\n\n在实际中，要同时考虑着色器访问速度和占用大小来设置。另外，还要考虑更新的频率，一般来说，把更新频率更高的东西要放到根参数数组中更前面的位置上，比如每个物体都不同数据（如模型矩阵、材质（material）等）放在每一帧内都一样的数据（如光源、透视矩阵）之前，把它们分在不同的 Constant Buffer 之中。\n\n着色器中，一个 Constant Buffer 中的数据，以及一个结构体中的数据，在内存排布上遵循以下原则：\n\n* 128bit 一组\n* 属于同一个向量的数组不拆开\n\n比如\n\n```hlsl\ncbuffer cb : register(b0) {\n    float3 v1;\n    float3 v2;\n    float s1;\n    float s2\n}\n```\n\n在内存中的排布如下：\n\n```plain\n| v1 | v1 | v1 | xx |\n| v2 | v2 | v2 | xx |\n| s1 | s2 | xx | xx |\n```\n\n而\n\n```hlsl\ncbuffer cb : register(b0) {\n    float3 v1;\n    float s1;\n    float3 v2;\n    float s2\n}\n```\n\n的内存排布是：\n\n```plain\n| v1 | v1 | v1 | s1 |\n| v2 | v2 | v2 | s2 |\n```\n\n这会带来两个问题，一是要考虑使用空间大小，二是要考虑 C++ 代码中要传给这个 Constant Buffer 的结构体的内存布局要一样（比如，不得不插入空隙时，加入一个 `float _padding` 字段）。\n\n### Pipeline State Object（PSO）\n\n在管线状态对象（PSO）中，我们指明绘制要使用的着色器、深度与模板函数、混合函数、背面剔除与正面旋转方向、填充方式（常规还是线框）等。\n\n区分绘制用的 Graphics PSO 和计算着色器的 Compute PSO。\n\n## DirectX 12 相关的其他内容\n\n### 帧资源（Frame Resource）\n\n一帧 flush 一次的做法显然完全没有利用 CPU 与 GPU 的并行性，它还是先 CPU 工作一段，然后 GPU 工作一段，以此交替地工作下去。我们希望这一帧的命令在执行时，下一帧的 CPU 工作也能进行，但由于每一帧的 CPU 工作会修改着色器使用的 Constant Buffer 和命令分配器里的命令，会影响正在执行的 GPU 工作，为了做到并行，我们把这些东西存储多份，每一份就被称作一个帧资源。\n\n如果我们有 $k$ 份帧资源，那么 GPU 就可以与接下来 $k - 1$ 帧的 CPU 并行，如果两者的工作时间差不多，那我们就做到了最优的并行。在原书代码中，选用了 $k = 3$。\n\n为了在数据发生修改时，新数据能够写入每一份帧资源的 Constant Buffer 中，我们在原始数据的结构中加入一个 dirty 字段，当修改时，赋值为 $k$，写入后字段自减一。这样不仅能保证一次修改的数据被写入，在每一帧都修改的情况下也会得到正确的结果。\n\n### 单帧绘制流程\n\n1. 切换到下一个帧资源，并等待该帧资源的上次绘制结束\n2. 动画的更新，更新各个 Constant Buffer\n3. Reset 当前帧资源的命令分配器，Reset 命令列表（设置 PSO）\n4. 设置视口（viewport）和裁剪（scissors rectangle）\n5. 清空 RTV & DSV，指明渲染的 RTV & DSV\n6. 设置根签名\n7. 设置 CBV/SRV/UAV 的描述子堆\n8. 设置一帧渲染中不变的 CBV\n9. 渲染每个物体\n   1. 设置物体的 CBV、物体材质的 CBV、SRV\n   2. 绘制\n10. 调用命令列表的 Close，用命令队列提交命令让 GPU 开始运行\n11. 设置 Fence\n12. 交换链切换\n\n### 计算着色器\n\n在计算着色器程序中，需要声明属性 `[numthreads(x, y, z)]`，表示这么大的一块作为一组线程组（Thread Group），同一个线程组的线程并行，且可以共享着色器程序中标有 `groupshared` 的数据，可以在程序中通过 `GroupMemoryBarrierWithGroupSync()` 来同步，不同线程组之间则不行。一般来说，线程组的大小应该是一个数的倍数（根据原书上的描述，NVIDIA 显卡是 32 的倍数，AMD 显卡是 64 的倍数）才能达到更好的效率。\n\n在计算着色器中，越界的部分写入无效，读取则读取到 0。\n\n### 细分\n\n细分包括可编程的 HS 和 DS，以及固定的 Tessellation 步骤。\n\n要使用细分，要绘制的图元的图元类型得是 `D3D_PRIMITIVE_TOPOLOGY_X_CONTROL_POINT_PATCHLIST`（其中 `X` 取 1 - 32，表示控制点的数目），PSO 的图元类型是 `D3D12_PRIMITIVE_TOPOLOGY_TYPE_PATCH`。\n\nHS 包括一个 Constant HS 和一个 Control Points HS，在 C++ 代码中指明的入口函数是 Control Points HS 的函数名，Constant HS 的函数名则通过 Control Points HS 的属性 `[patchconstantfunc()]` 来指明。\n\nControl Points HS 和 DS 都有一个属性 `[domain()]`，其可能的参数是 `isoline`、`triangle` 或 `quad `，关于这三种 patch 如何被 Constant HS 输出的两类细分因子影响，可以看 [Tessellation - OpenGL Wiki](https://www.khronos.org/opengl/wiki/Tessellation)（虽然是 OpenGL 的，但大家都是一样的，而且我觉得这个里面写的挺全的……）。\n\nControl Points HS 的目的是修改传入的控制点，也可以直接不变地输出。\n\nDS 可以看作是细分后顶点的顶点着色器，使用细分的话，透视矩阵在这里乘，DS 的输出作为 PS 的输入。\n\nDS 的输入不是具体的细分后顶点，而是一个跟据 patch 不同的参数（四边形的话就是 uv，三角形就是重心坐标）。需要我们手动根据输入的顶点来算出真正的细分后顶点（可以认为，Tessellation 步骤不知道我们的控制顶点是什么，只是在细分一个标准的线/三角形/正方形，所以也只能给出参数）。\n\n## 代码中的其他内容\n\n### 变换矩阵的左手系 & 右手系\n\n原书代码使用的数学库 DirectX Math 提供的生成透视矩阵、观察矩阵等矩阵的函数末尾有一个 `LH` 或 `RH` 后缀，指示左手矩阵还是右手矩阵。我们在学 OpenGL 使用的 glm 以及我自己写的数学库（在 `toy-renderer` 中）中，都是右手矩阵。使用左右手矩阵绘制的结果是左右镜像对称的。一些交互代码，如通过鼠标移动观察方向，也要对水平方向的处理做相反处理才能得到类似的效果。\n\n（还有一个不同是，DirectX Math 的透视矩阵得到的深度范围是 $[0, 1]$，我自己的数学库得到的是 $[-1, 1]$）\n\n### 变换矩阵的列优先 & 行优先\n\nDirectX Math 是行优先（row-major）矩阵，glm、我自己的数学库、GLSL 以及 HLSL 都是列优先（column-major）。\n\nHLSL 的 `mul()` 函数，既支持 `mul(mat, vec)` 也支持 `mul(vec, mat)`，向量是行向量还是列向量会根据在参数中的位置来决定。\n\nDirectX Math 自己是行优先矩阵右乘行向量，glm 和我自己的数学库是列优先矩阵左乘列向量，这二者其实是一模一样的。同一个矩阵的行优先表示与列有限表示在内存上相当于一次转置，右乘向量矩阵与左乘向量矩阵也是转置关系，所以这二者的矩阵在内存上是相同的。\n\n原书代码在 HLSL 还继续使用右乘行向量的方式，但 HLSL 是列优先矩阵，所以原书代码在将矩阵赋值到 Constant Buffer 的结构中是要做转置。但根据我们刚刚的分析，我们如果在 HLSL 使用左乘列向量，就不需要这一次转置。\n\n### CMake + Win32/DirectX 12\n\n众所周知，Win32 程序的入口函数是 `WinMain` 不是 `main`（当然，还有 `wWinMain`，区别是命令行参数是 ASCII 还是 Unicode），这一点通过\n\n```cmake\nset(CMAKE_WIN32_EXECUTABLE TRUE)\n```\n\n或\n\n```cmake\nadd_executable(target_name WIN32\n    ...\n)\n```\n\n来实现。\n\n链接 DirectX 库也很简单，必经这些库和头文件都默认在环境变量里的（Windows 相关的头文件好像要手动加一下来着）。\n\n```cmake\ntarget_link_libraries(target_name\n    PUBLIC d3dcompiler d3d12 dxgi\n)\n```\n\n还有一点，编译 Win32 程序并不一定要用 MSVC 编译器，像我用的就是 Clang。\n\n## 一些与原书不同的地方\n\n### `IDXGIFactory` & `IDXGISwapChain`\n\n原书中使用 `IDXGIFactory::CreateSwapChain()` 来创建交换链，但官网文档上不推荐使用这种方式，所以修改了关于 `IDXGIFactory` 和 `IDXGISwapChain` 的创建部分：\n\n```cpp\n// D3DApp.h\nMicrosoft::WRL::ComPtr<IDXGIFactory4> p_dxgi_factory;\nMicrosoft::WRL::ComPtr<IDXGISwapChain1> p_swap_chain;\n\n// D3DApp.cpp\nThrowIfFailed(CreateDXGIFactory2(DXGI_CREATE_FACTORY_DEBUG, IID_PPV_ARGS(&p_dxgi_factory)));\n\nDXGI_SWAP_CHAIN_DESC1 sc_desc = {};\nsc_desc.Width = client_width;\nsc_desc.Height = client_height;\nsc_desc.Format = back_buffer_fmt;\nsc_desc.SampleDesc.Count = 1;\nsc_desc.SampleDesc.Quality = 0;\nsc_desc.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;\nsc_desc.BufferCount = kSwapChainBufferCnt;\nsc_desc.Scaling = DXGI_SCALING_STRETCH;\nsc_desc.SwapEffect = DXGI_SWAP_EFFECT_FLIP_DISCARD;\nsc_desc.Flags = DXGI_SWAP_CHAIN_FLAG_ALLOW_MODE_SWITCH;\nDXGI_SWAP_CHAIN_FULLSCREEN_DESC sc_fs_desc = {};\nsc_fs_desc.Windowed = true;\n\nThrowIfFailed(p_dxgi_factory->CreateSwapChainForHwnd(p_cmd_queue.Get(), h_win,\n    &sc_desc, &sc_fs_desc, nullptr, &p_swap_chain));\n```\n\n### DirectXTK12 加载 DDS 材质\n\n按原书中的说法，当时还没有 DirectXTK12，所以作者自己魔改了一个。而我在学习的时候，DirectXTK12 是已经有了的，在 GitHub 上就可以找到，所以使用 DirectXTK12。\n\n只是加载 DDS 材质的话，需要包含以下头文件：\n\n```cpp\n#include \"ResourceUploadBatch.h\"\n#include \"DDSTextureLoader.h\"\n```\n\n首先需要初始化资源上传器：\n\n```cpp\nResourceUploadBatch resource_upload(p_device.Get());\nresource_upload.Begin();\n```\n\n然后调用 `CreateDDSTextureFromFile()` 加载材质：\n\n```cpp\nauto grass_tex = std::make_unique<Texture>();\ngrass_tex->name = \"grass\";\ngrass_tex->filename = root_path + L\"textures/grass.dds\";\nThrowIfFailed(CreateDDSTextureFromFile(p_device.Get(), resource_upload,\n    grass_tex->filename.c_str(), &grass_tex->resource));\ntextures[grass_tex->name] = std::move(grass_tex);\n```\n\n不过这个函数只是得到需要干什么事情，我们需要给上传器一个命令列表的对象让它添加命令，最后再 flush 队列：\n\n```cpp\nauto upload_finish = resource_upload.End(p_cmd_queue.Get());\nFlushCommandQueue();\nupload_finish.wait();\n```\n\n其中 `upload_finish` 的类型是 `std::future<void>`。\n\n## 一些其他的\n\nDirectXTK12 的例程，以及一些其他官方例程，它们的代码结构都差不太多的感觉，而且感觉看起来挺舒服的。说不定之后会考虑试一试那样子的写法。以及，之后的代码中应该会更多地使用 `d3dx12.h` 中的便捷函数来填充 `XXX_DESC`。","tags":["学习笔记","CG","DirectX12"],"categories":["学习笔记（CG）"]},{"title":"强化学习 - Policy Iteration & Value Iteration","url":"/强化学习-Policy-Iteration-Value-Iteration/","content":"\n近日处于兴趣，在看 [UCL 的 强化学习](http://www0.cs.ucl.ac.uk/staff/d.silver/web/Teaching.html)，目前看完了前三节。第一节是绪论，第二节介绍各种概念，第三届讲 Policy Iteration 和 Value Iteration。看完第三节后觉得应该写一下，所以对课件中提到的借车问题，用 C++ 分别实现了一下。笔记和代码会放在 GitHub 上：[RL-UCL-notes](https://github.com/PepcyCh/UCL-reinforcement-learning-notes)。\n\n部分有参考这个 repo：[ShangtongZhang/reinforcement-learning-an-introduction](https://github.com/ShangtongZhang/reinforcement-learning-an-introduction)\n\n## 借车问题\n\n有两处停车场，每个停车场的容量是 20 辆。每次你可以把至多 5 辆车从其中一个停车场移至另一个，移动一辆车的代价是 2 点。同时，每次会有若干人在停车场租车与还车，租出一辆车的收益是 10 点。每次租车与还车的数目服从泊松分布，停车场一的租车与还车的 $\\lambda$ 值均为 3，停车场二租车的 $\\lambda$ 值为 4、还车为 2。你要制定策略最大化收益。\n\n<!-- more -->\n\n## 基本概念\n\n整个活动是一个马尔可夫决策过程（Markov Decision Process，MDP），一个 MDP 可由元组 $\\lang \\mathcal{S}, \\mathcal{A}, \\mathcal{P}, \\mathcal{R}, \\gamma \\rang$ 表示。此外，还有一些重要概念，如策略、价值函数、Bellman 方程等。接下来会大概地描述一下它们的含义。想要具体了解其准确含义，还请去看原课件或书。\n\n### 状态 state $\\mathcal{S}$\n\n以借车问题为例，状态就是两个停车场的车数，总共有 $21 \\times 21 = 441$ 个。\n\n在其他的例子中，如走迷宫就是指所在地，井字棋就是棋盘上的样子。\n\n### 行动 action $\\mathcal{A}$\n\n以借车问题为例，行动就是移动车辆。注意，租车和还车不是行动，因为它们不是你要决定的。\n\n在其他的例子中，如走迷宫就是往哪个方向走，井字棋就是在哪里落子。\n\n### 转移 transition $\\mathcal{P}$\n\n转移是从一个状态到另一状态的概率，具体地说，用 $\\mathcal{P_{ss’}^a}$ 表示在状态 $s$，使用行动 $a$ 后能到达状态 $s’$ 的概率。\n\n在走迷宫的例子中，这个概率只会是 $0, 1$ 两个值。而借车问题中，由于租车和还车是随机的，这个概率就不是二值化的，可以由泊松分布的式子计算出来。\n\n### 收益 reward $\\mathcal{R}$\n\n收益可以是借车问题中这样直接描述出来的。也可以是根据问题自行定义的值，如走迷宫可以定义走一步的收益是 $-1$。\n\n用 $\\mathcal{R_s^a}$ 表示在状态 $s$，使用行动 $a$ 后会获得的收益的期望。\n\n### 衰减因子 $\\gamma$\n\n$\\gamma$ 是一个在 $[0, 1]$ 范围内的值，越接近 1，表示越考虑将来；越接近 0，表示越注重眼前。\n\n### 回报 return $G_t$\n\n第 $t$ 步的回报 $G_t$ 定义为 $R_{t + 1} + \\gamma R_{t + 2} + \\gamma^2 R_{t + 3} + \\cdots$\n\n其中 $R_t$ 表示第 $t$ 步时获得的收益。\n\n根据定义，可以看到衰减因子的作用为何会体现为这样。\n\n### 策略 policy $\\pi(a \\mid s)$\n\n策略是行动的分布，指在状态 $s$ 下，要使用行动 $a$ 的概率。\n\n### 价值函数 value function\n\n有状态价值函数（state-value function）和行动价值函数（action-value function）：\n\nstate-value function $v_\\pi(s)$ 表示使用策略 $\\pi(a \\mid s)$ ，在状态 $s$ 时，会得到的回报的期望。\n\naction-value function $q_\\pi(s, a)$ 表示使用策略 $\\pi(a \\mid s)$ ，在状态 $s$ 时使用行动 $a$，会得到的回报的期望。\n\n### Bellman 方程\n\nBellman 方程把回报分为立即的回报 $R_{t + 1}$ 和将来的衰减的回报。\n\n对于价值函数，将来的回报就是 $\\gamma v(S_{t + 1})$，结合价值函数的定义和一些概率上的运算，推导出了 $v_\\pi(s) = \\mathcal{R_s^\\pi} + \\gamma \\sum_{s’ \\in \\mathcal{S}} \\mathcal{P_{ss’}^\\pi} v_\\pi(s’)$。\n\n把策略 $\\pi$ 拆成行动 $a$ 的形式就是：\n$$\nv_\\pi(s) = \\sum_{a \\in \\mathcal{A}} \\pi(a \\mid s) \\left( \\mathcal{R_s^a} + \\gamma \\sum_{s' \\in \\mathcal{S}} \\mathcal{P_{ss'}^a} v_\\pi(s') \\right)\n$$\n（行动价值函数也有相应的 Bellman 方程，不过接下来都会用的是状态价值函数，就不提了。）\n\n有了 Bellman 方程，在已知 MDP 的收益和转移、决定了策略后就可以算出价值函数。\n\n## 策略迭代 Policy Iteration\n\n### 基本思想\n\n无论是策略迭代还是价值迭代，都需要知道 MDP 的转移。\n\n这样的话，有了 Bellman 方程，我们就可以求出价值函数。\n\n一个直观的想法是写出矩阵形式然后求解矩阵方程，不过这只适用于状态数较小的情况（其实借车问题的状态数 441 用解矩阵方程还是可以接受的）。更大一些的状态集可以用迭代求解。这个步骤被称为策略评价（policy evaluation）。\n\n在求出价值后，我们可以得到一种贪心策略，即每次贪心地选择价值最大的次态，这被称作策略改进（policy improvement）。事实上，不只贪心可以做策略改进。\n\n策略迭代的想法是，我们一开始的策略是等概率随机，之后不断地进行策略评价和改进，最终就会得到最优策略。而这一点被证明是正确的。\n\n### 代码实现\n\n首先，根据策略迭代的基本思想，可以写出主要函数的一个框架：\n\n```c++\nvoid Train() {\n    while (true) {\n        PolicyEvaluation()；\n        int n_policy_changed = PolicyImprovement();\n        if (n_policy_changed == 0)\n            break;\n    }\n}\n```\n\n策略评价和改进部分，都是对于每一个状态做一些相同事情，所以可以写成：\n\n```c++\nvoid PolicyEvaluation() {\n    while (true) {\n        Values new_values;\n        Reward diff = 0;\n        for (const auto &state : all_states) {\n            Reward new_value = CalcPE(state);\n            diff += std::abs(new_value - values[state]);\n            new_values[state] = new_value;\n        }\n        values = new_values;\n        if (diff < eps)\n            break;\n    }\n}\n\nint PolicyImprovement() {\n    Policies new_policies;\n    int diff = 0;\n    for (const auto &state : all_states) {\n        Policy new_policy = DoPI(state);\n        diff += 1 - (policies[state] == new_policy);\n        new_policies[state] = new_policy;\n    }\n    policies = new_policies;\n    return diff;\n}\n```\n\n`CalcPE(state)` 可以根据 Bellman 方程写出来：\n\n```c++\nReward CalcPE(const State &state) const {\n    const Policy &policy = policies.at(state);\n\n    Reward res = 0;\n    for (const auto &[action, prob] : policy) {\n        Reward imm_reward = CalcImmReward(state, action);\n        Reward dis_reward = CalcDisReward(state, action);\n        res += (imm_reward + dis_reward * gamma) * prob;\n    }\n    return res;\n}\n```\n\n（其中 `imm_reward` 是想表示 immediate reward，`dis_reward` 是想表示 discounted reward）\n\n`CalcImmReward(state, action)` 就是 $\\mathcal{R_s^a}$，根据具体的问题有所不同。\n\n`CalcDisReward(state, action)` 则可以继续写下去：\n\n```c++\nReward CalcDisReward(const State &state, const Action &action) const {\n    Reward res = 0;\n    for (const auto &state_p : all_states) {\n        res += values.at(state_p) * CalcPss(state, state_p, action);\n    }\n    return res;\n}\n```\n\n`CalcPss(state, state_p, action)` 就是 $\\mathcal{P_{ss’}^a}$ ，根据具体的问题有所不同。\n\n策略改进部分，根据价值贪心还是很好写的：\n\n```c++\nPolicy DoPI(const State &state) const {\n    Reward max = std::numeric_limits<Reward>::lowest();\n    int n_max = 0;\n    std::unordered_map<Action, Reward> temp_map;\n\n    for (const auto &action : all_actions) {\n        if (!state.CanDoAction(action))\n            continue;\n        Reward value = CalcDisReward(state, action);\n        temp_map[action] = value;\n        if (value > max) {\n            max = value;\n            n_max = 1;\n        } else if (value == max) {\n            ++n_max;\n        }\n    }\n\n    Policy new_policy;\n    double prob = 1.0 / n_max;\n    for (const auto &[action, reward] : temp_map) {\n        if (reward == max) {\n            new_policy[action] = prob;\n        }\n    }\n    return new_policy;\n}\n```\n\n以上部分对于任何满足条件的问题都是适用的，所以我把它们放进了一个类中，继承它的类需要根据具体问题实现 `CalcPss()`  和 `CalcImmReward()`。\n\n代码中的 `State`、`Action` 也是依赖具体问题的，所以做成了模版参数。其余的 `Reward`、`Policy` 等都是一些别名：\n\n```c++\nusing States = std::unordered_set<State, StateHash>;\nusing Actions = std::unordered_set<Action, ActionHash>;\nusing Reward = double;\nusing Values = std::unordered_map<State, Reward, StateHash>;\nusing Policy = std::unordered_map<Action, double, ActionHash>;\nusing Policies = std::unordered_map<State, Policy, StateHash>;\n```\n\n对于具体的借车问题，其状态就是一个数对表示车数，行动用 $[-5, 5]$ 的整数表示，正数表示从停车场一运到停车场二。\n\n在实现具体借车问题的 `CalcPss()` 和 `CalcImmReward()` 时，概率的计算部分是用了比较暴力的做法，直接枚举借车数与还车数，我是按照先借车不能借到负数，后还车不能还超容量枚举，这样算出的概率和实际也会有一定偏差，不过跑出来的结果看起来还是可以的。\n\n```c++\ndouble CalcPss(const State &state, const State &state_p,\n        const Action &action) const {\n    if (!state.CanDoAction(action))\n        return 0;\n\n    int new_x = std::min(state.x - action, kMaxCars);\n    int new_y = std::min(state.y + action, kMaxCars);\n    int delta_x = state_p.x - new_x;\n    int delta_y = state_p.y - new_y;\n\n    double pss = 0;\n    for (int req1 = std::max(0, -delta_x); req1 <= new_x; req1++) {\n        for (int req2 = std::max(0, -delta_y); req2 <= new_y; req2++) {\n            int ret1 = req1 + delta_x;\n            int ret2 = req2 + delta_y;\n            double prob = Poisson(req1, kAvgReq1) * Poisson(ret1, kAvgRet1)\n                * Poisson(req2, kAvgReq2) * Poisson(ret2, kAvgRet2);\n            pss += prob;\n        }\n    }\n    assert(pss >= 0);\n    return pss;\n}\n\nReward CalcImmReward(const State &state, const Action &action) const {\n    if (!state.CanDoAction(action))\n        return -1.0 / 0.0;\n    Reward move_reward = kMoveCost * std::abs(action);\n\n    Reward rent_reward = 0;\n    int new_x = std::min(state.x - action, kMaxCars);\n    int new_y = std::min(state.y + action, kMaxCars);\n    for (int req1 = 0; req1 <= new_x; req1++) {\n        for (int req2 = 0; req2 <= new_y; req2++) {\n            double prob_req = Poisson(req1, kAvgReq1) * Poisson(req2, kAvgReq2);\n            double prob_ret = 0;\n            for (int ret1 = 0; new_x - req1 + ret1 <= kMaxCars; ret1++) {\n                for (int ret2 = 0; new_y - req2 + ret2 <= kMaxCars; ret2++) {\n                    double prob = Poisson(ret1, kAvgRet1) *\n                        Poisson(ret2, kAvgRet2);\n                    prob_ret += prob;\n                }\n            }\n            rent_reward += prob_req * prob_ret * (req1 + req2) * kRentReward;\n        }\n    }\n\n    return move_reward + rent_reward;\n}\n```\n\n## 价值迭代 Value Iteration\n\n### 基本思想\n\n每次迭代，我们直接选取让回报最大的行动更新价值，这就是价值迭代。写成式子就是：\n$$\nv(s) = \\max_{a \\in \\mathcal{A}} \\left( \\mathcal{R_s^a} + \\gamma \\sum_{s' \\in \\mathcal{S}} \\mathcal{P_{ss'}^a} v(s') \\right)\n$$\n价值迭代的思想就是，反复迭代下去会得到最优策略。同样，这被证明是正确的。\n\n### 代码实现\n\n价值迭代与策略迭代有很大的相似性，比如相似的主框架：\n\n```c++\nvoid Train() {\n    while (true) {\n        double diff = BellmanOptimality();\n        if (diff < eps)\n            break;\n    }\n\n    policies = GetPoliciesFromValues();\n}\n```\n\n`BellmanOptimality()` 也同样是对每个状态做一些相同的事情：\n\n```c++\nReward BellmanOptimality() {\n    Values new_values;\n    Reward diff = 0;\n    for (const auto &state : all_states) {\n        Reward new_value = CalcOptimality(state);\n        diff += std::abs(new_value - values[state]);\n        new_values[state] = new_value;\n    }\n    values = new_values;\n    return diff;\n}\n```\n\n真正的计算函数也很直白：\n\n```c++\nReward CalcOptimality(const State &state) const {\n    Reward max = std::numeric_limits<Reward>::lowest();\n    for (const auto &action : all_actions) {\n        if (state.CanDoAction(action)) {\n            Reward imm_reward = CalcImmReward(state, action);\n            Reward dis_reward = CalcDisReward(state, action);\n            Reward reward = imm_reward + dis_reward * gamma;\n            max = std::max(max, reward);\n        }\n    }\n    return max;\n}\n```\n\n`CalcImmReward()` 和 `CalcDisReward()` 都是和策略迭代一样的。\n\n而最后的 `GetPoliciesFromValues()` 就是策略迭代的策略改进。\n\n可以发现，用于策略迭代的具体问题的 `CalcPss()` 和 `CalcImmReward()` 完全不需要修改。\n\n## 实现并行\n\n在借车问题中，策略迭代应该是跑了大概 1900s 的样子，价值迭代跑了大概 2200s。再看一下 `PolicyEvaluation()`、`PolicyImprovement()`、`BellmanOptimality()`、`GetPoliciesFromValues()`。它们都是对每一个状态做一些一样的事情，这些事情对公用的数据都是只读不写，不同状态之间相互独立，很容易改成并行的样子。\n\n实现中，使用 `std::vector<std::future<T>>` 来处理，以价值迭代为例：\n\n```c++\nReward BellmanOptimality() {\n    Values new_values;\n    Reward diff = 0;\n    std::vector<std::future<std::pair<Reward, State>>> handles;\n    for (const auto &state : all_states) {\n        handles.push_back(std::async(std::launch::async,\n                [this, &state]() { return this->CalcOptimality(state); }));\n    }\n    for (auto &future : handles) {\n        auto [new_value, state] = future.get();\n        diff += std::abs(new_value - values[state]);\n        new_values[state] = new_value;\n    }\n    values = new_values;\n    return diff;\n}\n```\n\n要让 `CalcOptimality(state)` 再把 `state` 返回来。可以看出来，对代码的改动很小。\n\n实测中，并行的价值迭代跑了 450s 左右。","tags":["课程笔记","实现笔记","强化学习"],"categories":["学习笔记（大学课外）"]},{"title":"CMU 15-213 A1 实现笔记","url":"/CMU-15-213-A1-实现笔记/","content":"\n之前的图形学的 15-462 在 1 月 9 日的时候跟完了，不过 A2 和 A4 没有写实现笔记（A4 可能考虑补写一下，也可能会鸽掉）。\n\n15-213 是 CS:APP 对应的课程，是我刚入大学时不久后就想跟的课程，一直拖到了现在，不过意外地发现可以和 CMU 同步。课程网站：[Introduction to Computer System - CMU 15-213](http://www.cs.cmu.edu/~./213/schedule.html)\n\n这课还有一个 A0，不过比较基础就不记录了（但还是花了比预想多 10～15min 的时间吧。。。）\n\nA1 的 pdf 没有挂在课程网站上，在 GitHub 上发现每年的题好像都略有不同，不过都挺有意思的。我用的是 [tinylcy/cmu-15213](https://github.com/tinylcy/cmu-15213) 的版本（其实是因为 clone 后才发现每年不一样。。。）。\n\nA1 是在一个比较严苛的约束下实现一些常见的操作，是若干道迷题的形式，感觉很好玩，而且有些并不容易。。。\n\n<!-- more -->\n\n## 简介\n\nA1（Data lab）是在一个比较严苛的约束下实现一些常见的操作，「严苛的约束」具体指：\n\n只允许：\n\n1. 使用 0 ～ 255 的 `int` 常量\n2. 定义 `int` 局部变量\n3. 使用运算符 `!`、`~`、`&`、`^`、`|`、`+`、`>>`、`<<`\n\n不允许：\n\n1. 使用条件控制与循环语句\n2. 定义或使用宏和函数\n3. 使用要求以外的运算符\n4. 使用任何形式的类型转换\n5. 使用 `int` 以外的类型（`int` 数组也是禁止的）\n\n可以认定：\n\n1. 使用补码\n2. `>>` 执行算术右移\n3. 超过字宽的移位操作是为定义的\n\n此外，每道题目都有运算符使用数目的限制。在一些题目中，可用运算符的种类会进一步减少。\n\n在浮点数部分，要求降低，额外允许：\n\n1. 条件控制与循环语句\n2. `||`、`&&`\n3. `unsigned int` 常量与变量，常量也不再有范围限制\n\n可以认定是 IEEE 754 的浮点数。\n\n题目还有 1、2、3、4 不同的分值，分值同时代表了难易度。\n\n## Bit Manipulations\n\n### 1.1 `bitAnd(int x, int y)`\n\n* 按位与\n* 额外限制：只允许 ~ 和 `|`\n* 运算符数目限制：8\n\n用德摩根定律就好了。\n\n```c\n/*\n * bitAnd - x&y using only ~ and |\n *   Example: bitAnd(6, 5) = 4\n *   Legal ops: ~ |\n *   Max ops: 8\n *   Rating: 1\n */\nint bitAnd(int x, int y) {\n  return ~((~x) | (~y));\n}\n```\n\n使用运算符数：4\n\n### 1.2 `getByte(int x, int n)`\n\n* 获取 $x$ 的从低位起第 $n$ 个字节的内容，从 $0$ 开始\n* 运算符数目限制：6\n\n右移并与 `0xFF` 取按位与就好了，乘以 2 的次幂用左移实现。\n\n```c\n/*\n * getByte - Extract byte n from word x\n *   Bytes numbered from 0 (LSB) to 3 (MSB)\n *   Examples: getByte(0x12345678,1) = 0x56\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 6\n *   Rating: 2\n */\nint getByte(int x, int n) {\n  return (x >> (n << 3)) & 0xFF;\n}\n```\n\n使用运算符数：3\n\n### 1.3 `logicalShift(int x, int n)`\n\n* 实现逻辑右移\n* 运算符数目限制：20\n\n逻辑右移后，高位一定都是 0，只要把算术右移的结果对形如 $(0\\dots01\\dots1)_2$ 的数取按位与就好了。\n\n实现中用到了算术右移的特性；此外，需要到右移 $n - 1$ 位，用右移后左移实现。\n\n```c\n/*\n * logicalShift - shift x to the right by n, using a logical shift\n *   Can assume that 0 <= n <= 31\n *   Examples: logicalShift(0x87654321,4) = 0x08765432\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 20\n *   Rating: 3\n */\nint logicalShift(int x, int n) {\n  return (x >> n) & ~(1 << 31 >> n << 1);\n}\n```\n\n使用运算符数：6\n\n### 1.4 `bitCount(int x)`\n\n* 求二进制下为 1 的位数\n* 运算符数目限制：40\n\n我承认，我不会，我太菜了。。。\n\n显然，一位一位的取出来并加起来运算符数是超了的。解决思路是分成 8 段，每段 4 位，先同步求出每段的 bitcount，再一半一半地加起来。\n\n```c\n/*\n * bitCount - returns count of number of 1's in word\n *   Examples: bitCount(5) = 2, bitCount(7) = 3\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 40\n *   Rating: 4\n */\n/* It is NOT my work... */\nint bitCount(int x) {\n  int m1 = 0x11 | (0x11 << 8);\n  int mask = m1 | (m1 << 16);\n  int s = x & mask;\n  s += x >> 1 & mask;\n  s += x >> 2 & mask;\n  s += x >> 3 & mask;\n  /* Now combine high and low order sums */\n  s = s + (s >> 16);\n\n  /* Low order 16 bits now consists of 4 sums.\n     Split into two groups and sum */\n  mask = 0xF | (0xF << 8);\n  s = (s & mask) + ((s >> 4) & mask);\n  return (s + (s >> 8)) & 0x3F;\n}\n```\n\n代码中，15 行结束后，s 中存了 8 段的 bitcount，这些和的最低位分别在第 0、4、8、……、24、28 位上；17 行合并第 0 位与第 16 位、第 4 位与第 20 位等的和；22 行合并第 0 位与 4 位、第 8 位与第 12 位；23 行合并仅剩的第 0 位与第 8 位。\n\n使用运算符数：25\n\n### 1.5 `bang(int x)`\n\n* 实现 `!x`\n* 额外限制：不能使用 `!`\n* 运算符数目限制：12\n\n同样的，一位一位地或起来会超数目，所以用一半一半合并的思路得到所有位或起来的值。\n\n这题做的比上一道早，明明这题里这个思路是能想到的，到上一题哪里怎么就想不到呢。。。QAQ\n\n这几个分值为 4 的题，感觉要不是搞过 OI/XCPC，不然大概率是做不出来了。。。\n\n```c\n/*\n * bang - Compute !x without using !\n *   Examples: bang(3) = 0, bang(0) = 1\n *   Legal ops: ~ & ^ | + << >>\n *   Max ops: 12\n *   Rating: 4\n */\nint bang(int x) {\n  int t0 =  x | (x >> 16);\n  int t1 = t0 | (t0 >> 8);\n  int t2 = t1 | (t1 >> 4);\n  int t3 = t2 | (t2 >> 2);\n  int t4 = t3 | (t3 >> 1);\n  return ~t4 & 1;\n}\n```\n\n使用运算符数：12（怕不是撞了标程）\n\n## Two’s Complement Arithmetic\n\n### 2.1 `tmin()`\n\n* 返回 `INT_MIN`\n* 运算符数目限制：4\n\n直接返回 `1 << 31` 就是了。\n\n```c\n/*\n * tmin - return minimum two's complement integer\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 4\n *   Rating: 1\n */\nint tmin(void) {\n  return 1 << 31;\n}\n```\n\n使用运算符数：1\n\n### 2.2 `fitsBits(int x, int n)`\n\n* 判断 $x$ 是否能用 $n$ 位下的补码正确表示\n* 运算符数目限制：15\n\n能在 $n$ 位补码表示的数有一个特性是，除去低 $n - 1$ 位，剩下的高位部分不是全 1 就是全 0，只要能判断一种情况，再用相同的方法判断一次 `~x` ，把结果或起来即可。\n\n我选择判断全 1，想法是用形如 $(1\\dots 10\\dots0)_2$ 的数与 $x$ 按位与，判断得到的结果是否还满足这个形式，而这个形式的数在右移几位后（这里是 $n$ 位）会得到 -1，-1 可以加一后用 `!` 判断。\n\n减法用加补码实现，也就是代码里的 `n + ~0`。\n\n```c\n/*\n * fitsBits - return 1 if x can be represented as an\n *  n-bit, two's complement integer.\n *   1 <= n <= 32\n *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint fitsBits(int x, int n) {\n  int mask, t, r0, r1;\n  n = n + ~0;\n  mask = ~(1 << n) + 1;\n  t = (mask & x) >> n;\n  r0 = !(t + 1);\n  x = ~x;\n  t = (mask & x) >> n;\n  r1 = !(t + 1);\n  return r0 | r1;\n}\n```\n\n使用运算符数：12\n\n### 2.3 `divpwr2(int x, int n)`\n\n* 计算 $x / (2^n)$，向零取整\n* 运算符数目限制：15\n\n算术右移是向下取整，与向零取整的区别仅在负数时出现，所以只要分别计算向下取整和向上取整的结果，取出符号位后用类似 2-1 多路复用器的思路做返回值。（学了数逻后发现不会用多路复用器以外的词来描述这个东西。这个思路在我后续的解题中还出现了不少）\n\n```c\n/*\n * divpwr2 - Compute x/(2^n), for 0 <= n <= 30\n *  Round toward zero\n *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 15\n *   Rating: 2\n */\nint divpwr2(int x, int n) {\n  int r0, r1, sgn;\n  r0 = x >> n;\n  r1 = (x + (1 << n) + ~0) >> n;\n  sgn = x & (1 << 31);\n  sgn = sgn >> 31;\n  return (sgn & r1) | (~sgn & r0);\n}\n```\n\n14 行利用了算术右移的特性，把 `sgn` 变成全 1 或全 0。\n\n使用运算符数：13\n\n### 2.4 `negate(int x)`\n\n* 返回相反数\n* 运算符数目限制：5\n\n补码的定义。\n\n```c\n/*\n * negate - return -x\n *   Example: negate(1) = -1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 5\n *   Rating: 2\n */\nint negate(int x) {\n  return ~x + 1;\n}\n```\n\n使用运算符数：2\n\n### 2.5 `isPositive(int x)`\n\n* 判断是否为正数\n* 运算符数目限制：8\n\n判断符号位能判断出非负数，再额外判一个 0 即可。\n\n```c\n/*\n * isPositive - return 1 if x > 0, return 0 otherwise\n *   Example: isPositive(-1) = 0.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 8\n *   Rating: 3\n */\nint isPositive(int x) {\n  int sgn = x & (1 << 31);\n  return !sgn & (!!x);\n}\n```\n\n使用运算符数：6\n\n### 2.6 `isLessOrEqual(int x, int y)`\n\n* 判断是否 $x \\leq y$\n* 运算符数目限制：24\n\n等价于判断 $y - x \\geq 0$ ，只需判断差的符号位，但这个差会爆 `int`，所以考虑分高低 16 位判断。\n\n高位的差为正数，或高位差为 0 且低位差非负就说明 $x \\leq y$。\n\n```c\n/*\n * isLessOrEqual - if x <= y  then return 1, else return 0\n *   Example: isLessOrEqual(4,5) = 1.\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 24\n *   Rating: 3\n */\nint isLessOrEqual(int x, int y) {\n  int sgn, mask;\n  int xh, xl, yh, yl, dh, dl, sh, sl, rh, rl;\n  sgn = 1 << 31;\n  mask = (1 << 16) + ~0;\n  xh = x >> 16;\n  yh = y >> 16;\n  xl = x & mask;\n  yl = y & mask;\n  dh = yh + ~xh;\n  dl = yl + ~xl + 1;\n  sh = dh & sgn;\n  sl = dl & sgn;\n  rh = !sh;\n  rl = !(dh + 1) & !sl;\n  return rh | rl;\n}\n```\n\n使用运算符数：21\n\n一开始觉得负数的算术右移会影响我，想着转成无符号数比较（反转符号位后的无符号数大小关系与原来的有符号数大小关系相同），但运算符数超了 1 个。。。\n\n### 2.7 `ilog2(int x)`\n\n* 返回 $\\lfloor \\log_2(x) \\rfloor$\n* 运算符数目限制：90\n\n看到 90 时吓了一跳，想了一段时间后还是出来了。\n\n一开始写成了与 lowbit 相对应的「highbit」（即小于等于 $x$ 的最大的 2 的整次幂），不过改成要求的东西并不需要改多少。\n\n尽管限制有 90 个，一位一位地做还是会超的。\n\n考虑依次用 `0xFFFF_0000`、`0xFF00_FF00`、`0xF0F0_F0F0`、`0xCCCC_CCCC`、`0xAAAA_AAAA` 的掩码取判断，第一个掩码检测通过时，答案加 16，否则不变，之后用结果改变第二个掩码为 `0xFF00_0000` 或 `0x0000_FF00` ；第二个掩码通过时加 8，之后改变第三个掩码为 `0xF000_0000` 、`0x00F0_0000` 、`0x0000_F000` 、`0x0000_00F0` 中的一个，以此类推。\n\n```c\n/*\n * ilog2 - return floor(log base 2 of x), where x > 0\n *   Example: ilog2(16) = 4\n *   Legal ops: ! ~ & ^ | + << >>\n *   Max ops: 90\n *   Rating: 4\n */\nint ilog2(int x) {\n  int m2, m4, m8, m16, m32, mask;\n  int t, b0, b1, res;\n\n  t = 1 << 31 >> 15;\n  m2 = t; // 0xFFFF_0000\n\n  t = t << 8;\n  mask = (1 << 16) + ~0;\n  m4 = (t >> 16) & mask;\n  m4 = m4 | (m4 << 16); // 0xFF00_FF00\n\n  m8 = 0xF0;\n  m8 = m8 | (m8 << 8);\n  m8 = m8 | (m8 << 16); // 0xF0F0_F0F0\n\n  m16 = 0xCC;\n  m16 = m16 | (m16 << 8);\n  m16 = m16 | (m16 << 16); // 0xCCCC_CCCC\n\n  m32 = 0xAA;\n  m32 = m32 | (m32 << 8);\n  m32 = m32 | (m32 << 16); // 0xAAAA_AAAA\n\n  t = x & m2;\n  b0 = (!t) << 31 >> 31;\n  b1 = ~b0;\n  mask = (b0 & m2) | (b1 & ~m2);\n  m4 = m4 & ~mask;\n  res = b1 & 16;\n\n  t = x & m4;\n  b0 = (!t) << 31 >> 31;\n  b1 = ~b0;\n  mask = mask | (b0 & m4) | (b1 & ~m4);\n  m8 = m8 & ~mask;\n  res = res + (b1 & 8);\n\n  t = x & m8;\n  b0 = (!t) << 31 >> 31;\n  b1 = ~b0;\n  mask = mask | (b0 & m8) | (b1 & ~m8);\n  m16 = m16 & ~mask;\n  res = res + (b1 & 4);\n\n  t = x & m16;\n  b0 = (!t) << 31 >> 31;\n  b1 = ~b0;\n  mask = mask | (b0 & m16) | (b1 & ~m16);\n  m32 = m32 & ~mask;\n  res = res + (b1 & 2);\n\n  t = x & m32;\n  b0 = (!t) << 31 >> 31;\n  b1 = ~b0;\n  // mask = mask | (b0 & m32) | (b1 & ~m32);\n  res = res + (b1 & 1);\n\n  return res;\n}\n```\n\n使用运算符数：好像是 83，不想再数一遍了。。。\n\n65 行的注释去掉，返回 `~mask` 就是所谓「highbit」了。\n\n## Floating-Point Operations\n\n### 3.1 `float_neg(unsigned uf)`\n\n* 返回 `uf` 相应的单精度浮点数的相反数，若为 NaN 则返回原值\n* 运算符数目限制：10\n\n只要根据 IEEE 754 判断 NaN 就好了。\n\n```c\n/*\n * float_neg - Return bit-level equivalent of expression -f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representations of\n *   single-precision floating point values.\n *   When argument is NaN, return argument.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 10\n *   Rating: 2\n */\nunsigned float_neg(unsigned uf) {\n  int mask = 0x7F800000;\n  if ((mask & uf) == mask) {\n    mask = ~mask ^ (1 << 31);\n    if (mask & uf) return uf;\n  }\n  return uf ^ (1 << 31);\n}\n```\n\n使用运算符数：7（好像是不算关系比较符的）\n\n### 3.2 `float_i2f(int x)`\n\n* 返回 `(float) x`\n* 运算符数目限制：30\n\n`(float) x` 是「四舍六入五靠偶」的，确切地说，是正好一半才靠偶。本题的唯一难点也就在这了。\n\n```c\n/*\n * float_i2f - Return bit-level equivalent of expression (float) x\n *   Result is returned as unsigned int, but\n *   it is to be interpreted as the bit-level representation of a\n *   single-precision floating point values.\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_i2f(int x) {\n  int highbit, lb, sgn, exp;\n  unsigned res, y;\n  if (x < 0) {\n    y = -x;\n    sgn = 0x80000000;\n  } else {\n    y = x;\n    sgn = 0;\n  }\n  for (highbit = 31; highbit >= 0; highbit--) if (y & (1 << highbit))\n    break;\n  if (highbit < 0) return 0;\n  lb = highbit - 23;\n  if (highbit >= 24) {\n    int mask = (1 << lb) - 1;\n    int half = 1 << (lb - 1);\n    int trunc = y & mask;\n    res = y >> lb;\n    if (trunc > half || (trunc == half && (res & 1))) {\n      ++res;\n      if (res & 0x01000000) {\n        res = res >> 1;\n        ++highbit;\n      }\n    }\n  } else {\n    res = y << (-lb);\n  }\n  res = res | sgn;\n  exp = highbit + 127;\n  res = (res & 0x807FFFFF) | (exp << 23);\n  return res;\n}\n```\n\n使用运算符数：26（好像是不算关系比较符的）\n\n为了减少数目把类似 `1 << xxx` 的数都写成常数了。\n\n### 3.3 `float_twice(unsigned uf)`\n\n* 返回 `uf` 相应的浮点数的两倍，NaN 则返回原值\n* 运算符数目限制：30\n\n其实 inf 也是返回原值，而 inf 和 NaN 的指数部分是一样的。\n\n规约化数只要指数部分加一，\n\n而非规约化数，无论两倍后是非规约化数还是规约化数，操作都是左移底数，当结果是规约化数的时候正好是对的。\n\n```c\n/*\n * float_twice - Return bit-level equivalent of expression 2*f for\n *   floating point argument f.\n *   Both the argument and result are passed as unsigned int's, but\n *   they are to be interpreted as the bit-level representation of\n *   single-precision floating point values.\n *   When argument is NaN, return argument\n *   Legal ops: Any integer/unsigned operations incl. ||, &&. also if, while\n *   Max ops: 30\n *   Rating: 4\n */\nunsigned float_twice(unsigned uf) {\n  int exp, frac;\n  unsigned res;\n  if ((uf & 0x7F800000) == 0x7F800000) return uf;\n  exp = uf & 0x7F800000;\n  frac = uf & 0x007FFFFF;\n  if (exp) {\n    exp = exp + 0x00800000;\n    res = (uf & 0x807FFFFF) | exp;\n  } else {\n    res = (uf & 0xFF800000) | (frac << 1);\n  }\n  return res;\n}\n```\n\n使用运算符数：9","tags":["CMU","课程笔记","实现笔记"],"categories":["学习笔记（大学课外）"]},{"title":"2019 ICPC EC-Final 游记","url":"/2019-ICPC-EC-Final-游记/","content":"\n* 队伍：Wheatfield with Crows\n* 队员：邓浩然（HbFS-）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：5/13（A，C，E，H，M）\n* 罚时：627\n* 排名：27/384\n\n<!-- more -->\n\n### Day -1\n\n晚上到了西安，路上的时间太长了，搞得人有点累。路上写了大雾作业，晚上又写了点数逻实验。\n\n学校好偏啊。。。\n\n### Day 0\n\n早（晚）起去报道，人好多（说来一想到今年去过的最大的赛区是 EC-Final 就感觉很离谱。。。），要了蓝色的包后瞬间就后悔了。。。\n\n拍了滚榜用的照但据说最后也没有滚榜。。。\n\n中午又写了会儿数逻。。。\n\n下午热身赛发现插气球的那个牌子上的字是从各个学校的校徽上摘的就很开心，然后被屏幕上用校徽做的壁纸震惊到了。。。\n\n感觉整个热身赛都在想题，没有测啥东西的样子。。。时间靠 B 觉得跑得挺快的。\n\n晚上三人被父母请了晚饭。\n\n### Day 1\n\n一如既往登录配 vim。配完后 lsy 写 A，**A1y15**。\n\n我下机后读了些题（大都是最后没人过的。。。），M 差点想偏到网络流，幸亏 dhr 提出次幂不相交的事情，我算了一下发现 2 的次幂枚举复杂度是对的，于是 **M1y42**。\n\ndhr 觉得 H 是随机算法，算了一波概率和时间后就上机 WA 了，之后改了一些错误后 **H4y67**。\n\n之后和 dhr 讨论 E，dhr 想了想觉得用一个堆就好了，我一时没太听明白，结果变成了他说我写，在 WA 了一发后我终于完全清楚我在写啥后，改了一处和 dhr 想的不太一样的地方后 **E2y121**。\n\n之后我觉得数学、尤其是卷积的题我还是可以的，于是在想 C；lsy 期间读了 G，有一处没搞清楚的题意发了提问但得到了蒙逼逼的答复，之后又去想她喜欢的树的 D。\n\n一段时间后我开出了 C，几乎是一发过了样例，提交 WA。之后下机交给 lsy 上机，自己找 dhr debug。花了挺长时间陆陆续续改了包括乘法写成求幂、一处没有取模、两三处下标写错后终于 **C6y202**。感觉自己真的每次都把代码完整地读过一遍，但每次真的只看到了一处错误。。。\n\nlsy 的 D 过了样例但是 WA 了。这是她发现有好多靠后的队伍过了 G，她重拾 G 后发现那个题意问题没有影响，这是我内心一副我们还有两个题的心态，这时大概还有 90～100min 的样子。lsy 表示她先写 G，我这时去看 D 和 G 的题面，以及 D 的代码，但感觉 D 的代码不是很好看，要想的细节有点多，就只好在脑中跑几个小样例，发现都对了。\n\nlsy 的 G 没有过样例，之后发现是读错了题，本以为是所有题都会做完。之后提出 2 的次幂枚举 + 从大到小和从小到大做题，想了想觉得对就有接着写了一会儿。放弃查 D 的我去看了看 G 的代码，发现没有考虑一血奖励，说出来后发现之前的做法就有问题了，于是又换回 D debug，这时大概还有 30min 左右。\n\nlsy 改了一个地方，测了一个样例，发现她认为正确的结果和我想的有点不同，结果发现好像是没有考虑只有非负的时候才能使用魔法。于是封榜后没有过题，看着封榜前的 rk20，觉得勉强有 Au。最后 rk27，感觉有种靠着人多蹭了一个 Au 的感觉。。。\n\n之后三人被 dhr 父母请了晚饭。飞机到杭州时都快 0 点了，等回寝室已经是快 2 点了，之后还要 6:40 起床度过这一天 10 节课的周一。。。\n\n### 总结\n\n赛季就这么结束了，我也就这么彻底退役了。虽然打得很演，但勉强收尾得还算可以吧。从去年只有一场的预备队 Nameless_Sunstar 到今年打满五场的三队的 Wheatfield with Crows，总共 2Ag 4Au 地退役了呢。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"CMU 15-462 A3 实现笔记","url":"/CMU-15-462-A3-实现笔记/","content":"\n上次写了 A1 的实现笔记，A2 感觉基本都是有很多细节的大模拟所以不想写实现笔记了（代码在 GitHub 上），一开始写得感觉都还可以，最后写完 downsample 和 resample 时发现之前写的有一个 corner case 没有想到，导致 RE，搞得心态也有点崩。。。（不过也算是完成 A2 了吧，尽管不是完美完成。。。）\n\nA3 是路径追踪的内容，算是挺喜欢的内容了。。。实现部分有参考 Ubpa 的实现：https://github.com/Ubpa/CMU_15_462\n\n之前也跟过 Ray Tracing in One Weekend 三本，但感觉还是有不太理解的地方。想着之后可以把 PBR 的那本看一看好了。\n\n笔记和代码有放在 GitHub 上：https://github.com/PepcyCh/cmu15462-notes\n\n课程： [Computer Graphics (CMU 15-462)](http://15462.courses.cs.cmu.edu/fall2018/)\n\n<!-- more -->\n\n## Task 1: Generating Camera Rays\n\n要求实现摄像机射出光线的代码，在 `camera.cpp` 中：\n\n```c++\nRay Camera::generate_ray(double x, double y) const {\n  // compute position of the input sensor sample coordinate on the\n  // canonical sensor plane one unit away from the pinhole.\n\n  Vector3D tar = Vector3D((x - .5) * screenW, (y - .5) * screenH, -screenDist);\n  Vector3D dir = c2w * tar;\n  dir.normalize();\n  Vector3D org = pos;\n\n  return Ray(org, dir);\n}\n```\n\n`- .5` 是把原点从左下角调至中心。\n\n一开始没有单位化，一切都很正常，直到我实现最后一项时出了问题。。。（当时想当然地以为方向向量是单位化的，却看到自己没有这么做。。。）\n\n然后把各种 Sampler 实现了一波：\n\n```c++\nVector2D JitteredSampler::get_sample() const {\n  static std::vector<Vector2D> samples(ns_aa);\n  static int curr = ns_aa;\n  if (curr == ns_aa) {\n    int w = std::sqrt(ns_aa);\n    curr = 0;\n    for (int i = 0; i < w; i++) {\n      for (int j = 0; j < w; j++) {\n        double x = (i + double(std::rand()) / RAND_MAX) / w;\n        double y = (j + double(std::rand()) / RAND_MAX) / w;\n        samples[curr++] = Vector2D(x, y);\n      }\n    }\n    curr = 0;\n  }\n  return samples[curr++];\n}\n\nVector2D MultiJitteredSampler::get_sample() const {\n    static std::vector<Vector2D> samples(ns_aa);\n    static int curr = ns_aa;\n    if (curr == ns_aa) {\n        int w = std::sqrt(ns_aa);\n        curr = 0;\n        int u = 0, v = 0;\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < w; j++) {\n                double x = (u + double(std::rand()) / RAND_MAX) / w;\n                double y = (v + double(std::rand()) / RAND_MAX) / w;\n                samples[curr++] = Vector2D(x, y);\n                if (v == w - 1) {\n                    ++u;\n                    v = 0;\n                } else {\n                    ++v;\n                }\n            }\n        }\n        std::random_shuffle(samples.begin(), samples.begin() + curr);\n        curr = 0;\n        for (int i = 0; i < w; i++) {\n            for (int j = 0; j < w; j++) {\n                double x = (i + samples[curr].x) / w;\n                double y = (j + samples[curr].y) / w;\n                samples[curr++] = Vector2D(x, y);\n            }\n        }\n        curr = 0;\n    }\n    return samples[curr++];\n}\n\nVector2D NRooksSampler::get_sample() const {\n    static std::vector<Vector2D> samples(ns_aa);\n    static int curr = ns_aa;\n    if (curr == ns_aa) {\n        curr = 0;\n        std::vector<double> X(ns_aa), Y(ns_aa);\n        for (int i = 0; i < ns_aa; i++) {\n            X[i] = (i + double(std::rand()) / RAND_MAX) / ns_aa;\n            Y[i] = (i + double(std::rand()) / RAND_MAX) / ns_aa;\n        }\n        std::random_shuffle(Y.begin(), Y.end());\n        for (int i = 0; i < ns_aa; i++) {\n            samples[i] = Vector2D(X[i], Y[i]);\n        }\n        curr = 0;\n    }\n    return samples[curr++];\n}\n\nstatic double radicalInverse3(int i) {\n    double b = 1. / 3.;\n    double t = b;\n    double res = 0;\n    while (i) {\n        res += t * (i % 3);\n        t *= b;\n        i /= 3;\n    }\n    return res;\n}\nstatic double radicalInverse2(int i) {\n    double t = 1. / 2.;\n    double res = 0;\n    while (i) {\n        res += t * (i & 1);\n        t /= 2.;\n        i >>= 1;\n    }\n    return res;\n}\n\nVector2D SobolSampler::get_sample() const {\n    static std::vector<Vector2D> samples(ns_aa);\n    static bool init = false;\n    static int curr = ns_aa;\n    if (!init) {\n        std::vector<unsigned> C(ns_aa), V(32);\n        for (int i = 0; i < ns_aa; i++) {\n            int w = i;\n            C[i] = 1;\n            while (w & 1) {\n                ++C[i];\n                w >>= 1;\n            }\n        }\n        for (int i = 1; i <= 31; i++) V[i] = 1 << (32 - i);\n\n        std::vector<unsigned> X(ns_aa);\n        X[0] = 0;\n        for (int i = 1; i < ns_aa; i++) {\n            X[i] = X[i - 1] ^ V[C[i - 1]];\n            samples[i].x = X[i] / std::pow(2., 32.);\n        }\n\n        V[1] = 1 << 31;\n        for (int i = 2; i <= 31; i++) V[i] = V[i - 1] ^ (V[i - 1] >> 1);\n        X[0] = 0;\n        for (int i = 1; i < ns_aa; i++) {\n            X[i] = X[i - 1] ^ V[C[i - 1]];\n            samples[i].y = X[i] / std::pow(2., 32.);\n        }\n        init = true;\n    }\n    if (curr == ns_aa) curr = 0;\n    return samples[curr++];\n}\n\nVector2D HaltonSampler::get_sample() const {\n    static std::vector<Vector2D> samples(ns_aa);\n    static bool init = false;\n    static int curr = ns_aa;\n    if (!init) {\n        for (int i = 0; i < ns_aa; i++) {\n            double x = radicalInverse2(i);\n            double y = radicalInverse3(i);\n            samples[i] = Vector2D(x, y);\n        }\n        init = true;\n    }\n    if (curr == ns_aa) curr = 0;\n    return samples[curr++];\n}\n\nVector2D HammersleySampler::get_sample() const {\n    static std::vector<Vector2D> samples(ns_aa);\n    static bool init = false;\n    static int curr = ns_aa;\n    if (!init) {\n        for (int i = 0; i < ns_aa; i++) {\n            double x = double(i) / ns_aa;\n            double y = radicalInverse2(i);\n            samples[i] = Vector2D(x, y);\n        }\n        init = true;\n    }\n    if (curr == ns_aa) curr = 0;\n    return samples[curr++];\n}\n```\n\n这个实现中，除 Sobol、Halton 和 Hammersley 都不能在多线程下正常工作。。。\n\n之后我一直用的是 Sobol，在 `pathtracer.cpp` 中的构造函数部分做了修改：\n\n```c++\n  // gridSampler = new UniformGridSampler2D();\n  // gridSampler = new JitteredSampler(ns_aa);\n  // gridSampler = new MultiJitteredSampler(ns_aa);\n  // gridSampler = new NRooksSampler(ns_aa);\n  gridSampler = new SobolSampler(ns_aa);\n  // gridSampler = new HaltonSampler(ns_aa);\n  // gridSampler = new HammersleySampler(ns_aa);\n```\n\n## Task 2: Intersecting Triangles and Spheres\n\n球体，在 `static_sence/sphere.cpp`:\n\n```c++\nbool Sphere::test(const Ray& r, double& t1, double& t2) const {\n  // Implement ray - sphere intersection test.\n  // Return true if there are intersections and writing the\n  // smaller of the two intersection times in t1 and the larger in t2.\n\n  Vector3D oc = r.o - o;\n  double a = r.d.norm2();\n  double b = dot(oc, r.d);\n  double c = oc.norm2() - r2;\n  double disc = b * b - a * c;\n  if (disc > 0) {\n    double sqrtd = sqrt(disc);\n    t1 = (-b - sqrtd) / a;\n    t2 = (-b + sqrtd) / a;\n    return true;\n  }\n  return false;\n}\n\nbool Sphere::intersect(const Ray& r) const {\n  // Implement ray - sphere intersection.\n  // Note that you might want to use the the Sphere::test helper here.\n  double t1, t2;\n  if (test(r, t1, t2)) {\n    return !(t1 > r.max_t || t2 < r.min_t);\n  }\n\n  return false;\n}\n\nbool Sphere::intersect(const Ray& r, Intersection* isect) const {\n  // Implement ray - sphere intersection.\n  // Note again that you might want to use the the Sphere::test helper here.\n  // When an intersection takes place, the Intersection data should be updated\n  // correspondingly.\n\n  double t1, t2;\n  if (test(r, t1, t2)) {\n    if (t1 > r.max_t || t2 < r.min_t) return false;\n    isect->primitive = this;\n    isect->bsdf = get_bsdf();\n    if (t1 > r.min_t) {\n      r.max_t = isect->t = t1;\n      isect->n = (r.o + t1 * r.d - o);\n      isect->n.normalize();\n    } else {\n      r.max_t = isect->t = t2;\n      isect->n = (r.o + t2 * r.d - o);\n      isect->n.normalize();\n    }\n    return true;\n  }\n\n  return false;\n}\n```\n\n三角形，在 `static_sence/triangle.cpp`:\n\n```c++\nbool Triangle::intersect(const Ray& r) const {\n  Vector3D p1 = mesh->positions[v1];\n  Vector3D p2 = mesh->positions[v2];\n  Vector3D p3 = mesh->positions[v3];\n\n  Vector3D e1 = p2 - p1;\n  Vector3D e2 = p3 - p1;\n  Vector3D s = r.o - p1;\n\n  double det = dot(cross(e1, r.d), e2);\n  if (det != 0) {\n    double du = -dot(cross(s, e2), r.d);\n    double dv = dot(cross(e1, r.d), s);\n    double dt = -dot(cross(s, e2), e1);\n    double u = du / det;\n    double v = dv / det;\n    double t = dt / det;\n    if (u < 0 || v < 0 || 1 - u - v < 0) return false;\n    return !(t < r.min_t || t > r.max_t);\n  } else {\n    double t;\n    if (doesRayIntersectSegment(r, p1, p2, t)) return !(t < r.min_t || t > r.max_t);\n    if (doesRayIntersectSegment(r, p1, p3, t)) return !(t < r.min_t || t > r.max_t);\n    if (doesRayIntersectSegment(r, p2, p3, t)) return !(t < r.min_t || t > r.max_t);\n  }\n\n  return false;\n}\n\nbool Triangle::intersect(const Ray& r, Intersection* isect) const {\n  // implement ray-triangle intersection. When an intersection takes\n  // place, the Intersection data should be updated accordingly\n\n  Vector3D p1 = mesh->positions[v1];\n  Vector3D p2 = mesh->positions[v2];\n  Vector3D p3 = mesh->positions[v3];\n  Vector3D n1 = mesh->normals[v1];\n  Vector3D n2 = mesh->normals[v2];\n  Vector3D n3 = mesh->normals[v3];\n\n  Vector3D e1 = p2 - p1;\n  Vector3D e2 = p3 - p1;\n  Vector3D s = r.o - p1;\n\n  double det = dot(cross(e1, r.d), e2);\n  if (det != 0) {\n    double du = -dot(cross(s, e2), r.d);\n    double dv = dot(cross(e1, r.d), s);\n    double dt = -dot(cross(s, e2), e1);\n    double u = du / det;\n    double v = dv / det;\n    double t = dt / det;\n    if (u < 0 || v < 0 || 1 - u - v < 0) return false;\n    if (t < r.min_t || t > r.max_t) return false;\n    isect->n = u * n1 + v * n2 + (1 - u - v) * n3;\n    if (dot(isect->n, r.d) > 0) isect->n = -isect->n;\n    r.max_t = isect->t = t;\n    isect->primitive = this;\n    isect->bsdf = get_bsdf();\n    return true;\n  } else {\n    Matrix3x3 inv = Matrix3x3();\n    inv.column(0) = p1;\n    inv.column(1) = p2;\n    inv.column(2) = p3;\n    inv = inv.inv();\n    double t, u, v;\n    bool inter = false;\n    if (doesRayIntersectSegment(r, v1, v2, t)) {\n      if (t < r.min_t || t > r.max_t) return false;\n      Vector3D ret = inv * (r.o + t * r.d);\n      u = ret.x;\n      v = ret.y;\n      inter = true;\n    }\n    if (doesRayIntersectSegment(r, v1, v3, t)) {\n      if (t < r.min_t || t > r.max_t) return false;\n      Vector3D ret = inv * (r.o + t * r.d);\n      u = ret.x;\n      v = ret.y;\n      inter = true;\n    }\n    if (doesRayIntersectSegment(r, v2, v3, t)) {\n      if (t < r.min_t || t > r.max_t) return false;\n      Vector3D ret = inv * (r.o + t * r.d);\n      u = ret.x;\n      v = ret.y;\n      inter = true;\n    }\n    if (!inter) return false;\n    isect->n = u * n1 + v * n2 + (1 - u - v) * n3;\n    if (dot(isect->n, r.d) > 0) isect->n = -isect->n;\n    r.max_t = isect->t = t;\n    isect->primitive = this;\n    isect->bsdf = get_bsdf();\n    return true;\n  }\n}\n```\n\n感觉当光线与三角面平行时的处理写得有点丑。\n\n## Task 3: Implementing a Bounding Volume Hierarchy (BVH)\n\n先实现了包围盒的光线检测，在 `bbox.cpp`：\n\n```c++\nbool BBox::intersect(const Ray &r, double &t0, double &t1) const {\n  // Implement ray - bounding box intersection test\n  // If the ray intersected the bounding box within the range given by\n  // t0, t1, update t0 and t1 with the new intersection times.\n\n  t0 = r.min_t;\n  t1 = r.max_t;\n  for (int d = 0; d < 3; d++) {\n      double tt0 = std::min((min[d] - r.o[d]) * r.inv_d[d], (max[d] - r.o[d]) * r.inv_d[d]);\n      double tt1 = std::max((min[d] - r.o[d]) * r.inv_d[d], (max[d] - r.o[d]) * r.inv_d[d]);\n      t0 = std::max(t0, tt0);\n      t1 = std::min(t1, tt1);\n      if (t0 > t1) return false;\n  }\n\n  return t0 < r.max_t;\n}\n```\n\n写的时候去看了当时跟 Ray Tracing in One Weeken 的代码，发现当时包围盒检查有两处 min 和 max 写的是反的。。。难怪当时跑得那么慢。。。\n\n建 BVH 树和查询都写成非递归的了，在 `bvh.cpp`：\n\n```c++\nBVHAccel::BVHAccel(const std::vector<Primitive *> &_primitives,\n                   size_t max_leaf_size) {\n    static const int B = 16;\n\n    this->primitives = _primitives;\n\n    // Construct a BVH from the given vector of primitives and maximum leaf\n    // size configuration. The starter code build a BVH aggregate with a\n    // single leaf node (which is also the root) that encloses all the\n    // primitives.\n\n    BBox bb;\n    for (int i = 0; i < primitives.size(); i++) {\n        bb.expand(primitives[i]->get_bbox());\n    }\n    root = new BVHNode(bb, 0, primitives.size());\n\n    std::queue<BVHNode *> q;\n    q.push(root);\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n        if (u->range <= max_leaf_size) continue;\n\n        int bestD = -1, bestI = -1;\n        double SN = u->bb.surface_area(), bestC = DBL_MAX;\n\n        for (int d = 0; d < 3; d++) {\n            std::vector<BBox> boxes(B);\n            std::vector<std::vector<Primitive*>> prims(B);\n            double min = u->bb.min[d], max = u->bb.max[d];\n            double length = (max - min) / B;\n            if (length == 0) continue;\n\n            for (size_t i = 0; i < u->range; i++) {\n                BBox cb = primitives[u->start + i]->get_bbox();\n                double p = cb.centroid()[d];\n                int buc = clamp<int>((p - min) / length, 0, B - 1);\n                prims[buc].push_back(primitives[u->start + i]);\n                boxes[buc].expand(cb);\n            }\n\n            for (int i = 1; i < B; i++) {\n                BBox lb, rb;\n                int ln = 0, rn = 0;\n                for (int j = 0; j < i; j++) {\n                    lb.expand(boxes[j]);\n                    ln += prims[j].size();\n                }\n                for (int j = i; j < B; j++) {\n                    rb.expand(boxes[j]);\n                    rn += prims[j].size();\n                }\n                double SA = lb.surface_area(), SB = rb.surface_area();\n                double C = SA / SN * ln + SB / SN * rn;\n                if (C < bestC) {\n                    bestD = d;\n                    bestI = i;\n                    bestC = C;\n                }\n            }\n        }\n\n        double min = u->bb.min[bestD], max = u->bb.max[bestD];\n        double length = (max - min) / B;\n        BBox lb, rb;\n        std::vector<Primitive *> lp, rp;\n        for (size_t i = 0; i < u->range; i++) {\n            BBox cb = primitives[u->start + i]->get_bbox();\n            double p = cb.centroid()[bestD];\n            int buc = clamp<int>((p - min) / length, 0, B - 1);\n            if (buc < bestI) {\n                lb.expand(cb);\n                lp.push_back(primitives[u->start + i]);\n            } else {\n                rb.expand(cb);\n                rp.push_back(primitives[u->start + i]);\n            }\n        }\n\n        if (lp.size() == 0 || lp.size() == u->range) {\n            lb = BBox(), rb = BBox();\n            int hn = u->range / 2;\n            for (int i = 0; i < hn; i++) lb.expand(primitives[u->start + i]->get_bbox());\n            for (int i = hn; i < u->range; i++) rb.expand(primitives[u->start + i]->get_bbox());\n            u->l = new BVHNode(lb, u->start, hn);\n            u->r = new BVHNode(rb, u->start + hn, u->range - hn);\n            q.push(u->l);\n            q.push(u->r);\n        } else {\n            int p = 0;\n            for (auto prim : lp) {\n                primitives[u->start + p] = prim;\n                ++p;\n            }\n            int ln = p;\n            for (auto prim : rp) {\n                primitives[u->start + p] = prim;\n                ++p;\n            }\n            u->l = new BVHNode(lb, u->start, ln);\n            u->r = new BVHNode(rb, u->start + ln, u->range - ln);\n            q.push(u->l);\n            q.push(u->r);\n        }\n    }\n}\n\n\nBVHAccel::~BVHAccel() {\n  // Implement a proper destructor for your BVH accelerator aggregate\n\n  std::queue<BVHNode *> q;\n  q.push(root);\n  while (!q.empty()) {\n    auto u = q.front();\n    q.pop();\n    if (u->l) q.push(u->l);\n    if (u->r) q.push(u->r);\n    delete u;\n  }\n}\n\n// ...\n\nbool BVHAccel::intersect(const Ray &ray) const {\n  // Implement ray - bvh aggregate intersection test. A ray intersects\n  // with a BVH aggregate if and only if it intersects a primitive in\n  // the BVH that is not an aggregate.\n\n  bool hit = false;\n\n  std::stack<BVHNode *> s;\n  s.push(root);\n  while (!s.empty()) {\n    auto u = s.top();\n    s.pop();\n\n    double t0, t1;\n    if (u->bb.intersect(ray, t0, t1)) {\n      if (u->isLeaf()) {\n        for (size_t i = 0; i < u->range; i++) {\n          if (primitives[u->start + i]->intersect(ray)) {\n            hit = true;\n            break;\n          }\n        }\n        if (hit) break;\n      } else {\n        if (u->l) s.push(u->l);\n        if (u->r) s.push(u->r);\n      }\n    }\n  }\n\n  return hit;\n}\n\nbool BVHAccel::intersect(const Ray &ray, Intersection *isect) const {\n  // Implement ray - bvh aggregate intersection test. A ray intersects\n  // with a BVH aggregate if and only if it intersects a primitive in\n  // the BVH that is not an aggregate. When an intersection does happen.\n  // You should store the non-aggregate primitive in the intersection data\n  // and not the BVH aggregate itself.\n\n  bool hit = false;\n  isect->t = ray.max_t;\n\n  std::stack<BVHNode *> s;\n  s.push(root);\n  while (!s.empty()) {\n    auto u = s.top();\n    s.pop();\n\n    double t0, t1;\n    if (u->bb.intersect(ray, t0, t1)) {\n      if (t0 <= isect->t) {\n        if (u->isLeaf()) {\n          for (size_t i = 0; i < u->range; i++) {\n            if (primitives[u->start + i]->intersect(ray, isect)) {\n              hit = true;\n              ray.max_t = isect->t;\n            }\n          }\n        } else {\n          double lt0, lt1;\n          bool lhit = false;\n          if (u->l) lhit = u->l->bb.intersect(ray, lt0, lt1);\n          double rt0, rt1;\n          bool rhit = false;\n          if (u->r) rhit = u->r->bb.intersect(ray, rt0, rt1);\n\n          if (lhit && rhit) {\n            if (lt0 < rt0) {\n              s.push(u->r);\n              s.push(u->l);\n            } else {\n              s.push(u->l);\n              s.push(u->r);\n            }\n          } else if (lhit) {\n            s.push(u->l);\n          } else if (rhit) {\n            s.push(u->r);\n          }\n        }\n      }\n    }\n  }\n\n  return hit;\n}\n```\n\n## Task 4: Implementing Shadow Rays\n\n在 `pathtracer.cpp` 的 `PathTracer::trace_ray` 方法中的相应部分增加光线的检测就好了：\n\n```c++\n  if (!isect.bsdf->is_delta()) {\n    Vector3D dir_to_light;\n    float dist_to_light;\n    float pr;\n\n    // ### Estimate direct lighting integral\n    for (SceneLight* light : scene->lights) {\n\n      // no need to take multiple samples from a point/directional source\n      int num_light_samples = light->is_delta_light() ? 1 : ns_area_light;\n\n      // integrate light over the hemisphere about the normal\n      for (int i = 0; i < num_light_samples; i++) {\n\n        // returns a vector 'dir_to_light' that is a direction from\n        // point hit_p to the point on the light source.  It also returns\n        // the distance from point x to this point on the light source.\n        // (pr is the probability of randomly selecting the random\n        // sample point on the light source -- more on this in part 2)\n        const Spectrum& light_L = light->sample_L(hit_p, &dir_to_light, &dist_to_light, &pr);\n\n        // convert direction into coordinate space of the surface, where\n        // the surface normal is [0 0 1]\n        const Vector3D& w_in = w2o * dir_to_light;\n        if (w_in.z < 0) continue;\n\n          // note that computing dot(n,w_in) is simple\n        // in surface coordinates since the normal is (0,0,1)\n        double cos_theta = w_in.z;\n          \n        // evaluate surface bsdf\n        const Spectrum& f = isect.bsdf->f(w_out, w_in);\n\n        // (Task 4) Construct a shadow ray and compute whether the intersected surface is\n        // in shadow. Only accumulate light if not in shadow.\n        Ray shadow(hit_p + hit_n * EPS_D, dir_to_light);\n        if (!bvh->intersect(shadow)) {\n          L_out += (cos_theta / (num_light_samples * pr)) * f * light_L;\n        }\n      }\n    }\n  }\n```\n\n其实这一段代码是做了重要性采样。\n\n## Task 5: Adding Path Tracing\n\n实现 `sampler.cpp` 中的 cosine weighted sampler：\n\n```c++\nVector3D CosineWeightedHemisphereSampler3D::get_sample(float *pdf) const {\n  // You may implement this, but don't have to.\n  double Xi1 = double(std::rand()) / RAND_MAX;\n  double Xi2 = double(std::rand()) / RAND_MAX;\n\n  double sintheta = sqrt(Xi1);\n  double costheta = sqrt(1 - Xi1);\n  double phi = 2.0 * PI * Xi2;\n\n  double xs = sintheta * cos(phi);\n  double ys = sintheta * sin(phi);\n  double zs = costheta;\n\n  *pdf = costheta / PI;\n\n  return Vector3D(xs, ys, zs);\n}\n```\n\n然后在 `raytracer.cpp` 中的 `PathTracer::trace_ray` 方法中递归：\n\n```c++\n  // (1) randomly select a new ray direction (it may be\n  // reflection or transmittence ray depending on\n  // surface type -- see BSDF::sample_f()\n  Vector3D w_in;\n  float pdf;\n  Spectrum fr = isect.bsdf->sample_f(w_out, &w_in, &pdf);\n\n  // (2) potentially terminate path (using Russian roulette)\n  double prob = 1.0;\n  if (fr.illum() < 0.5)\n    prob = 0.5;\n  if (double(rand()) / RAND_MAX > prob)\n    return L_out;\n\n  // (3) evaluate weighted reflectance contribution due \n  // to light from this direction\n  // Spectrum fr = isect.bsdf->f(w_out, w_in);\n  Ray ri(hit_p, o2w * w_in, int(r.depth + 1));\n  ri.min_t = EPS_D;\n  Spectrum Li = trace_ray(ri);\n  L_out += fr * Li * (std::abs(w_in.z) / (pdf * prob));\n```\n\n这里是修改 `ri.min_t` 而不是改变起点是为了处理要进入球体的内部的光线。\n\n## Task 6: Adding New Materials\n\n全部在 `bsdf.cpp` 中。\n\ndiffuse 应该是前一个 task 个的？\n\n```c++\n// Diffuse BSDF //\n\nSpectrum DiffuseBSDF::f(const Vector3D& wo, const Vector3D& wi) {\n  return albedo * (1.0 / PI);\n}\n\nSpectrum DiffuseBSDF::sample_f(const Vector3D& wo, Vector3D* wi, float* pdf) {\n  // Implement DiffuseBSDF\n  *wi = sampler.get_sample(pdf);\n  if (wo.z < 0) wi->z *= -1.;\n  return albedo * (1.0 / PI);\n}\n```\n\n然后是折射与反射的函数：\n\n```c++\nvoid BSDF::reflect(const Vector3D& wo, Vector3D* wi) {\n  // Implement reflection of wo about normal (0,0,1) and store result in wi.\n  wi->x = -wo.x;\n  wi->y = -wo.y;\n  wi->z = wo.z;\n}\n\nbool BSDF::refract(const Vector3D& wo, Vector3D* wi, float ior) {\n  // Use Snell's Law to refract wo surface and store result ray in wi.\n  // Return false if refraction does not occur due to total internal reflection\n  // and true otherwise. When dot(wo,n) is positive, then wo corresponds to a\n  // ray entering the surface through vacuum.\n\n  double k = wo.z >= 0 ? 1.0 / ior : ior;\n  double d = 1 - (1 - wo.z * wo.z) * k * k;\n  if (d < 0) return false;\n  wi->x = -wo.x * k;\n  wi->y = -wo.y * k;\n  wi->z = sqrt(d);\n  if (wo.z >= 0) wi->z *= -1.;\n\n  return true;\n}\n```\n\n然后就是我有点懵的镜面与玻璃的 brdf 了。。。看了 Ubpa 的代码，发现结果确实和参考很相像，但我有一点不是很清楚为什么是这样的。。。\n\n```c++\n// Mirror BSDF //\n\nSpectrum MirrorBSDF::f(const Vector3D& wo, const Vector3D& wi) {\n  return 1.0 / fabs(wi.z) * reflectance;\n}\n\nSpectrum MirrorBSDF::sample_f(const Vector3D& wo, Vector3D* wi, float* pdf) {\n  // Implement MirrorBSDF\n  reflect(wo, wi);\n  *pdf = 1.0;\n  return 1.0 / fabs(wi->z) * reflectance;\n}\n\n// Glass BSDF //\ndouble schlick(double cosine, double ior) {\n  double r0 = (1 - ior) / (1 + ior);\n  r0 = r0 * r0;\n  return r0 + (1 - r0) * pow(1 - cosine, 5);\n}\n\nSpectrum GlassBSDF::f(const Vector3D& wo, const Vector3D& wi) {\n  Vector3D temp;\n  bool canRefract = refract(wo, &temp, ior);\n  double fresnel = canRefract ? schlick(fabs(wo.z), ior) : 1.0;\n  double k = wo.z >= 0 ? 1.0 / ior : ior;\n  if (wo.z * wi.z >= 0) return fresnel / fabs(wi.z) * reflectance;\n  else return k * k * (1 - fresnel) / fabs(wi.z) * transmittance;\n}\n\nSpectrum GlassBSDF::sample_f(const Vector3D& wo, Vector3D* wi, float* pdf) {\n  // Compute Fresnel coefficient and either reflect or refract based on it.\n  Vector3D refle, refra;\n  bool canRefract = refract(wo, &refra, ior);\n  reflect(wo, &refle);\n  double fresnel = canRefract ? schlick(fabs(wo.z), ior) : 1.0;\n  double rnd = double(rand()) / RAND_MAX;\n\n  Spectrum retf;\n  if (rnd <= fresnel) {\n    *wi = refle;\n    retf = fresnel / fabs(wi->z) * reflectance;\n    *pdf = fresnel;\n  } else {\n    double k = wo.z >= 0 ? 1.0 / ior : ior;\n    *wi = refra;\n    retf = k * k * (1 - fresnel) / fabs(wi->z) * transmittance;\n    *pdf = 1.0 - fresnel;\n  }\n\n  return retf;\n}\n```\n\n另外，实现的时候没有管 `roughness` 。。。应该是指把反射或折射光线在一定范围内扰动以形成类似金属表面样式的结果。\n\n## Task 7: Infinite Environment Lighting\n\n和天空盒很像不过是球形的，在 `static_sence/environment_light{.h, .cpp}`：\n\n首先实现 AliasTable：\n\n```c++\n  class AliasTable {\n   private:\n    struct Item {\n      int id0, id1;\n      double ratio;\n    };\n    std::vector<Item> items;\n\n   public:\n    void init(const std::vector<double>& vec);\n    int sample(double p) const;\n  };\n```\n\n```c++\nvoid EnvironmentLight::AliasTable::init(const std::vector<double>& vec) {\n  int N = vec.size();\n  items.resize(N);\n  for (int i = 0; i < N; i++) {\n    items[i].id0 = i;\n    items[i].id1 = -1;\n    items[i].ratio = vec[i];\n  }\n\n  double mid = 1.0 / N;\n  int rich = -1, poor = -1;\n  for (int i = 0; i < N; i++) if (items[i].ratio < mid) {\n    poor = i;\n    break;\n  }\n  for (int i = 0; i < N; i++) if (items[i].ratio > mid) {\n    rich = i;\n    break;\n  }\n\n  int poor_max = poor;\n  while (rich != -1 && poor != -1) {\n    double diff = mid - items[poor].ratio;\n    items[poor].id1 = rich;\n    items[poor].ratio = mid;\n    items[rich].ratio -= diff;\n\n    int temp_poor = -1;\n    if (items[rich].ratio < mid && rich < poor) {\n      temp_poor = rich;\n    } else {\n      for (int i = poor_max; i < N; i++) if (items[i].ratio < mid) {\n        temp_poor = i;\n        break;\n      }\n    }\n    poor = temp_poor;\n    poor_max = std::max(poor_max, poor);\n\n    int temp_rich = -1;\n    for (int i = rich; i < N; i++) if (items[i].ratio > mid) {\n      temp_rich = i;\n      break;\n    }\n    rich = temp_rich;\n  }\n}\n\nint EnvironmentLight::AliasTable::sample(double p) const {\n  int id = p;\n  double left = p - id;\n  return left <= items[id].ratio ? items[id].id0 : items[id].id1;\n}\n\nEnvironmentLight::EnvironmentLight(const HDRImageBuffer* envMap)\n    : envMap(envMap) {\n  int w = envMap->w, h = envMap->h;\n\n  probs.resize(w * h);\n  double sum = 0;\n  for (int j = 0; j < h; j++) {\n    double theta = (j + 0.5) / h * PI;\n    double sintheta = sin(theta);\n    for (int i = 0; i < w; i++) {\n      int id = i + j * w;\n      probs[id] = envMap->data[id].illum() * sintheta;\n      sum += probs[id];\n    }\n  }\n  for (double& p : probs) p /= sum;\n  table.init(probs);\n}\n```\n\n之后用 AliasTable 采样实现 `sample_L`:\n\n```c++\nSpectrum EnvironmentLight::sample_L(const Vector3D& p, Vector3D* wi,\n                                    float* distToLight, float* pdf) const {\n  *distToLight = INF_F;\n\n  double rnd = double(rand()) / RAND_MAX * probs.size();\n  int id = table.sample(rnd);\n  *pdf = probs[id];\n\n  int x = id % envMap->w;\n  int y = id / envMap->w;\n  double theta = PI * (y + double(rand()) / RAND_MAX) / envMap->h;\n  double phi = 2 * PI * (x + double(rand() / RAND_MAX)) / envMap->w;\n\n  wi->x = sin(theta) * cos(phi);\n  wi->z = sin(theta) * sin(phi);\n  wi->y = cos(theta);\n\n  return sample_dir(*wi);\n}\n```\n\n用双线性插值实现 `sample_dir`，因为完全没用上 `Ray::o`，所以直接把参数改成 `Vector3D` 了。。。\n\n```c++\nSpectrum EnvironmentLight::sample_dir(const Vector3D& r) const {\n  int w = envMap->w, h = envMap->h;\n  double theta = acos(r.y);\n  double phi = atan2(r.z, r.x) + PI;\n  double tx = phi / 2 / PI * w;\n  double ty = theta / PI * h;\n\n  int x[2], y[2];\n  x[0] = round(tx) - 1;\n  x[1] = x[0] + 1;\n  x[0] = clamp(x[0], 0, w - 1);\n  x[1] = clamp(x[1], 0, w - 1);\n  double dx = tx - x[0] - 0.5;\n  y[0] = round(ty) - 1;\n  y[1] = y[0] + 1;\n  y[0] = clamp(y[0], 0, h - 1);\n  y[1] = clamp(y[1], 0, h - 1);\n  double dy = ty - y[0] - 0.5;\n\n  Spectrum mix(0, 0, 0);\n  for (int i = 0; i < 2; i++) {\n    for (int j = 0; j < 2; j++) {\n      int id = x[i] + y[j] * w;\n      mix += envMap->data[id] * (i * dx + (1 - i) * (1 - dx)) * (j * dy + (1 - j) * (1 - dy));\n    }\n  }\n\n  return mix;\n}\n```\n\n## 其他（随便口胡）\n\n感觉这份代码的 `trace_ray` 在相对坐标中做很舒服的样子。。。\n\n写完之后更想学 PBR 了，但不知道会花多少时间，毕竟自己的英文阅读速度不是很快，以及不知道会让自己离想象中的「游戏工程师」是更近还是更远。有看到 CMU 15-466 的 Computer Game Programming，也很想学的样子，然后再这么一想，就发现自己还有很多想学的东西，就会觉得时间好少的感觉。。。尤其是看到校内还要学一些奇怪的、占时间的课。。。","tags":["CMU","课程笔记","实现笔记","CG"],"categories":["学习笔记（大学课外）"]},{"title":"2019 ICPC 上海游记","url":"/2019-ICPC-上海游记/","content":"\n* 队伍：Wheatfield with Crows\n* 队员：邓浩然（HbFS-）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：6/13（B，D，E，F，H，K）\n* 罚时：617\n* 排名：21/300（不含打星队）\n\n<!--more-->\n\n### Day 0\n\n三支队伍打车到了上大的三个校门。。。\n\n报道居然要每人签字。。。\n\n食堂居然不比浙大好吃。。。\n\n去报道时正好看到朝鲜理科的六个人在照相，见到了传闻中的整齐的西装。\n\n热身赛被校内队伍暴打，到最后连 vim 配置都没敲完。。。\n\n晚上在宾馆对面的商场里吃了西贝（牛大腿好好吃！）和 DQ 的奥利奥熔岩。三人做出了「从过个马路就是的商场出来后需要导航才能回去」和「回去后又跑过去买早餐」的窒息操作。\n\n回宾馆后打 cc98 雀魂赛，很开心地拿了一位，目前积分 +20，还差一场，正分出线的话稳了。\n\n### Day 1\n\n一如继往地去配了 vim（自动登录 DOM Judge 好评）。\n\nlsy **K1y14** 后我去签 B，在写代码时不知怎地删了初始化的代码，于是 **B2y29**。\n\n之后尝试去构造 D，lsy 可以写 F。我通过顶点度数感受了一下觉得可以分成 $\\lfloor n / 2 \\rfloor$ 条链，但 WA 了三次后发现写的还是有问题，甚至时间上也开始有问题了。。。\n\n期间 dhr 出了 H，给我说了做法后 **H1y83**；我给 dhr 说了 E 的题意后被指出是最大生成树，而且计数排序就好了，于是 **E1y96**。（自己当时可能在想构造，读完题就没想过做法的样子。）\n\n之后 dhr 接手 D，重新想了个做法，于是 **D4y152**。\n\nlsy 的 F 被三道题打断多次后终于写完，过了样例后 **F1y163**。\n\nlsy 读了 M 并说了费用流，但没人提交过。我在等机位的时候看到 RNS 和高大爷他们各自出现了一个红色，觉得自己也会是 TLE，果不其然。之后 dhr 指出不用堆优化的话，Dij 费用流就是 $O(n^3)$ 的（但第一次要用 spfa 跑），改了一发后依然 TLE。同时 lsy 这边似乎出了 J。\n\n我去看了红板，尝试理解 KM，但发现自己不是真正理解 KM 的人。dhr 在大概剩 90min 时提出可以优化简图到 $O(n)$ 条边，我花了一段时间理解后上机，期间 dhr 帮着找出了我找不到的错，改了两次才改对后终于过了样例（我只大概扫了一眼，应该是过了），提交 WA。我想了想觉得这个费用流的最后跑出的流量可能不是 $m$，我输出的中间答案会错，凭感觉改了一发依然 WA。最后时刻提交了一发 lsy 的 J 结束。\n\n赛后看群发现被评价做「做 M 上头了」，看知乎发现我们的 M 就是出题人的正解，一模一样的 $4n$ 点 $10n$ 边，但不知写挂了什么。。。赛后 dhr 表示 lsy 某次下机后 J 的算法已经假了。。。更可做的 A 好像没人读过。。。\n\n这个 M，如果出题人的 std 是跑的 Dij，那事估摸就没现在这么多了呢。。。顺便，想知道什么是真正理解 KM。\n\n晚上在车站附近的绿茶吃了晚饭，之后又吃了 DQ 的奥利奥熔岩。\n\n在回去的高铁上打了最后一轮雀魂赛的小组赛，虽然是一位，但回头看时发现有几次立直都是几乎听绝张，有点惊险。最后 +57 分 8 位出线了。\n\n### 总结\n\n只有我有罚时。。。\n\n这次居然出现了不初始化这种事情，感觉自己前期打得有点糟糕。最后 dhr 开出费用流时，我本以为是梦回厦门，结果等滚榜时愣是有种梦回去年南京的感觉。\n\n不知怎的被教练组续命去 EC-Final，那就希望能好好打好最后一场吧。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"2019 CCPC-Final 游记","url":"/2019-CCPC-Final-游记/","content":"\n* 队伍：Wheatfield with Crows\n* 队员：邓浩然（HbFS-）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：4/12（A，I，K，L）\n* 罚时：354（05:54:27）\n* 排名：23/115\n\n<!-- more -->\n\n### Day -1\n\n中午到了中传，报完到后就在宾馆里打起了雀魂。\n\n晚上和 heltion 和 lyk 在食堂吃了晚饭，要了回锅肉炒面，挺好吃的。\n\n之后继续雀魂。。。\n\n发现企业队强得过分了。。。\n\n### Day 0\n\n白天听讲座的时候一直在摸鱼。发现忘了拿 lsy 的袋子，于是 lsy 失去了她的餐券。\n\n中午和 heltion 和 zqq 在食堂吃了，要了红烧牛肉刀削面，挺好吃的+1。\n\n下午讲座继续\n\n热身赛签了 A，写了一半 C 后发现复杂度假了，一段时间后又 fix 好了。之后 lsy 写了 B，dhr 写了 D，之后又大概测了测东西。\n\n氦气球好评。\n\n虽然中午拿上了 lsy 的袋子，但晚饭时发现没有拿 dhr 的袋子，于是 dhr 也失去了他的餐券，成功成为不让队员吃饭的队员（不是）。\n\n晚上在食堂吃了大盘鸡拌面，挺好吃的+2。dhr 用 lsy 的券吃了食堂。\n\n### Day 1\n\n出门我去登陆和配置，两位老板读题。配置好后 lsy 去写 A，**A1y22**。之后我给 lsy 说了 K 的题意，给 dhr 说来 F 的题意，dhr 觉得 F 可做遍和我讨论了起来，我同时知道了 L 的题意，想了想感觉数据范围很奇怪。\n\nlsy 听了 K 的题意就说能做，之后 lsy **K1y57**。dhr 在听了 F 的题意后说出了「每次都是一个水手 + 两个人」，我觉得很对，此时在此基础上已经讨论出了一个做法，我去写了一发，WA 了。之后决定上机写一下感觉和数据范围相差甚远、不用取模、榜上看起来 dirt 率还有点高的 L，没想到过了，**L1y120**。\n\n之后 dhr 和 lsy 讨论出了 H 的网络流做法，同时找到了 F 的一个小 bug，但 F 还是 WA，H 也是。期间去看了构造的 I，想了一下「$n (n + 1) / 2$ 是三角形的式子」就出了，**I1y153**。\n\n之后的时间里，dhr 和 lsy 查 H，和我查 F。渐渐地，H 发现做法有问题，以为能 fix 但最后也发现不能了；F 这边 dhr 表示可以用去掉优化的暴力 DP 对拍，但无果，我提议交一下暴力，得到了 TLE，觉得是优化的问题的概率比较大，lsy 则表示可能是还没跑出来就 TLE 了，于是我一直挂着对拍程序。（事后发现是 lsy 的判断对了）\n\n期间有尝试开 E，有想过用 k-D Tree 搞这个范围的最值，但感觉这个双曲边界的范围完全不会搞。\n\n最后一个小时时，明显没了干劲，开始自暴自弃地去读了 J 的题意和看榜。\n\n赛后发现 F 在我向 dhr 转述题意时出了问题，我没有说「水手可以下岛」的事情，dhr 提出结论的时候也没有怎么想就觉得对了，事实上是对着半个假的题意做了一整场。听题解时听到 L 说一定要放小数据范围，感觉自己确实是被搞死的人之一了。\n\n最后是 C 和 D 没有人读过。\n\n---\n\n晚上在出租车和高铁上打了 CC98 雀魂赛小组赛的前三轮，分别是三位、二位、四位，出线危险。每次掉线连回的时候就急着打铳了好几次，有点难受，但下周好像还要在高铁上打后三轮，毕竟还要去上海。\n\n### 总结及一些其他的\n\n感觉问题也有很多，也感觉很菜，打得很自闭。虽然是第一次没有罚时，但是在这种情况下也感觉很难受。\n\n中传的食堂对我这个西北人来说很棒，但是看起来好贵啊。。。QAQ\n\n恭喜蛇队，也恭喜 fby 成功上镜央视（不是）。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"simple-JPEG-IO 实现笔记","url":"/simple-JPEG-IO-实现笔记/","content":"\n文档：https://www.w3.org/Graphics/JPEG/itu-t81.pdf\n\n实现参考：\n\n* stb_image：https://github.com/nothings/stb/blob/master/stb_image.h\n* Game Engine From Scratch：https://github.com/netwarm007/GameEngineFromScratch/blob/master/Framework/Parser/JPEG.hpp\n\n---\n\n前些日子写学校里图像信息处理的作业时想着不用 BMP 而直接用 JPEG 会方便很多，本来也想写这么一个轮子，所以就花了些时间实现出了这么一个玩意儿。本文就算是我写这个东西时的学习笔记了，因为重心放在了解析上，输出只是随便糊了一个最基本的，所以大部分内容都是站在解析的角度上记录的。\n\nsimple-JPEG-IO：https://github.com/PepcyCh/simple-JPEG-IO\n\n---\n\n笔记大概分为四个部分：\n\n* 大致压缩流程\n* 基本文件结构\n* 解析流程\n* 输出流程\n\n<!-- more -->\n\n## 大致压缩流程\n\n把图像分成若干 $8 \\times 8$ 的块，右侧和下侧超出的部分用边界值填充。\n\n对于每一个块，先转化至 YCbCr 空间，之后分通道进行压缩。\n\n首先对该块进行 DCT。\n\n之后对 DCT 后得到的 $8 \\times 8$ 的矩阵中的每一个元素分别除以一个 $8 \\times 8$ 的量化矩阵中的相应元素并向下取整。\n\n在每一个 Restart Interval 内（见「基本文件结构-DRI」），除第一个 DC 系数（$8 \\times 8$ 的块中左上角的值）外，每一个 DC 系数对前一个块的 DC 系数做差；AC 系数（$8 \\times 8$ 的块中除左上角以外的值）使用 Run-length Code 压缩（具体见「基本文件结构-熵编码部分」）。\n\n之后使用 Huffman 编码进行压缩（Huffman 编码的不是 DC 或 AC 系数，具体见「基本文件结构-熵编码部分」）。\n\n---\n\nJPEG 使用的 DCT 公式：\n$$\nS_{vu} = \\frac{1}{4} c_u c_v \\sum_{x = 0}^{7} \\sum_{y = 0}^{7} s_{yx} \\cos \\frac{(2x + 1) u \\pi}{16} \\cos \\frac{(2y + 1) v \\pi}{16}\n$$\nIDCT 公式：\n$$\ns_{yx} = \\frac{1}{4} \\sum_{u = 0}^{7} \\sum_{v = 0}^{7} c_u c_v s_{vu} \\cos \\frac{(2x + 1) u \\pi}{16} \\cos \\frac{(2y + 1) v \\pi}{16}\n$$\n其中：\n$$\nc_u, c_v = \\begin{cases}\n\\frac{1}{\\sqrt{2}} &, u, v = 0 \\\\\n1 &, \\text{otherwise}\n\\end{cases}\n$$\n\n## 基本文件结构\n\nJPEG 文件中使用大端法。\n\nJPEG 文件由若干块组成，每一块的开头是一个 2 字节长的块标识符，第一字节均为 `0xFF`。除图像首尾的块 SOI（Start Of Image）、EOI（End Of Image）和一些块外，大部分块在 2 字节的块标识符后还有一个 2 字节的部分表示块的长度，该长度包括自己的 2 字节，但不包括块标识符。\n\n根据压缩流程中所描述的，要正确解析一个 JPEG 图像，只需要考虑以下块：\n\n* SOI（Start Of Image）\n* EOI（End Of Image）\n* SOFn（Start Of  Frame）\n* DQT（Define Quantization Table）\n* DHT（Define Huffman Table）\n* SOS（Start Of Scan）\n* DRI（Define Restart Interval）\n* RST（Restart）\n\n除此之外，还要了解真正存储图像的熵编码部分。\n\n之后将依次介绍以上每一个块。\n\n### SOI（Start Of Image）\n\n块标识符：`0xFFD8`\n\n除标识符外无其他内容，出现在文件最开始。\n\n### EOI（End Of Image）\n\n块标识符：`0xFFD9`\n\n除标识符外无其他内容，出现在文件最末尾。\n\n### SOFn（Start Of Frame）\n\n块标识符：`0xFFCn`（$n = 0, 1, \\dots, \\text{F}$）\n\n常用的有 SOF0 和 SOF2，分别表示基线模式（Baseline DCT）和连续模式（Progressive DCT）。\n\n该块描述了一些图像的基本信息。\n\n其块内容可表示为：\n$$\n\\text{Lf} \\;\\; \\text{P} \\;\\; \\text{Y} \\;\\; \\text{X} \\;\\; \\text{Nf} \\;\\; (\\text{Ck} \\;\\; \\text{Hk} \\;\\; \\text{Vk} \\;\\; \\text{Tqk})_{1 \\sim \\text{Nf}}\n$$\n\n#### $\\text{Lf}$：Frame Header Length - 16bits\n\n块长度，等于 $8 + 3\\text{Nf}$\n\n#### $\\text{P}$：Sample Precision - 8bits\n\n可取的值为 $8$ 和 $12$，基线模式下只能为 $8$。simple-JPEG-IO 只考虑了为 $8$ 的情况，实践中还未因此受到影响。\n\n#### $\\text{Y}$：Number of Lines - 16bits\n\n图像的高度。若为 $0$ 则表示由 DNL（Define Number of Lines）块定义，本文不考虑这种情况。\n\n#### $\\text{X}$：Number of Samples per Line - 16bits\n\n图像的宽度。\n\n#### $\\text{Nf}$：Number of Image Components in Frame - 8bits\n\n图像的通道数。一般为 $3$，按顺序分别为 Y、Cb、Cr。\n\n#### $\\text{Ck}$：Component Identifier - 8bits\n\n该通道的编号。\n\n#### $\\text{Hk}$：Horizontal Sampling Factor - 4bits\n\n水平采样因子，具体解释见「解析流程」。\n\n#### $\\text{Vk}$：Vertical Sampling Factor - 4bits\n\n竖直采样因子，具体解释见「解析流程」。\n\n#### $\\text{Tqk}$：Quantization Table Destination Selector - 8bits\n\n该通道使用的量化表的编号（$0 \\sim 3$）。\n\n### DQT（Define Quantization Table）\n\n块标识符：`0xFFDB`\n\n该块定义了一个或多个量化表。\n\n一个定义了 $n$ 个量化表的块内容可表示为：\n$$\n\\text{Lq} \\;\\; (\\text{Pq} \\;\\; \\text{Tq} \\;\\; (\\text{Qk})_{0 \\sim 63})_{1 \\sim n}\n$$\n\n#### $\\text{Lq}$：Quantization Table Defination Length - 16bits\n\n块长度。\n\n#### $\\text{Pq}$：Quantization Table Element Precision - 4bits\n\n可取的值为 $0$ 或 $1$，若为 $0$，表示该表的每一个 $\\text{Qk}$ 占 8bits，否则表示占 16bits。基线模式下只能为 $0$。\n\n#### $\\text{Tq}$：Quantization Table Destination Identifier - 4bits\n\n该量化表的编号，取值为 $0 \\sim 3$，用于 SOFn 的 $\\text{Tqk}$。\n\n#### $\\text{Qk}$：Quantization Table Elements - 8bits/16bits\n\n量化表的每一个元素，按 zig-zag 序给出。\n\n### DHT（Define Huffman Table）\n\n块标识符：`0xFFC4`\n\n该块定义了一个或多个 Huffman 表。\n\n一个定义了 $n$ 个 Huffman 表的块内容可表示为：\n$$\n\\text{Lh} \\;\\; (\\text{Tc} \\;\\; \\text{Th} \\;\\; (\\text{Lk})_{1 \\sim 16} \\;\\; (\\text{Vi,j})_{i=1 \\sim 16, j = 1 \\sim \\text{Li}})_{1 \\sim n}\n$$\n\n#### $\\text{Lh}$：Huffman Table Defination Length - 16bits\n\n块长度。\n\n#### $\\text{Tc}$：Table Class - 4bits\n\n若为 $0$，表示是一个 DC 表；若为 $1$，表示是一个 AC 表。\n\n#### $\\text{Th}$：Huffman Table Destination Identifier - 4bits\n\nHuffman 表的编号，取值为 $0 \\sim 3$（基线模式下取值为 $0 \\sim 1$），编号相同但类别不同的 Huffman 表不是同一个表（也就是一共最多会有 $8$ 个表）。\n\n#### $\\text{Lk}$：Number of Huffman Codes of Length $k$ - 8bits\n\n长度为 $k$ 的 Huffman 码的个数。\n\n#### $\\text{Vi,j}$：Value Associated with Each Huffman Code - 8bits\n\n长度为 $i$ 的第 $j$ 个 Huffman 码表示的值。\n\n具体的编码方式将在「解析流程」中给出。\n\n### SOS（Start Of Scan）\n\n块标识符：`0xFFDA`\n\n该块标识着一次扫描的开始，若为基线模式，则只会有一个 SOS 块。紧接其后的就是熵编码的扫描内容。\n\n其块内容可表示为：\n$$\n\\text{Ls} \\;\\; \\text{Ns} \\;\\; (\\text{Csk} \\;\\; \\text{Tdk} \\;\\; \\text{Tak})_{1 \\sim \\text{Ns}} \\;\\; \\text{Ss} \\;\\; \\text{Se} \\;\\; \\text{Ah} \\;\\; \\text{Al}\n$$\n\n#### $\\text{Ls}$：Scan Header Length - 16bits\n\n块长度，不含熵编码部分。\n\n#### $\\text{Ns}$：Number of Image Components in Scan - 8bits\n\n该次扫描内涉及的通道数。\n\n#### $\\text{Csk}$：Scan Component Selector - 8bits\n\n扫描内第 $k$ 个通道的编号，该编号就是在 SOFn 中定义的编号。\n\n#### $\\text{Tdk}$：DC Entropy Coding Table Destination Selector - 4bits\n\n该通道使用的 DC 表的编号，该编号就是 DHT 中定义的编号。\n\n#### $\\text{Tak}$：AC Entropy Coding Table Destination Selector - 4bits\n\n该通道使用的 AC 表的编号，该编号就是 DHT 中定义的编号。\n\n#### $\\text{Ss}$：Start of Spectral of Predictor Selection - 8bits\n\n连续模式时，该次扫描涉及的 $8 \\times 8$ 块内第一个元素的 zig-zag 序下标，其及剩下的参数将在「解析流程-连续模式」中做进一步解释。\n\n基线模式下一定为 $0$。\n\n#### $\\text{Se}$：End of Spectral of Predictor Selection - 8bits\n\n连续模式时，该次扫描涉及的 $8 \\times 8$ 块内最后一个元素的 zig-zag 序下标。\n\n基线模式下一定为 $63$。\n\n#### $\\text{Ah}$：Successive Approximation Bit Position High - 4bits\n\n连续模式时，为 $0$ 表示是 $\\text{Ss} \\sim \\text{Se}$ 的 DCT 系数的第一次扫描，否则是之后的扫描。\n\n基线模式下一定为 $0$。\n\n#### $\\text{Al}$：Successive Approximation Bit Position Low - 4bits\n\n连续模式时，该次扫描涉及的每一个 DCT 系数的位移系数。\n\n基线模式下一定为 $0$。\n\n### DRI（Define Restart Interval）\n\n块标识符：`0xFFDD`\n\n该块定义了 restart interval 的长度，每当扫描后的熵编码部分已经解析或编码了长度的整数倍的 MCU（Minimum Coded Unit，最小编码单元，将在「解析流程」中做进一步解释） 时暂时结束熵编码部分，同时清零已保存的当前的 DC 值，之后遇到 RST（Restart）块时将继续进行接下来的扫描。如果无 DRI 块，则可以认为 restart interval 的长度为 0，之后也不会有 RST 块。\n\n比如，Photoshop 的基线模式会把图像的每一行设成一个 restart interval，那么文件中会是「SOS，第一行数据，RST，第二行数据，……，RST，最后一行数据」。\n\n当熵编码部分结束时不是一个满的字节时，需要填充满。\n\n其块内容可以表示为：\n$$\n\\text{Lr} \\;\\; \\text{Ri}\n$$\n\n#### $\\text{Lr}$：Define Restart Interval Segment Length - 16bits\n\n块长度，等于 $4$。\n\n#### $\\text{Ri}$：Restart Interval - 16bits\n\n定义的长度。\n\n### RST（Restart）\n\n块标识符：`0xFFD7`\n\n无内容，紧接其后的是熵编码的扫描内容。\n\n### 熵编码部分\n\n此外，需要了解熵编码部分的结构，每一个数值的存储如下：\n\n首先是 $\\text{RRRRSSSS}$ ，一个 8 位的数，$\\text{RRRR}$ 表示在它之前为 $0$ 的元素个数（对于 DC 系数，应当是 $0$），$\\text{SSSS}$ 表示存储该数值需要的位数。这个 $\\text{RRRRSSSS}$ 便是用 Huffman 表编码的东西，也就是说，存储的是编码后的 Huffman 码。在基线模式下，DC 系数的 $\\text{SSSS}$ 的取值范围是 $0 \\sim 11$，AC 系数的取值范围是 $1 \\sim 10$，所以基线模式下的一个 DC 表会有 $12$ 个元素，一个 AC 表会有 $162$ 个元素（包括了之后提到的 ZRL 和 EOB），一些解析器（如 Photoshop 的）需要 Huffman 表正好有这么多的元素才视作可解析的 JPEG 文件。\n\n之后才是真正的数值，读取 $\\text{SSSS}$ 长的二进制数，根据下表可以得到真正的数值：\n\n| 长度 |         所编码的数         |\n| :--: | :------------------------: |\n|  0   |             0              |\n|  1   |           -1, 1            |\n|  2   |        -3, -2, 2, 3        |\n|  3   | -7, -6, -5, -4, 4, 5, 6, 7 |\n|  4   |      -15 ~ -8, 8 ~ 15      |\n|  5   |     -31 ~ -16, 16 ~ 31     |\n|  6   |     -63 ~ -32, 32 ~ 63     |\n|  7   |    -127 ~ -64, 64 ~ 127    |\n|  8   |   -255 ~ -128, 128 ~ 255   |\n|  9   |   -511 ~ -256, 256 ~ 511   |\n|  10  |  -1023 ~ -512, 512 ~ 1023  |\n|  11  | -2047 ~ -1024, 1024 ~ 2047 |\n\n$\\text{RRRR}$ 指示之前为 $0$ 的数据数，但显然它最多只能表示 $15$ 个 $0$，于是定义 $\\text{RRRRSSSS} = \\text{0xF0}$ 为 ZRL（Zero Run Length），表示连续的 $16$ 个 $0$（如果不做特殊处理，理解成一个 $0$ 的前面有 $15$ 个 $0$ 也是可以得到正确结果的）；同时，可能会出现从当前到 $8 \\times 8$ 块的最后一个数都是 $0$ 的情况，用 $\\text{RRRRSSSS} = 0x00$ 表示，该值被称作 EOB（End Of Block）。在连续模式中会有一些变化，将在「解析流程-连续模式」中进一步说明。\n\n很明显，在熵编码部分中可能出现 `0xFF` 这半个块标识符，而熵编码部分又不像 SOS、SOFn 这样的块用 2 字节指示了长度，所以规定，如果出现了 `0xFF`，在其后需要追加一个无意义的 `0x00`，称为「bitstuff」，解析时应先去除这样的 `0x00`。\n\n## 解析流程\n\n### 基线模式\n\n很多东西在基线模式和连续模式下都是相同或相似的，就都在「基线模式」中描述了。\n\n根据 JPEG 文件结构的特性，很容易想到用一个 `while` 循环控制，依次解析各个块，直至遇到 EOI 块结束。\n\n#### 根据 DHT 的信息建立 Huffman 树\n\n按顺序考虑每一个 $\\text{Vi,j}$，记录一个当前的编码 $curr$，初始为 $0$，当没有长度为 $1$ 的编码时，在后面补 $0$，直至找到一个最小的长度 $l$ 使 $\\text{Ll} \\neq 0$，为 $V_{l,1}$ 分配编码 $curr$，之后 $curr$ 自增 $1$，之后如果仍存在相同长度的编码，重复分配和自增的操作；否则重复补零的操作。\n\n#### 采样因子、扫描与 MCU\n\nMCU（Minimum Coded Unit），最小编码单元，即在一次扫描过程中最小的处理单元，在扫描过程中，按先从左到右、后从上到下的顺序依次处理每一个 MCU。\n\n如果一次扫描内只有一个通道，即 $\\text{Ns} = 1$，则无论该通道的采样因子取何值，MCU 都被定义成一个 $8 \\times 8$ 的块。当图像的宽或高不为 $8$ 的整数倍时，在下层和右层按边界值填充。\n\n否则，需要考虑不同通道的采样因子。\n\n假设一副 JPEG 图像 Y、Cb、Cr 通道的水平和竖直采样因子均为 $1$，那就是最简单的情况，此时 MCU 被定义成一个 $8 \\times 8$ 的 Y 通道、一个 $8 \\times 8$ 的 Cb 通道和一个 $8 \\times 8$ 的 Cr 通道。\n\n而除此之外，还有一种常见的情况是 Y 通道的两个采样因子均为 $2$，Cb 和 Cr 的采样因子为 $1$，这意味着 Cb 和 Cr 被进行了缩小。此时，图像最左上角的 $2 \\times 2$ 个像素有各自的 Y 值，Cb 和 Cr 的值却公用同一个。MCU 此时的定义是一个 $2 \\times 2$ 的块的 Y 通道（如果称一个 $8 \\times 8$ 为一个块）、一个 $1 \\times 1$ 的块的 Cb 通道和一个 $1 \\times 1$ 的块的 Cr 通道。这同样暗示着 Y 通道的宽高不只要填充至 $8$ 的整数倍，还要填充到 $16 \\times 16$ 的整数倍。待全部解析完毕后，需对 Cb 和 Cr 通道进行上采样以得到原始图像每个像素的值。\n\n从而我们可以得到是，一个 MCU 由不同通道的 $\\text{Vk} \\times \\text{Hk}$ 的块组成，采样因子最大的那一通道的相应维是没有经过下采样的。\n\n---\n\n在各个块和熵编码部分都解析完毕后，对每一个 $8 \\times 8$ 的块进行 IDCT，对需要上采样的通道上采样，最后转为 RGB 空间。\n\n### 连续模式\n\n连续模式与基线模式最大的区别就是 SOS 块中的 $\\text{Ss}, \\text{Se}, \\text{Ah}, \\text{Al}$ 了。\n\n连续模式的目的是，当只解析了部分熵编码后，能得到一个完整但不精确的图像，具体的实现方法就是把基线模式中对一个 MCU 的处理分成几个部分，放在不同的扫描中。\n\n对一个 MCU 内的信息的拆分有两种，一是把一个 $8 \\times 8$ 块的 $64$ 个数据分段，二是把每一个数按二进制位分段。\n\n$\\text{Ss}$ 和 $\\text{Se}$ 对应的是第一种，表示本次扫描只有 $64$ 个数中 zig-zag 序下标 $\\text{Ss} \\sim \\text{Se}$ 的数据。特别的，规定 AC 和 DC 不应混在一起，也就是 $\\text{Ss} = 0$ 时必有 $\\text{Se} = 0$，$\\text{Se} \\neq 0$ 则 $\\text{Ss} \\neq 0$。\n\n$\\text{Ah}$ 和 $\\text{Al}$ 对应的是第二种。在第一次扫描时，$\\text{Al}$ 表示解析出的值最后均作一次左移 $\\text{Al}$ 位的操作，之后的扫描将一位一位地细化每一个 DCT 系数，存储的就是每个系数的第 $\\text{Al}$ 位是否需要调整。\n\n还有一些其他的规定：仅包含 DC 系数的第一次扫描必须是所有扫描中的第一个扫描，仅包含 DC 系数的扫描涉及所有的通道，包含 AC 系数的扫描仅包含一个通道。\n\n在 DC 系数的第一次扫描时，除了要进行左移操作外与基线模式基本相同。\n\n在 AC 系数的第一次扫描时，除了要进行左移操作外，EOB 的定义也发生了变化。EOB 现在能表示的不仅是自己这一块，还表示后续的若干块均为 $0$，此时，凡是 $\\text{SSSS} = 0$ 但 $\\text{RRRR} \\neq 15$ 的都是一个 EOB 标记，在其后还有长为 $\\text{RRRR}$ 的数表示为 $0$ 的块数（含当前所在块），该数按下表的规律解析：\n\n| 长度 | 所编码的数 |\n| :--: | :--------: |\n|  0   |     1      |\n|  1   |    2, 3    |\n|  2   | 4, 5, 6, 7 |\n|  ……  |     ……     |\n\nDC 系数的后续扫描中，按序每次读取一个二进制位，为 $1$ 则表示相应系数的第 $\\text{Al}$ 位需要调整。\n\nAC 系数的后续扫描中，与之前的扫描类似，但此时一定有 $\\text{SSSS} = 1$（除非是 ZRL 和 EOB），后一位表示该数是否需要调整，同时， $\\text{RRRR}$ 现在表示的是在该数之前有多少个在之前的扫描中为 $0$ 的数这次仍然为 $0$，对于之前不为 $0$ 但这时被跳过去的数，是否需要调整则以类似 DC 系数后续扫描的方式缀在表示该数的那一位的后面。因 EOB 和 ZRL 而被跳过去的块也是类似的道理。\n\n## 输出流程\n\n只要依次输出每一个必要的块的内容即可。\n\n建立 Huffman 表时注意最长的编码长度不能超过 $16$，以及所有可能出现的编码都应出现在表中，对于基线模式就是 $12$ 个 DC 的 $\\text{RRRRSSSS}$ 和 $162$ 个 AC 的 $\\text{RRRRSSSS}$。可以偷懒用等长编码。\n\n注意在熵编码部分添加 bitstuff 和填充最后一个未满的字节。\n\n量化表随便搞一个就好了，我用的是 Photoshop 输出基线模式时用的量化表。","tags":["随笔","实现笔记"],"categories":["学习笔记（大学课外）"]},{"title":"2019 ICPC 南京游记","url":"/2019-ICPC-南京游记/","content":"\n* 队伍：Wheatfield with Crows\n* 队员：邓浩然（HbFS-）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：7/12（A，B，C，F，H，J，K）\n* 罚时：899\n* 排名：15/33?（含打星队）\n\n<!-- more -->\n\n### Day -1\n\nvp 了银川，8 题 + 赛后 5min L，A 不知怎么 WA 的，被校内队伍吊打。\n\n### Day 0\n\n南航食堂还是那么好吃。。。\n\n热身赛前发现显示器不亮，检查了各个连线后无果，无奈叫了志愿者，发现是线没接紧的样子。。。\n\n热身赛一开始 dhr 不在，我签到，lsy 开 D。在我终于改好了无数个智障错误过了 B、lsy 发现自己 D 假了后 dhr 回来了。讨论了一波后弃疗，去测了一些该测的东西。赛后发现 D 好像是队伍的知识盲区。\n\n和去年一样，机子会有点卡（卡顿程度比去年热身赛好点），希望也和去年一样第二天就好了吧。\n\n晚饭又吃了食堂。\n\n晚上写了会儿 DIP 实验报告，发现自己没带电脑线。\n\n晚些时候 cjb 开了会。\n\n### Day 1\n\n在北门口吃了 KFC 的早饭。\n\n出门我登陆和配置，两位老板从两头读题，配置期间有人过 A，lsy 觉得 K 我能写，想着 A 也想不到，于是我就先写 K 了，改了一个窒息错误后 **K2y22**，回过头来看 A，猜了个结论 **A1y27**。\n\n之后 lsy 和 dhr 开出了 C，于是 lsy **C1y50**。期间我跟榜看了 H 和 J 的题意，不是很理解 H 的题意但和 dhr 讨论了一下后出了 J，抄了红板子的 KM 于是 **J1y70**。\n\n之后和 dhr 继续讨论 H，发现二人对「Who xxx」的回答的理解有分歧，dhr 认为回答是 princess、minister 之类的东西而我觉得是 support or not support，之后的公共表明了 dhr 是对的。这时已经得到了一些结论了，我有点手痒忍不住，去 WA 了一发。同时，dhr 觉得 I Hash 记搜能过，写了会儿 I。\n\n期间 F 被开出，lsy 去写 F。过程中我在尝试想 H，也有去读过 B 的题意，人工打表了一会儿。这时，隐约听到隔壁桌说了什么，才意识到 H 的 corner case，于是 **H2y164**。\n\n剩下的时间里 lsy 写 F、dhr 搞 I、我想 B，lsy 调了有一段时间后 **F1y224**。dhr 屡次发现自己代码的问题但仍然不过。我看着手工打表莽了一发 B 但 WA 了。于是三人一起看 dhr 的代码，最后在 TLE 和 WA（hash 冲突）之间摆动，dhr 随机数据本地秒过觉得很奇怪，我觉得他的数据造法有问题，因此有过一小段争执，在改了一下手造数据把 I 卡 TLE、甚至把机子卡死后 dhr 有些想放弃 I 了的样子。\n\n卡机期间想出了 B 的正解，于是 **B2y282**。\n\n### 总结\n\n又是只有我有罚时（已经习惯了。。。）\n\n感觉自己写的题中有 3 个都是搞个结论出来输出一下就好了，感觉不是很喜欢。以及，I 好像记搜 + 去零是能过的，我们不知道写挂了什么三个人都没看出错的东西。\n\n其实在南京这地拿金还有点意外的，毕竟参赛手册看起来挺凶的，加上三人去年在南京都有过爆炸经历。\n\n希望期中加油吧（还没开始复习呢。。。）","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"2019 CCPC 厦门游记","url":"/2019-CCPC-厦门游记/","content":"\n* 队伍：Wheatfield with Crows\n* 队员：邓浩然（HbFS-）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：8/12（A，B，D，G，H，I，J，K）\n* 罚时：23:00:10 (1380)\n* 排名：1/238\n\n<!-- more -->\n\n### Day -1\n\n上完大物后去买了个香菇菜包和面包就去 218 集合出发去杭州东了，感慨女生的平均行李数远少于男生。。。之后果不其然地在出租车上晕车了。\n\n在高铁上写了大物作业和数逻实验报告，之后电脑快没电了（早上的课上用掉了一半，CLion 太费电了。。。QAQ）。之后就一直在听歌。\n\n酒店门口看到了一家「中国兰州拉面」，作为兰州人感到了一丝说不出话。放好东西后和队友去吃了「中国兰州拉面」旁的沙茶面，感觉比想象中的好吃一点（因为听说是海鲜做的沙茶酱，以为会是什么奇特的味道）。\n\n### Day 0\n\n起床后看到 Steam 上的 CLANNAD 的简中终于出了，非常高兴，打算回杭州后入了。\n\n买了面包做早饭，之后大家一起打车去了学校。\n\n报道时看到了自己的座位，斜对面就是同校队伍「终于不用去银川了」的座位。听说同校的另外两支队伍离得也很近。感觉这个电脑桌面有点让人一时怀疑它是不是显示器。。。\n\n中午和带队学长及「终于不用去银川了」吃了海鲜，炸豆腐鱼真的好吃，麦仔茶也不错（除了有点甜），在知道原料的情况下尝试了一下土笋冻，觉得还是不太想吃下去。。。\n\n开幕式后去热身赛，发现附近有两支八月时被 cjb 邀过来一起训练的队伍：NJU 的「圆狗粉丝团」（半支 「Calabash」）和 FDU 的「东乡美森是勇者」。\n\n发题面时，前面的同校队伍的人都说 C 是我的题，之后看到题目后差点兴奋地跳了起来，兴奋地写了答案，觉得自己一血稳了，然后失望地发现是二血，慢了半分钟。。。（赛后有人说秦皇岛的热身赛，虽然没有经历过，但我们的校赛和省赛也算是有过类似的经历了，当时一直翻着 P 站才过了的）\n\n四题后想了一会儿 E 不想想了（我可能一会儿都没想），开始摸鱼，比如听 dhr 讲隔壁队的队名（「三相之力」）或去串一串队，之后两个队友就开始看宫崎骏了。。。\n\n感觉食堂的饭还行，有一种出来比赛时吃到的饭怎么都比自己学校好的感觉。。。\n\n晚上队伍简单地开了会，之后写了概统作业。\n\n### Day 1\n\n我出门登陆网站与配置 Vim，dhr 与 lsy 从两头开始读题，配置完后我开始从中间读题，发现 G 可能是签到，和 dhr 说了一下后去写了一会儿，果不其然地成为了一开始榜上一片红的队伍之一。\n\n之后 lsy 上机写 A，dhr 在想 J，我继续读题，读过 B、C、D 后发现 D 是一个简单题，和 dhr 说后在 lsy WA 了一发之后去写了会儿 D，期间 lsy **A2y58** 。确认了一下答案范围开了 `__int128`，也把原来想的线段树换成了树状数组，于是 **D1y66**，lsy 又写了 dhr 的 J，**J1y89**。期间我看榜读 H，发现差分就好了，于是 **H1y99**。在过 A 前，有把 G 改成 `__int128` 又 WA 过一发。\n\ndhr 发现 G 陆续开始有队伍过了，让 lsy 再读一遍题面，一段时间后 lsy 发现了 G 的坑点，我想了有一会儿发现很好改，但在机上又花了一段时间才改对，之后 **G3y133**。\n\ndhr 期间在开 I，我帮着写了一个打表，在过了 G 之后在读和想 F（因为 B 没啥想法，C 想了一会儿就觉得可能是神题，K 是字符串不太擅长，而正好斜对面「圆狗粉丝团」在开 F，L 和 E 没读过，题面太长也没想读。。。）。一段时间后 dhr 出了 I，给 lsy 讲了做法，lsy 花了一些时间理解后 **I1y202**，dhr 则来想 B。\n\n我在发下 M 记后吃了一个堡，然后扔了 F 题来想 B，dhr 有提过一般图但我没能建出图来，之后 dhr 开始有一些抽象的想法，最后他觉得出了就和我说了下，我花了一些时间理解了一下做法，和 dhr 讨论了后半的写法后，吃了下发的一对鸡翅后上机，dhr 去和 lsy 开 K。\n\n一段时间后我写完了 B 且一遍过了样例，但没过一个手造样例，正好他们出了 K，于是打印代码下来找错，又和 dhr 讨论了讨论，把 lsy 赶下机大概三次后过了手造样例，提交 RE，打印后意识到了问题，于是 **B2y273**。\n\n最后和 dhr 围观 lsy 写 K，在疯狂「提交、WA、打印」的循环中逐渐找到了所有错误，最后 **K5y295**，dhr 感觉应该有杯。\n\n结束后 dhr 直接去问「东乡美森是勇者」，发现他们是 7 题。打开手机发现群里 Claris 在说 dhr 夺冠了，有点激动。裁判表示 dhr 的 B 的做法不是标解，一开始以为是水过去的，但想了想好像是对的。\n\n听讲题的时候发现和标算不同的题不止一道。。。L 和 E 到最后都没人读完。\n\n感觉踩了 mjy 有点开心，毕竟赛前一直有种「毕竟是毛嘉怡啊，这怎么能打得过」的想法。\n\n比赛中一直能看到东乡队的一人穿着东乡的痛衣。。。\n\n赛后也听到了银川那边 Immortal Shield rk10 和 AutoClose rk15 的喜报。\n\n### 总结\n\n打得基本上还行吧，希望不会是把下周的运气都花光了之类的，毕竟是队里三人都自闭过的南京赛区啊。\n\n希望下周以及之后的上海和 CCPC Final 加油吧。\n\n### 一些其他的\n\n比完赛、吃完晚饭后回房间睡了一觉，起来后就发现有点微烧了。。。QAQ\n\n还是觉得南京好难打啊，毕竟光校内去的就是除 Legilimens 以外最强的四支。。。不过去南京就住一个晚上，不用像这次一样带这么多东西了。。。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"CMU 15-462 A1 实现笔记","url":"/CMU-15-462-A1-实现笔记/","content":"\n最近在跟 [Computer Graphics (CMU 15-462)](http://15462.courses.cs.cmu.edu/fall2018/) 的课程，所以想把完成 Assignment 1 的过程很粗略地记录一下。\n\n笔记和代码有放在 GitHub 上：https://github.com/PepcyCh/cmu15462-notes\n\n不保证代码正确，只保证看起来差不多。\n\n只实现了吴小林直线算法这一项 bonus。。。\n\n<!-- more -->\n\n## Task 1: Hardware Renderer\n\n热身的 Task，随便写写就好了。\n\n（不过代码的 2 格缩进稍稍有点不习惯）\n\n```c++\nvoid HardwareRenderer::rasterize_point(float x, float y, Color color) {\n    // Task 1:\n    // Implement point rasterization\n    glBegin(GL_POINTS);\n    glColor3f(color.r, color.g, color.b);\n    glVertex2f(x, y);\n    glEnd();\n}\n\nvoid HardwareRenderer::rasterize_line(float x0, float y0,\n                                      float x1, float y1,\n                                      Color color) {\n    // Task 1:\n    // Implement line rasterization\n    glBegin(GL_LINES);\n    glColor3f(color.r, color.g, color.b);\n    glVertex2f(x0, y0);\n    glVertex2f(x1, y1);\n    glEnd();\n}\n\nvoid HardwareRenderer::rasterize_triangle(float x0, float y0,\n                                          float x1, float y1,\n                                          float x2, float y2,\n                                          Color color) {\n    // Task 1:\n    // Implement triangle rasterization\n    glBegin(GL_TRIANGLES);\n    glColor3f(color.r, color.g, color.b);\n    glVertex2f(x0, y0);\n    glVertex2f(x1, y1);\n    glVertex2f(x2, y2);\n    glEnd();\n}\n```\n\n## Task 2 : Warm Up: Drawing Lines\n\n要求实现 $O(length)$ 的画线段的算法，要求支持浮点坐标的端点和任意斜率。\n\n我实现了一下[吴小林直线算法](https://zh.wikipedia.org/wiki/吴小林直线算法)，不过代码是根据原理脑补出来的：\n\n假设我们在绘制一个斜率小于 $1$ 的线段，考虑当前在考虑的像素的 $x$ 坐标是 $x + 0.5$，根据此时相应的 $y$ 坐标与像素坐标 $y_0 + 0.5$ 的差为该像素与上方或下方相邻像素分配透明度。\n\n```c++\nvoid SoftwareRendererImp::rasterize_line( float x0, float y0,\n                                          float x1, float y1,\n                                          Color color) {\n    // Task 2:\n    // Implement line rasterization\n    float dx = abs(x1 - x0), dy = abs(y1 - y0);\n    if (dy <= dx) {\n        if (x0 == x1) return;\n        if (x0 > x1) {\n            swap(x0, x1);\n            swap(y0, y1);\n        }\n        float k = (y1 - y0) / (x1 - x0);\n        float x = floor(x0) + 0.5;\n        float y = y0 + k * (x - x0);\n        for (; x <= x1; x += 1) {\n            float y2 = floor(y) == round(y) ? y - 1 : y + 1;\n            float d = abs(y + 0.5 - round(y + 0.5));\n            rasterize_point(x, y, Color(color.r, color.g, color.b, color.a * (1 - d), true);\n            rasterize_point(x, y2, Color(color.r, color.g, color.b, color.a * d), true);\n            y += k;\n        }\n    } else {\n        if (y0 == y1) return;\n        if (y0 > y1) {\n            swap(y0, y1);\n            swap(x0, x1);\n        }\n        float k = (x1 - x0) / (y1 - y0);\n        float y = floor(y0) + 0.5;\n        float x = x0 + k * (y - y0);\n        for (; y <= y1; y += 1) {\n            float x2 = floor(x) == round(x) ? x - 1 : x + 1;\n            float d = abs(x + 0.5 - round(x + 0.5));\n            rasterize_point(x, y, Color(color.r, color.g, color.b, color.a * (1 - d)), true);\n            rasterize_point(x2, y, Color(color.r, color.g, color.b, color.a * d), true);\n            x += k;\n        }\n    }\n}\n```\n\n实现的时候写错过的地方：\n\n* 像素的坐标要加上 $0.5$\n* 分配的应该是透明度\n\n此时绘制 `/svg/basic/test2.svg` 可以感受一下吴小林算法的抗锯齿效果。因为此时还没有实现颜色的混合，所以之后的测试中都会在直线附近有一道白边，实现 Task 8 之后就一切正常了。\n\n## Task 3: Drawing Triangles\n\n要求实现比对所有像素（采样点）进行判定快的算法。\n\n我的实现是在三角形的包围框中进行判定，实现的时候没有实现 edge rules。\n\n```c++\nvoid SoftwareRendererImp::rasterize_triangle( float x0, float y0,\n                                              float x1, float y1,\n                                              float x2, float y2,\n                                              Color color ) {\n    // Task 3:\n    // Implement triangle rasterization\n    int minx = (int) floor(min({x0, x1, x2}));\n    int maxx = (int) floor(max({x0, x1, x2}));\n    int miny = (int) floor(min({y0, y1, y2}));\n    int maxy = (int) floor(max({y0, y1, y2}));\n\n    float dx0 = x1 - x0, dy0 = y1 - y0;\n    float dx1 = x2 - x1, dy1 = y2 - y1;\n    float dx2 = x0 - x2, dy2 = y0 - y2;\n    float rot = dx0 * dy1 - dy0 * dx1;\n\n    float pd = 1.0f / sample_rate;\n    for (int x = minx; x <= maxx; x++) {\n        for (int y = miny; y <= maxy; y++) {\n            for (int i = 0; i < sample_rate; i++) {\n                for (int j = 0; j < sample_rate; j++) {\n                    float px = (i + 0.5f) * pd, py = (j + 0.5f) * pd;\n                    float e0 = (y + py - y0) * dx0 - (x + px - x0) * dy0;\n                    float e1 = (y + py - y1) * dx1 - (x + px - x1) * dy1;\n                    float e2 = (y + py - y2) * dx2 - (x + px - x2) * dy2;\n                    if (e0 * rot >= 0 && e1 * rot >= 0 && e2 * rot >= 0)\n                        rasterize_point(x + px, y + py, color);\n                }\n            }\n        }\n    }\n}\n```\n\n代码是实现了 SSAA 后的代码。\n\n事实上，判定部分还可以写作 `(e0 >= 0 && e1 >= 0 && e2 >= 0) || (e0 <= 0 && e1 <= 0 && e2 <= 0)`。\n\n## Task 4: Anti-Aliasing Using Supersampling\n\n在 `SoftwareRendererImp` 中新定义一个 `supersample_target`，和一个用来表示当前是否在 SSAA 的 `supersampling`（因为我想在没有 SSAA 的时候直接写入 `rander_target`）。选用 `std::vector` 是为了不用花心思于内存分配与释放上。\n\n```c++\nstd::vector<unsigned char> supersample_target;\nbool supersampling = false;\n```\n\n之后补全 `resolve()` 函数。\n\n```c++\nvoid SoftwareRendererImp::resolve( void ) {\n\n    // Task 4:\n    // Implement supersampling\n    // You may also need to modify other functions marked with \"Task 4\".\n    if (!supersampling) return;\n\n    for (int y = 0; y < target_h; y++) {\n        for (int x = 0; x < target_w; x++) {\n            float sumr = 0;\n            float sumg = 0;\n            float sumb = 0;\n            float suma = 0;\n            for (int i = 0; i < sample_rate; i++) {\n                for (int j = 0; j < sample_rate; j++) {\n                    sumr += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w)];\n                    sumg += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 1];\n                    sumb += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 2];\n                    suma += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 3];\n                }\n            }\n            sumr /= sample_rate * sample_rate;\n            sumg /= sample_rate * sample_rate;\n            sumb /= sample_rate * sample_rate;\n            suma /= sample_rate * sample_rate;\n\n            render_target[4 * (x + y * target_w)] = (uint8_t) sumr;\n            render_target[4 * (x + y * target_w) + 1] = (uint8_t) sumg;\n            render_target[4 * (x + y * target_w) + 2] = (uint8_t) sumb;\n            render_target[4 * (x + y * target_w) + 3] = (uint8_t) suma;\n        }\n    }\n}\n```\n\n要求 SSAA 后不应该改变点的大小和线的粗细，所以我在 `rasterize_point()` 的参数中增加了一项 `point_or_line` ，对于点和线段，直接覆盖 $sample\\_rate \\times sample\\_rate$ 大小的采样点。\n\n```c++\nvoid SoftwareRendererImp::rasterize_point( float x, float y, Color color, bool point_or_line = false ) {\n    // fill in the nearest pixel\n    int sx = (int) floor(x);\n    int sy = (int) floor(y);\n\n    // check bounds\n    if ( sx < 0 || sx >= target_w ) return;\n    if ( sy < 0 || sy >= target_h ) return;\n\n    // fill sample\n    if (!supersampling) {\n        render_target[4 * (sx + sy * target_w)] = (uint8_t) (color.r * 255);\n        render_target[4 * (sx + sy * target_w) + 1] = (uint8_t) (color.g * 255);\n        render_target[4 * (sx + sy * target_w) + 2] = (uint8_t) (color.b * 255);\n        render_target[4 * (sx + sy * target_w) + 3] = (uint8_t) (color.a * 255);\n    } else if (point_or_line) {\n        sx *= sample_rate;\n        sy *= sample_rate;\n        for (int i = 0; i < sample_rate; i++) {\n            for (int j = 0; j < sample_rate; j++) {\n                supersample_target[4 * (sx + j + (sy + i) * target_w * sample_rate)] = (uint8_t) (color.r * 255);\n                supersample_target[4 * (sx + j + (sy + i) * target_w * sample_rate) + 1] = (uint8_t) (color.g * 255);\n                supersample_target[4 * (sx + j + (sy + i) * target_w * sample_rate) + 2] = (uint8_t) (color.b * 255);\n                supersample_target[4 * (sx + j + (sy + i) * target_w * sample_rate) + 3] = (uint8_t) (color.a * 255);\n            }\n        }\n    } else {\n        sx = (int) floor(x * sample_rate);\n        sy = (int) floor(y * sample_rate);\n        supersample_target[4 * (sx + sy * target_w * sample_rate)] = (uint8_t) (color.r * 255);\n        supersample_target[4 * (sx + sy * target_w * sample_rate) + 1] = (uint8_t) (color.g * 255);\n        supersample_target[4 * (sx + sy * target_w * sample_rate) + 2] = (uint8_t) (color.b * 255);\n        supersample_target[4 * (sx + sy * target_w * sample_rate) + 3] = (uint8_t) (color.a * 255);\n    }\n}\n```\n\n## Task 5: Implementing Modeling and Viewing Transforms\n\n### Part 1: Modeling Transforms\n\n参考 `hardware_renderer.cpp` 就好了。\n\n```c++\nvoid SoftwareRendererImp::draw_element( SVGElement* element ) {\n\n  // Task 5 (part 1):\n  // Modify this to implement the transformation stack\n\n  Matrix3x3 temp_matrix = transformation;\n  transformation = transformation * element->transform;\n\n  switch(element->type) {\n    case POINT:\n      draw_point(static_cast<Point&>(*element));\n      break;\n    case LINE:\n      draw_line(static_cast<Line&>(*element));\n      break;\n    case POLYLINE:\n      draw_polyline(static_cast<Polyline&>(*element));\n      break;\n    case RECT:\n      draw_rect(static_cast<Rect&>(*element));\n      break;\n    case POLYGON:\n      draw_polygon(static_cast<Polygon&>(*element));\n      break;\n    case ELLIPSE:\n      draw_ellipse(static_cast<Ellipse&>(*element));\n      break;\n    case IMAGE:\n      draw_image(static_cast<Image&>(*element));\n      break;\n    case GROUP:\n      draw_group(static_cast<Group&>(*element));\n      break;\n    default:\n      break;\n  }\n\n  transformation = temp_matrix;\n}\n```\n\n### Part 2: Viewing Transform\n\n按照原文：\n\n> This transform should map the SVG canvas coordinate space to a normalized device coordinate space where the top left of the visible SVG coordinate maps to `(0, 0)` and the bottom right maps to `(1, 1)`. For example, for the values `centerX=200, centerY=150, vspan=10`, then SVG canvas coordinate `(200, 150)` transforms to normalized coordinate `(0.5, 0.5)` (center of screen) and canvas coordinate `(200, 160)` transforms to `(0.5, 1)` (bottom center).\n\n就可以写出相应的变换矩阵了。注意提供的矩阵是右乘行向量而不是左乘列向量的（或者说注意矩阵的下标）。\n\n```c++\nvoid ViewportImp::set_viewbox( float centerX, float centerY, float vspan ) {\n\n    // Task 5 (part 2):\n    // Set svg coordinate to normalized device coordinate transformation. Your input\n    // arguments are defined as normalized SVG canvas coordinates.\n    this->centerX = centerX;\n    this->centerY = centerY;\n    this->vspan = vspan;\n\n    // Matrix3x3:\n    // 00 10 20\n    // 01 11 21\n    // 02 12 22\n    svg_2_norm = Matrix3x3::identity();\n    svg_2_norm[0][0] = 0.5 / vspan;\n    svg_2_norm[1][1] = 0.5 / vspan;\n    svg_2_norm[2][0] = 0.5 - 0.5 * centerX / vspan;\n    svg_2_norm[2][1] = 0.5 - 0.5 * centerY / vspan;\n}\n```\n\n## Task 6: Drawing Scaled Images\n\n首先是实现 `rasterize_image()` 函数：\n\n```c++\nvoid SoftwareRendererImp::rasterize_image( float x0, float y0,\n                                           float x1, float y1,\n                                           Texture& tex ) {\n    // Task 6:\n    // Implement image rasterization\n    float dx = x1 - x0;\n    float dy = y1 - y0;\n\n    float pd = 1.0f / sample_rate;\n    for (int x = (int) floor(x0 * sample_rate); x <= (int) floor(x1 * sample_rate); x++) {\n        for (int y = (int) floor(y0 * sample_rate); y <= (int) floor(y1 * sample_rate); y++) {\n            float u = ((x + 0.5f) * pd - x0) / dx;\n            float v = ((y + 0.5f) * pd - y0) / dy;\n            // Color c = sampler->sample_nearest(tex, u, v, 0);\n            // Color c = sampler->sample_bilinear(tex, u, v, 0);\n            Color c = sampler->sample_trilinear(tex, u, v, dx, dy);\n            rasterize_point((x + 0.5f) * pd, (y + 0.5f) * pd, c);\n        }\n    }\n}\n```\n\n然后是 `sample_nearest()`：\n\n```c++\nColor Sampler2DImp::sample_nearest(Texture& tex,\n                                   float u, float v,\n                                   int level) {\n    // Task 6: Implement nearest neighbour interpolation\n\n    // return magenta for invalid level\n    if (level >= tex.mipmap.size())\n        return Color(1, 0, 1, 1);\n\n    int su = (int) floor(clamp(u, 0.0f, 0.99999f) * tex.mipmap[level].width);\n    int sv = (int) floor(clamp(v, 0.0f, 0.99999f) * tex.mipmap[level].height);\n\n    float r = tex.mipmap[level].texels[4 * (su + sv * tex.mipmap[level].width)] / 255.0f;\n    float g = tex.mipmap[level].texels[4 * (su + sv * tex.mipmap[level].width) + 1] / 255.0f;\n    float b = tex.mipmap[level].texels[4 * (su + sv * tex.mipmap[level].width) + 2] / 255.0f;\n    float a = tex.mipmap[level].texels[4 * (su + sv * tex.mipmap[level].width) + 3] / 255.0f;\n\n    return Color(r, g, b, a);\n}\n```\n\n和 `sample_bilinear()`：\n\n```c++\nColor Sampler2DImp::sample_bilinear(Texture& tex,\n                                    float u, float v,\n                                    int level) {\n    // Task 6: Implement bilinear filtering\n\n    // return magenta for invalid level\n    if (level >= tex.mipmap.size())\n        return Color(1, 0, 1, 1);\n\n    float tu = clamp(u, 0.0f, 0.99999f) * tex.mipmap[level].width;\n    float tv = clamp(v, 0.0f, 0.99999f) * tex.mipmap[level].height;\n\n    int su[2];\n    su[0] = clamp<int>(round(tu) - 1, 0, tex.mipmap[level].width - 1);\n    su[1] = clamp<int>(su[0] + 1, 0, tex.mipmap[level].width - 1);\n    float du = tu - 0.5f - su[0];\n    if (du < 0) su[1] = su[0];\n\n    int sv[2];\n    sv[0] = clamp<int>(round(tv) - 1, 0, tex.mipmap[level].height - 1);\n    sv[1] = clamp<int>(sv[0] + 1, 0, tex.mipmap[level].height - 1);\n    float dv = tv - 0.5f - sv[0];\n    if (dv < 0) sv[1] = sv[0];\n\n    Color mix = Color(0, 0, 0, 0);\n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2; j++) {\n            float r = tex.mipmap[level].texels[4 * (su[i] + sv[j] * tex.mipmap[level].width)] / 255.0f;\n            float g = tex.mipmap[level].texels[4 * (su[i] + sv[j] * tex.mipmap[level].width) + 1] / 255.0f;\n            float b = tex.mipmap[level].texels[4 * (su[i] + sv[j] * tex.mipmap[level].width) + 2] / 255.0f;\n            float a = tex.mipmap[level].texels[4 * (su[i] + sv[j] * tex.mipmap[level].width) + 3] / 255.0f;\n            Color c = Color(r * a, g * a, b * a, a);\n            mix += (i * du + (1 - i) * (1 - du)) * (j * dv + (1 - j) * (1 - dv)) * c;\n        }\n    }\n\n    if (mix.a != 0) {\n        mix.r /= mix.a;\n        mix.g /= mix.a;\n        mix.b /= mix.a;\n    }\n    return mix;\n}\n```\n\n实现双线性插值的时候因为加不加 $0.5$ 的问题写错过一段时间，当时的效果是图像仿佛向左上角平移了一段距离。\n\n另外，这个多线性插值的写法是当时跟 *Ray Tracing in One Weekend* 系列时学到的，虽然感觉会多几次运算，但看起来似乎美观一点的样子。\n\n## Task 7: Anti-Aliasing Image Elements Using Trilinear Filtering\n\n有了双线性插值，实现三线性插值就很方便了：\n\n```c++\nColor Sampler2DImp::sample_trilinear(Texture& tex,\n                                     float u, float v,\n                                     float u_scale, float v_scale) {\n\n    // Task 7: Implement trilinear filtering\n\n    // return magenta for invalid level\n    float level = max(log2f(max(tex.width / u_scale, tex.height / v_scale)), 0.0f);\n\n    int ld = (int) floor(level);\n    if (ld >= tex.mipmap.size())\n        return Color(1, 0, 1, 1);\n\n    int hd = ld;\n    if (hd >= tex.mipmap.size())\n        return sample_bilinear(tex, u, v, ld);\n\n    Color lc = sample_bilinear(tex, u, v, ld);\n    Color hc = sample_bilinear(tex, u, v, hd);\n\n    lc.r *= lc.a;\n    lc.g *= lc.a;\n    lc.b *= lc.a;\n    hc.r *= hc.a;\n    hc.g *= hc.a;\n    hc.b *= hc.a;\n\n    float dd = level - ld;\n    Color mix = (1 - dd) * lc + dd * hc;\n    if (mix.a != 0) {\n        mix.r /= mix.a;\n        mix.g /= mix.a;\n        mix.b /= mix.a;\n    }\n    return mix;\n}\n```\n\n这个计算 mipmap level 的式子虽然乍一看和课件中的有点不同，但仔细想一想会发现是对的。（当时发现根据传进来的参数似乎只好这么写，后来才意识到它的正确性的。）\n\n然后是 mipmap 的生成，因为要求假定尺寸是 $2$ 的整次幂，所以很好实现：\n\n```c++\nvoid Sampler2DImp::generate_mips(Texture& tex, int startLevel) {\n\n  // NOTE:\n  // This starter code allocates the mip levels and generates a level\n  // map by filling each level with placeholder data in the form of a\n  // color that differs from its neighbours'. You should instead fill\n  // with the correct data!\n\n  // Task 7: Implement this\n\n  // check start level\n  if ( startLevel >= tex.mipmap.size() ) {\n    std::cerr << \"Invalid start level\";\n  }\n\n  // allocate sublevels\n  int baseWidth  = tex.mipmap[startLevel].width;\n  int baseHeight = tex.mipmap[startLevel].height;\n  int numSubLevels = (int)(log2f( (float)max(baseWidth, baseHeight)));\n\n  numSubLevels = min(numSubLevels, kMaxMipLevels - startLevel - 1);\n  tex.mipmap.resize(startLevel + numSubLevels + 1);\n\n  int width  = baseWidth;\n  int height = baseHeight;\n  for (int i = 1; i <= numSubLevels; i++) {\n\n    MipLevel& level = tex.mipmap[startLevel + i];\n\n    // handle odd size texture by rounding down\n    width  = max( 1, width  / 2); assert(width  > 0);\n    height = max( 1, height / 2); assert(height > 0);\n\n    level.width = width;\n    level.height = height;\n    level.texels = vector<unsigned char>(4 * width * height);\n  }\n\n  for(size_t i = 1; i <= numSubLevels; ++i) {\n    MipLevel& mip = tex.mipmap[i];\n\n    for (int x = 0; x < mip.width; x++) {\n      for (int y = 0; y < mip.height; y++) {\n          Color sum = Color(0, 0, 0, 0);\n          for (int j = 0; j < 4; j++) {\n              static const int d[4][2] = {\n                      {0, 0}, {0, 1}, {1, 0}, {1, 1}\n              };\n              float r = tex.mipmap[i - 1].texels[4 * (2 * x + d[j][0] + (2 * y + d[j][1]) * mip.width * 2)] / 255.0f;\n              float g = tex.mipmap[i - 1].texels[4 * (2 * x + d[j][0] + (2 * y + d[j][1]) * mip.width * 2) + 1] / 255.0f;\n              float b = tex.mipmap[i - 1].texels[4 * (2 * x + d[j][0] + (2 * y + d[j][1]) * mip.width * 2) + 2] / 255.0f;\n              float a = tex.mipmap[i - 1].texels[4 * (2 * x + d[j][0] + (2 * y + d[j][1]) * mip.width * 2) + 3] / 255.0f;\n              sum += Color(r * a, g * a, b * a, a);\n          }\n          sum *= 0.25f;\n          if (sum.a != 0) {\n              sum.r /= sum.a;\n              sum.g /= sum.a;\n              sum.b /= sum.a;\n          }\n          float_to_uint8(&mip.texels[4 * (x + y * width)], &sum.r);\n      }\n    }\n  }\n}\n```\n\n其实感觉这段代码写得应该是有问题的，因为它似乎只在 $startLevel = 0$ 的时候是对的，虽说程序中也只有真美调用过。\n\n## Task 8: Alpha Compositing\n\n修改 `rasterize_point()` ：\n\n```c++\nstatic void blend(uint8_t *dst, const Color &c) {\n    dst[0] = (c.r + (1 - c.a) * (dst[0] / 255.0f)) * 255;\n    dst[1] = (c.g + (1 - c.a) * (dst[1] / 255.0f)) * 255;\n    dst[2] = (c.b + (1 - c.a) * (dst[2] / 255.0f)) * 255;\n    dst[3] = (c.a + (1 - c.a) * (dst[3] / 255.0f)) * 255;\n}\n\nvoid SoftwareRendererImp::rasterize_point( float x, float y, Color color, bool point_or_line = false ) {\n    // fill in the nearest pixel\n    int sx = (int) floor(x);\n    int sy = (int) floor(y);\n\n    // check bounds\n    if ( sx < 0 || sx >= target_w ) return;\n    if ( sy < 0 || sy >= target_h ) return;\n\n    // fill sample\n    color.r *= color.a;\n    color.g *= color.a;\n    color.b *= color.a;\n    if (!supersampling) {\n        blend(render_target + (4 * (sx + sy * target_w)), color);\n    } else if (point_or_line) {\n        sx *= sample_rate;\n        sy *= sample_rate;\n        for (int i = 0; i < sample_rate; i++) {\n            for (int j = 0; j < sample_rate; j++) {\n                blend(&supersample_target[4 * (sx + j + (sy + i) * target_w * sample_rate)], color);\n            }\n        }\n    } else {\n        sx = (int) floor(x * sample_rate);\n        sy = (int) floor(y * sample_rate);\n        blend(&supersample_target[4 * (sx + sy * target_w * sample_rate)], color);\n    }\n}\n```\n\n和 `resolve()`：\n\n```c++\nvoid SoftwareRendererImp::resolve( void ) {\n\n    // Task 4:\n    // Implement supersampling\n    // You may also need to modify other functions marked with \"Task 4\".\n    if (!supersampling) {\n        for (int y = 0; y < target_h; y++) {\n            for (int x = 0; x < target_w; x++) {\n                float r = render_target[4 * (x + y * target_w)] / 255.0f;\n                float g = render_target[4 * (x + y * target_w) + 1] / 255.0f;\n                float b = render_target[4 * (x + y * target_w) + 2] / 255.0f;\n                float a = render_target[4 * (x + y * target_w) + 3] / 255.0f;\n                if (a != 0) {\n                    r /= a;\n                    g /= a;\n                    b /= a;\n                }\n                render_target[4 * (x + y * target_w)] = (uint8_t) (r * 255);\n                render_target[4 * (x + y * target_w) + 1] = (uint8_t) (g * 255);\n                render_target[4 * (x + y * target_w) + 2] = (uint8_t) (b * 255);\n            }\n        }\n\n        return;\n    }\n\n    for (int y = 0; y < target_h; y++) {\n        for (int x = 0; x < target_w; x++) {\n            float sumr = 0;\n            float sumg = 0;\n            float sumb = 0;\n            float suma = 0;\n            for (int i = 0; i < sample_rate; i++) {\n                for (int j = 0; j < sample_rate; j++) {\n                    sumr += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w)];\n                    sumg += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 1];\n                    sumb += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 2];\n                    suma += supersample_target[4 * (x * sample_rate + j + (y * sample_rate + i) * sample_rate * target_w) + 3];\n                }\n            }\n            sumr /= sample_rate * sample_rate;\n            sumg /= sample_rate * sample_rate;\n            sumb /= sample_rate * sample_rate;\n            suma /= sample_rate * sample_rate;\n            if (suma != 0) {\n                sumr /= suma / 255;\n                sumg /= suma / 255;\n                sumb /= suma / 255;\n            }\n            render_target[4 * (x + y * target_w)] = (uint8_t) sumr;\n            render_target[4 * (x + y * target_w) + 1] = (uint8_t) sumg;\n            render_target[4 * (x + y * target_w) + 2] = (uint8_t) sumb;\n            render_target[4 * (x + y * target_w) + 3] = (uint8_t) suma;\n        }\n    }\n}\n```\n\n事实上，本来还需修改材质相关部分，但一开始就是按正确的写的。\n\n## Task 9: Draw Something!!!\n\n本想用在线编辑器随便画点，但发现保存后它不能很好地解析，所以就呆呆地画了个正方形在屏幕中央。。。\n\n## 其他（随便口胡）\n\n实现 SSAA 的时候本想去感受一下 MLAA，但一直有个地方没有想清楚（而文章中举例时都正好跳过了我想不通的情况。。。），也看了一下 MSAA，发现其实很好实现的样子，但感觉当像素中心在三角元外的时候会有点奇怪的问题，就是很明显此时插出的材质坐标是不在期望的三角形内部的，但却要用这个代表这个像素（也有可能是我理解错了 MSAA 的做法）。\n\n实现椭圆的话，因为上学期学校程序设计专题的大作业就是写的简易 CAD，当时实现椭圆就是简单粗暴地一点一点地微分凑出椭圆，想来在椭圆的包围盒内依次检查每一个采样点也是一个不错的想法（我甚至觉得比画一堆三角形好）。","tags":["CMU","课程笔记","实现笔记","CG"],"categories":["学习笔记（大学课外）"]},{"title":"[HDU 6118][百度之星 2017 初赛 B] 度度熊的交易计划","url":"/HDU-6118-百度之星-2017-初赛-B-度度熊的交易计划/","content":"\n## 题目大意\n\n在一张 $n$ 个点 $m$ 条边的无向图上，每个点可以以 $a_i$ 的成本制造至多 $b_i$ 个商品，也可以以 $c_i$ 的价格售出至多 $d_i$ 个商品，每条边可以以每件商品 $k_i$ 的价格运输商品。求最大利润。\n\n多组数据。\n\n$1 \\leq n \\leq 500$\n\n$1 \\leq m \\leq 1,000$\n\n$1 \\leq a_i, b_i, c_i, d_i, k_i \\leq 1,000$\n\n## 题目链接\n\n[HDU 6118](http://acm.hdu.edu.cn/showproblem.php?pid=6118)\n\n<!-- more -->\n\n## 题解\n\n考虑费用流，建立一个源点和一个汇点，从源点向每个点建一条容量为 $b_i$、费用为 $a_i$ 的边，从每个点向汇点建一条容量为 $d_i$、费用为 $-c_i$ 的边，对于原图中边权为 $k$ 的每一条边，建一条对应的容量无限、费用为 $k$ 的双向边，跑**最小费用可行流**，答案即最小费用的相反数。\n\n## 代码\n\n与最小费用最大流的区别用注释表示了。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 505;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n    std::vector<Edge> e;\n    Edge *pre;\n    int flow, dist, cnt;\n    bool inq;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    int cap, flow, cost, rev;\n\n    Edge(Node *u, Node *v, int cap, int cost, int rev) : u(u), v(v), rev(rev), cap(cap), flow(0), cost(cost) {}\n};\n\nvoid addEdge(int u, int v, int cap, int cost) {\n    N[u].e.push_back(Edge(&N[u], &N[v], cap, cost, N[v].e.size()));\n    N[v].e.push_back(Edge(&N[v], &N[u], 0, -cost, N[u].e.size() - 1));\n}\n\nnamespace EdmondsKarp {\n    void solve(int s, int t, int n, int &flow, int &cost) {\n        flow = cost = 0;\n        while (true) {\n            for (int i = 0; i < n; i++) {\n                N[i].dist = INT_MAX;\n                N[i].flow = 0;\n                N[i].pre = NULL;\n            }\n\n            std::queue<Node *> q;\n            q.push(&N[s]);\n            N[s].dist = 0;\n            N[s].flow = INT_MAX;\n            while (!q.empty()) {\n                Node *u = q.front();\n                q.pop();\n\n                for (Edge *e = &u->e.front(); e <= &u->e.back(); e++) {\n                    if (e->cap > e->flow && e->v->dist > u->dist + e->cost) {\n                        e->v->dist = u->dist + e->cost;\n                        e->v->flow = std::min(u->flow, e->cap - e->flow);\n                        e->v->pre = e;\n                        q.push(e->v);\n                    }\n                }\n            }\n\n            // if (N[t].dist == INT_MAX) break;\n            if (N[t].dist > 0) break;\n\n            for (Edge *e = N[t].pre; e; e = e->u->pre) {\n                e->flow += N[t].flow;\n                e->v->e[e->rev].flow -= N[t].flow;\n            }\n\n            flow += N[t].flow;\n            cost += N[t].dist * N[t].flow;\n        }\n    }\n}\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        N[i].e.clear();\n    }\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        init(n + 2);\n        const int s = 0, t = n + 1;\n\n        for (int i = 1, a, b, c, d; i <= n; i++) {\n            scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n            addEdge(s, i, b, a);\n            addEdge(i, t, d, -c);\n        }\n\n        for (int i = 0, u, v, w; i < m; i++) {\n            scanf(\"%d %d %d\", &u, &v, &w);\n            addEdge(u, v, INT_MAX, w);\n            addEdge(v, u, INT_MAX, w);\n        }\n\n        int flow, cost;\n        EdmondsKarp::solve(s, t, n + 2, flow, cost);\n        printf(\"%d\\n\", -cost);\n    }\n\n    return 0;\n}\n```","tags":["费用流","最小费用可行流"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[Codeforces Round 549] Div1-C/Div2-F U2","url":"/Codeforces-Round-549-Div1-C-Div2-F-U2/","content":"\n## 题目大意\n\n平面上任意两个横坐标不同的点可以确定一条形如 $y = x^2 + bx + c$ 的抛物线。现给出平面上的 $n$ 个点，以它们建出尽可能多的此种抛物线，使得任意一个点不在某个抛物线的上方（在线上不计）。\n\n$1 \\leq n \\leq 100,000$\n\n$|x_i|, |y_i| \\leq 1,000,000$\n\n## 题目链接\n\n[Codeforces Round 549 - Div1-C/Div2-F](https://codeforces.com/contest/1142/problem/C)\n\n<!-- more -->\n\n## 题解\n\n对式子进行移项，得 $y - x^2 = bx + c$，即把所有点改成 $(x_i, y_i - x_i^2)$，求它们的一个上凸包。\n\n记得对相同横坐标的点只取纵坐标最大的一个，因为要求横坐标不同的点才能构成抛物线。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct Point {\n    long long x, y;\n\n    Point() {}\n    Point(long long x, long long y) : x(x), y(y) {}\n\n    Point operator-(const Point &rhs) const { return Point(x - rhs.x, y - rhs.y); }\n    friend long long cross(const Point &a, const Point &b) { return a.x * b.y - a.y * b.x; }\n} P[MAXN], ch[MAXN];\n\nint getConvexHull(int n) {\n    std::sort(P, P + n, [](const Point &a, const Point &b) {\n                return a.x == b.x ? a.y < b.y : a.x < b.x;\n            });\n    int p = 0;\n    for (int i = 0; i < n; i++) if (i == n - 1 || P[i].x != P[i + 1].x) P[p++] = P[i];\n    int m = 0;\n    for (int i = 0; i < p; i++) {\n        while (m > 1 && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) >= 0) --m;\n        ch[m++] = P[i];\n    }\n    return m;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lld %lld\", &P[i].x, &P[i].y);\n        P[i].y = P[i].y - P[i].x * P[i].x;\n    }\n    int ans = getConvexHull(n) - 1;\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}\n```","tags":["计算几何","凸包"],"categories":["题解（OI/XCPC）"]},{"title":"[ZOJ 3964] Yet Another Game of Stones","url":"/ZOJ-3964-Yet-Another-Game-of-Stones/","content":"\n## 题目大意\n\nAlice 与 Bob 取 $n$ 堆石子（Alice 为先手），但每堆除数目 $a_i$，还有一个针对 Alice 的限制 $b_i$，具体地说：\n\n* $b_i = 0$，则该堆对 Alice 无限制\n* $b_i  = 1$，则 Alice 只能在该堆取奇数个石子\n* $b_i = 2$，则 Alice 只能在该堆取偶数个石子\n\n问 Alice 是否必胜。\n\n$1 \\leq n \\leq 100,000$\n\n$1 \\leq a_i \\leq 1,000,000,000$\n\n## 题目链接\n\n[ZOJ 3964](http://acm.zju.edu.cn/onlinejudge/showProblem.do?problemId=5596)\n\n<!-- more -->\n\n## 题解\n\n一道非公平博弈的题，则要考虑什么时候公平，以及不公平时怎么变的公平。\n\n首先，如果有一堆石子满足 $a_i = 1$ 且 $b_i = 1$，则此时这个限制是无用的，之后我们讨论的限制都是有用的限制。\n\n如果所有堆都无有用限制，那就是普通的 NIM 游戏。\n\n如果只有一个限制堆：\n\n* Alice 可以将其取光，剩余石子堆为普通的 NIM 游戏。\n* Alice 可以将其取至只剩一个，此时限制无用，为普通 NIM 游戏。\n* 否则 Alice 对这一堆无可奈何，Bob 必胜。\n\n如果有多个限制堆，则必有一个 Alice 无可奈何，Bob 必胜。\n\n## 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 100005;\n\nint a[MAXN], b[MAXN];\n\nvoid solve() {\n    int n, nim = 0, cnt = 0;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &b[i]);\n        if (b[i] == 1 && a[i] == 1) b[i] = 0;\n        if (!b[i]) nim ^= a[i];\n        else ++cnt;\n    }\n    if (cnt > 1) {\n        puts(\"Bob\");\n        return;\n    } else if (cnt == 0) {\n        puts(nim ? \"Alice\" : \"Bob\");\n        return;\n    }\n    bool ans = true;\n    for (int i = 0; i < n; i++) if (b[i]) {\n        if (b[i] % 2 == a[i] % 2) {\n            ans = !nim;\n        } else if (b[i] == 1) {\n            ans = nim == 1;\n        } else {\n            ans = false;\n        }\n    }\n    puts(ans ? \"Alice\" : \"Bob\");\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) solve();\n    return 0;\n}\n```","tags":["博弈","不公平博弈","NIM博弈"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Round 526] Div1-B/Div2-E The Fair Nut and Strings","url":"/Codeforces-Round-526-Div1-B-Div2-E-The-Fair-Nut-and-Strings/","content":"\n## 题目大意\n\n本题中所有字符串均只由 $a$、$b$ 两种字符组成。\n\n给出两个长为 $n$ 的字符串 $s$ 和 $t$，保证有字典序 $s \\leq t$ 。现要给出 $k$ 个长为 $n$ 的、字典序介于 $s$ 与 $t$ 的字符串，使得可以作为其中至少一个字符串的前缀的字符串数目最多，求这个数目。\n\n$1 \\leq n \\leq 500,000$\n\n$1 \\leq k \\leq 10^9$\n\n## 题目链接\n\n[Codeforces Round 526 - Div1-B/Div2-E](https://codeforces.com/contest/1083/problem/B)\n\n<!-- more -->\n\n## 题解\n\n考虑一棵以 $s$ 和 $t$ 为「边界」的 Trie。假如已经找好了所有 $k$ 个字符串，放入后叶子结点的数目就是 $k$，除根节点外的总节点数就是所求数目，考虑如何最大化这个数目。\n\n从头到尾考虑字符串，考虑 Trie 的形态，在更早尽可能多地分支会使答案更大，于是一个贪心策略就是：每次尽可能多地分支，同时维护当前层的节点数，直到该层节点数不小于 $k$。\n\n感觉是一道很妙的题。\n\n## 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 500005;\n\nchar s[MAXN], t[MAXN];\n\nint main() {\n    int n, k;\n    scanf(\"%d %d %s %s\", &n, &k, s, t);\n\n    long long ans = 0, curr = 1;\n    for (int i = 0; i < n; i++) {\n        curr = curr * 2 - int(s[i] == 'b') - int(t[i] == 'a');\n        if (curr >= k) {\n            ans += 1ll * k * (n - i);\n            break;\n        } else ans += curr;\n    }\n\n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n```","tags":["字符串","贪心","Trie"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Hello 2019] D Makoto and a Blackboard","url":"/Codeforces-Hello-2019-D-Makoto-and-a-Blackboard/","content":"\n## 题目大意\n\n给出一个数 $n$，每次它会等概率地变为它的一个约数，求 $k$ 次操作后该数的期望，对 $1,000,000,007$ 取模。\n\n$1 \\leq n \\leq 10^{15}$\n\n$1 \\leq k \\leq 10^4$\n\n## 题目链接\n\n[Codeforces Hello 2019 - D](https://codeforces.com/contest/1097/problem/D)\n\n<!-- more -->\n\n## 题解\n\n容易发现答案是关于 $n$ 的积性函数，则只需考虑 $n = p^q ~ (p \\text{ is prime})$ 时的答案，记为 $f(p, q, k)$，则有：\n$$\nf(p, q, k) = \\frac{1}{q + 1} \\sum_{i = 0}^{q} f(p, i, k - 1)\n$$\n通过预处理逆元和前缀和可以做到 $O(qk)$ （不预处理逆元也可以过）。\n\n## 代码\n\n```c++\n#include <bits/stdc++.h>\n\nconst int MOD = 1000000007;\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nlong long inv(long long x) {\n    return qpow(x, MOD - 2);\n}\n\nconst int MAXK = 10005;\n\nstd::queue<std::pair<long long, int> > q;\n\nlong long calc(long long p, long long n, long long k) {\n    static long long f[2][MAXK];\n    for (int i = 0; i <= n; i++) f[0][i] = qpow(p, i);\n\n    int curr = 0, last = 1;\n    for (int i = 0; i < k; i++) {\n        for (int j = 1; j <= n; j++) {\n            f[curr][j] += f[curr][j - 1];\n            f[curr][j] >= MOD ? f[curr][j] -= MOD : 0;\n        }\n        curr ^= 1, last ^= 1;\n        for (int j = 0; j <= n; j++)\n            f[curr][j] = f[last][j] * inv(j + 1) % MOD;\n    }\n\n    return f[curr][n];\n}\n\nint main() {\n    long long n;\n    int k;\n    scanf(\"%lld %d\", &n, &k);\n\n    long long temp = n;\n    for (long long i = 2; i * i <= temp; i++) if (temp % i == 0) {\n        int k = 0;\n        while (temp % i == 0) {\n            ++k;\n            temp /= i;\n        }\n        q.emplace(i, k);\n    }\n    if (temp > 1) q.emplace(temp, 1);\n\n    long long ans = 1;\n    while (!q.empty()) {\n        auto u = q.front();\n        q.pop();\n\n        long long t = calc(u.first, u.second, k);\n        ans = ans * t % MOD;\n    }\n\n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n```","tags":["积性函数"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Hello 2019] F Alex and a TV Show","url":"/Codeforces-Hello-2019-F-Alex-and-a-TV-Show/","content":"\n## 题目大意\n\n维护 $n$ 个可重集，有 $q$ 次操作，操作有四种：\n\n* `1 x v` ：让第 $x$ 个集合变为 $\\{v\\}$\n* `2 x y z` ：让第 $x$ 个集合变为第 $y$ 个集合与第 $z$ 个集合的并（因为是可重集，所以指的是直接合在一起）\n* `3 x y z` ：让第 $x$ 个集合变为第 $y$ 个集合与第 $z$ 个集合的积，定义 $A \\times B = \\{\\gcd(a, b) \\mid a \\in A, b \\in B\\}$\n* `4 x v` ：询问 $v$ 在第 $x$ 个集合中出现的次数，对 $2$ 取模\n\n$1 \\leq n \\leq 10^5$\n\n$1 \\leq q \\leq 10^6$\n\n$1 \\leq v \\leq 7,000$\n\n## 题目链接\n\n[Codeforces Hello 2019 - F](https://codeforces.com/contest/1097/problem/F)\n\n<!-- more -->\n\n## 题解\n\n考虑到询问只对 $2$ 取模，再观察数据范围，意识到复杂度应该是 $O(qv / 32)$  ，考虑用 bitset 表示每一个集合，此时发现无法快速地完成操作三。\n\n考虑存储约数而非数本身，则操作三就是两个 bitset 的按位与。通过预处理，前三个操作都可以做到 $O(v / 32)$ 了，考虑如何快速回答询问。\n\n记 $f(x)$ 表示在原集合中 $x$ 的出现次数，$g(x)$ 表示 $x$ 作为因子出现的次数（即转化后的集合中出现的次数），有：\n$$\ng(d) = \\sum_{d \\mid n} f(n)\n$$\n则：\n$$\nf(d) = \\sum_{d | n} g(n) \\mu(\\frac{n}{d})\n$$\n通过预处理，所有操作均可做到 $O(v / 32)$。\n\n## 代码\n\n```c++\n#include <bits/stdc++.h>\n\nconst int MAXN = 100005;\nconst int MAXV = 7005;\n\nstd::bitset<MAXV> bs[MAXN], num[MAXV], dv[MAXV];\n\nvoid init() {\n    for (int i = 1; i < MAXV; i++) for (int j = i; j < MAXV; j += i) num[j][i] = 1;\n\n    static bool mu[MAXV];\n    for (int i = 1; i < MAXV; i++) {\n        mu[i] = true;\n        for (int j = 2; j <= i; j++) if (i % j == 0) {\n            mu[i] = (i / j % j == 0) ? false : mu[i / j];\n            break;\n        }\n    }\n\n    for (int i = 1; i < MAXV; i++) for (int j = 1; i * j < MAXV; j++) dv[i][i * j] = mu[j];\n}\n\nint main() {\n    init();\n\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n\n    while (q--) {\n        int op, x;\n        scanf(\"%d %d\", &op, &x);\n\n        if (op == 1) {\n            int v;\n            scanf(\"%d\", &v);\n            bs[x] = num[v];\n        } else if (op == 2) {\n            int y, z;\n            scanf(\"%d %d\", &y, &z);\n            bs[x] = bs[y] ^ bs[z];\n        } else if (op == 3) {\n            int y, z;\n            scanf(\"%d %d\", &y, &z);\n            bs[x] = bs[y] & bs[z];\n        } else {\n            int v;\n            scanf(\"%d\", &v);\n            putchar(((bs[x] & dv[v]).count() & 1) + '0');\n        }\n    }\n    puts(\"\");\n    \n    return 0;\n}\n```","tags":["数学","容斥原理","莫比乌斯反演"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Good Bye 2018] F New Year and the Mallard Expedition","url":"/Codeforces-Good-Bye-2018-F-New-Year-and-the-Mallard-Expedition/","content":"\n## 题目大意\n\n走一段由 $n$ 段路程组成的路，每段路的长度为 $l_i$，地形为草地、水、岩浆中的一种。有三种运动方式，走路、游泳和飞行。走路一单位长度耗时 $5$，可获得 $1$ 点能量，只能在草地上；游泳一单位长度耗时 $3$，可获得 $1$ 点能量，只能在水中；飞行一单位长度耗时 $1$，消耗 $1$ 点能量，可以在任何地形上使用。每时每刻能量不可为负值，可以在任意时刻调整运动方式和运动方向，求最短用时。\n\n$1 \\leq n \\leq 100,000$\n\n$1 \\leq l_i \\leq 10^{12}$\n\n## 题目链接\n\n[Codeforces Good Bye 2018 - F](https://codeforces.com/contest/1091/problem/F)\n\n<!-- more -->\n\n## 题解\n\n先在所有草地上走、在所有水中游泳、在所有岩浆上飞行，考虑贪心地调整到最优解。\n\n首先，以上描述的运动策略不一定合法，即可能会出现能量为负的情况。此时可以考虑选取之前的一段水或草地，在其上往返游泳或走一单位长度可获得 $1$ 点能量，由于游泳耗时更短，所以只要之前有水，就在水上往返运动，且可获得的能量与路径长度无关（即再短的路也可以为我们带来所需的能量）。\n\n其次，可以发现最优解时最后一定不会有剩余的能量，如果有，我们考虑将之前的一段走或游泳转为飞行，$S$ 点剩余能量可以转化之前 $S / 2$ 单位长度的路。由于走路耗时更大，故应尽可能多地转化步行。考虑可以被转化的步行的长度的上界：首先，记走过了长为 $G$ 的草地，上界一定不大于 $G$；其次，途中不能出现负值的能量，所以对每一段路结束时剩余的能量 $S$ ，用 $S / 2$ 更新上界。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nlong long l[MAXN];\nchar str[MAXN];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%lld\", &l[i]);\n    scanf(\"%s\", str);\n\n    long long ans = 0, stamina = 0, convert = 0;\n    bool hasWater = false;\n\n    for (int i = 0; i < n; i++) {\n        if (str[i] == 'G') {\n            ans += 5 * l[i];\n            stamina += l[i];\n            convert += 2 * l[i];\n        } else if (str[i] == 'W') {\n            ans += 3 * l[i];\n            stamina += l[i];\n            hasWater = true;\n        } else  {\n            ans += l[i];\n            stamina -= l[i];\n            if (stamina < 0) {\n                ans -= stamina * (hasWater ? 3 : 5);\n                stamina = 0;\n            }\n        }\n\n        convert = std::min(convert, stamina);\n    }\n\n    if (stamina > 0) {\n        ans -= 2 * convert;\n        ans -= stamina - convert;\n    }\n\n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n```","tags":["贪心"],"categories":["题解（OI/XCPC）"]},{"title":"[2016 Multi-University Training Contest 8] I Rikka with Subset","url":"/2016-Multi-University-Training-Contest-8-I-Rikka-with-Subset/","content":"\n## 题目大意\n\n给出一个长为 $n$ 的整数列 $\\{a_i\\}$ 。对 $1 \\sim n$ 中的每一个数 $k$ ，定义其一个子集 $S$ 关于 $k$ 的值为 $S$ 中前 $\\min\\{|S|, k\\}$ 大的数之和；定义一个关于该数列和 $k$ 的函数，其值为该数列所有非空子集关于 $k$ 的值之和。对每一个 $k$，求出其函数值，答案对 $998244353$ 取模。$T$ 组数据。\n\n$1 \\leq T \\leq 10$\n\n$1 \\leq n \\leq 100,000$\n\n$0 \\leq a_i \\leq 10^9$\n\n## 题目链接\n\n[HDU 5829](http://acm.hdu.edu.cn/showproblem.php?pid=5829)\n\n<!-- more -->\n\n## 题解\n\n对数列按增序排序。发现计算函数值的逐差更容易，记为 $s_k$ ，表示数列所有大小至少为 $k$ 的非空子集中第 $k$ 大的数之和。考虑每个数在多少个子集中可以作为第 $k$ 大的数，有：（数列下标从 $0$ 开始）\n$$\n\\begin{align}\ns_k &= \\sum_{i = 0}^{n - k} a_i 2^i \\binom{n - i - 1}{k - 1} \\\\\n&= \\frac{1}{(k - 1)!} \\sum_{i = 0}^{n - k} \\frac{a_i 2^i (n - i - 1)!}{(n - i - k)!}\n\\end{align}\n$$\n发现计算 $s_k$ 时和式有 $n - k + 1$ 项，考虑将 $s$ 倒序得到 $\\{s'_k\\}$ ，并试图推出卷积形式：\n$$\ns'_k = \\frac{1}{n - k - 1} \\sum_{i = 0}^{k} a_i 2^i (n - i - 1)! \\times \\frac{1}{(k - i)!}\n$$\n取序列 $f$、$g$：\n$$\nf_i = a_i 2^i (n - i - 1)! \\\\\ng_i = \\frac{1}{i!}\n$$\n它们做卷积可得到 $\\{(n - k - 1)s'_k\\}$ ，继而得到答案。\n\n## 代码\n\n行末必须有空格，否则会 PE。\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\nconst int MAXN_EXTEND = 262144;\nconst int MOD = 998244353;\nconst int G = 3;\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nlong long inv(long long x) {\n    return qpow(x, MOD - 2);\n}\n\nlong long fact[MAXN], invFact[MAXN], pow2[MAXN];\n\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) fact[i] = fact[i - 1] * i % MOD;\n    invFact[MAXN - 1] = inv(fact[MAXN - 1]);\n    for (int i = MAXN - 2; ~i; i--) invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n\n    pow2[0] = 1;\n    for (int i = 1; i < MAXN; i++) {\n        pow2[i] = pow2[i - 1] << 1ll;\n        pow2[i] >= MOD ? pow2[i] -= MOD : 0;\n    }\n}\n\nnamespace NTT {\n    static const int N = ::MAXN_EXTEND;\n\n    long long omega[N], omegaInv[N];\n\n    void init() {\n        long long g = qpow(G, (MOD - 1) / N), ig = inv(g);\n        omega[0] = omegaInv[0] = 1;\n        for (int i = 1; i < N; i++) {\n            omega[i] = omega[i - 1] * g % MOD;\n            omegaInv[i] = omegaInv[i - 1] * ig % MOD;\n        }\n    }\n\n    int extend(int n) {\n        int res = 1;\n        while (res < n) res <<= 1;\n        return res;\n    }\n\n    void reverse(long long *a, int n) {\n        for (int i = 0, j = 0; i < n; i++) {\n            if (i < j) std::swap(a[i], a[j]);\n            for (int l = n >> 1; (j ^= l) < l; l >>= 1) {}\n        }\n    }\n\n    void transform(long long *a, int n, long long *omega) {\n        reverse(a, n);\n\n        for (int l = 2; l <= n; l <<= 1) {\n            int hl = l >> 1;\n            for (long long *x = a; x != a + n; x += l) {\n                for (int i = 0; i < hl; i++) {\n                    long long t = omega[N / l * i] * x[i + hl] % MOD;\n                    x[i + hl] = (x[i] - t + MOD) % MOD;\n                    x[i] += t;\n                    x[i] >= MOD ? x[i] -= MOD : 0;\n                }\n            }\n        }\n    }\n\n    void dft(long long *a, int n) {\n        transform(a, n, omega);\n    }\n\n    void idft(long long *a, int n) {\n        transform(a, n, omegaInv);\n        long long t = inv(n);\n        for (int i = 0; i < n; i++) a[i] = a[i] * t % MOD;\n    }\n}\n\nint a[MAXN];\nlong long f[MAXN_EXTEND], g[MAXN_EXTEND], s[MAXN];\n\nint main() {\n    init();\n    NTT::init();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n        std::sort(a, a + n);\n\n        for (int i = 0; i < n; i++) {\n            f[i] = a[i] * fact[n - i - 1] % MOD * pow2[i] % MOD;\n            g[i] = invFact[i];\n        }\n\n        int N = NTT::extend(n << 1);\n        std::fill(f + n, f + N, 0);\n        std::fill(g + n, g + N, 0);\n\n        NTT::dft(f, N);\n        NTT::dft(g, N);\n        for (int i = 0; i < N; i++) f[i] = f[i] * g[i] % MOD;\n        NTT::idft(f, N);\n\n        for (int i = 0; i < n; i++) s[n - i - 1] = f[i] * invFact[n - i - 1] % MOD;\n        for (int i = 1; i < n; i++) {\n            s[i] += s[i - 1];\n            s[i] >= MOD ? s[i] -= MOD : 0;\n        }\n        for (int i = 0; i < n; i++) printf(\"%lld \", s[i]);\n        puts(\"\");\n    }\n    \n    return 0;\n}\n```","tags":["多校","FFT","数学","卷积"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Good Bye 2018] E New Year and the Acquaintance Estimation","url":"/Codeforces-Good-Bye-2018-E-New-Year-and-the-Acquaintance-Estimation/","content":"\n## 题目大意\n\n已知一张 $n + 1$ 个点的无向图中 $n$ 个点的度数，求另一个点可能的度数。\n\n$1 \\leq n \\leq 500,000$\n\n## 题目链接\n\n[Codeforces Good Bye 2018 - E](https://codeforces.com/contest/1091/problem/E)\n\n<!-- more -->\n\n## 题解\n\n如果已知所有点的度数，可以通过以下方法构造出一张图，或判断出无解：\n\n1. 按降序排序度数\n2. 取出第一个点，记其度数为 $deg$ ，并向之后的 $deg$ 个点连边，它们的度数减一\n3. 反复以上步骤直至剩余的度数全为 $0$，或发现做不到\n\n该算法称为 [Havel–Hakimi algorithm](https://en.wikipedia.org/wiki/Havel%E2%80%93Hakimi_algorithm) ，并且原题已经友好地给了我们 wiki 的链接。（比赛时猜到了这种构造，点开链接后才确认了正确性）\n\n如果未知点（记作 $u_0$ ）的度数为 $deg$ 时有解，考虑图中的一条边 $(u, v)$ ，且不存在边 $(u_0, u)$、$(u_0, v)$，那么可以找到 $u_0$ 度数为 $deg + 2$ 时的一个解。感受一下，可能的度数一定是一段连续的奇/偶数，那么我们只要找到上界与下界即可。\n\n仔细思考/手动模拟之后发现，如果一个点的度数为某个值时有解，让该度数加上或减去 $1$，Havel-Hakimi 最终得到的序列会有一个 $\\pm 1$ （其位置可能会在 $n$ 以后）。可以考虑以下算法：\n\n先让 $u_0$ 与其他点不连边，对已知的 $n$ 个点跑 Havel-Hakimi，最后的序列的绝对值之和为下界；让 $u_0$ 与其他点都连边（相当于其他点的度数均减 $1$ ），对这 $n$ 个点跑 Havel-Hakimi，最后的序列的绝对值之和为上界。\n\n现在考虑如何高效地跑 Havel-Hakimi。操作可以描述为区间减 $1$ 和整体排序。由于区间修改操作前序列有序，而每次操作只会让数减 $1$，整体排序操作可以高效完成。具体地说，记操作区间右端点为 $r$、序列为 $\\{d_i\\}$，则在修改操作前 $d_r = d_{r + 1}$ 时才会需要重新调整顺序。需要调整时，可以找到连续的一段值为 $d_r$ 的区间 $[L, R] ~ (r, r + 1\\in [L, R])$ ，在修改与排序操作后，$[L, R]$ 的前 $R - r$ 个数不变，后 $r - L + 1$ 个数减 $1$。\n\n具体实现上，可以用线段树维护序列，查找相等的区间时直接二分，时间复杂度是 $O(n \\log^2n)$ ，依靠线段树的二分结构可以做到 $O(n \\log n)$。\n\n## 代码\n\n```c++\n#include <bits/stdc++.h>\n\nconst int MAXN = 500005;\n\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int l, r;\n        long long min, tag;\n\n        Node() {}\n        Node(int pos, int val) : l(pos), r(pos), min(val), tag(0), lc(NULL), rc(NULL) {}\n        Node(Node *lc, Node *rc) : l(lc->l), r(rc->r), lc(lc), rc(rc), tag(0) {\n            maintain();\n        }\n\n        void add(long long d) {\n            min += d;\n            tag += d;\n        }\n\n        void pushDown() {\n            if (tag) {\n                lc->add(tag);\n                rc->add(tag);\n                tag = 0;\n            }\n        }\n\n        void maintain() {\n            min = std::min(lc->min, rc->min);\n        }\n\n        void update(int l, int r, int d) {\n            if (r < this->l || this->r < l) return;\n            if (l <= this->l && this->r <= r) {\n                add(d);\n                return;\n            }\n            pushDown();\n            lc->update(l, r, d);\n            rc->update(l, r, d);\n            maintain();\n        }\n\n        long long query(int l, int r) {\n            if (r < this->l || this->r < l) return LLONG_MAX;\n            if (l <= this->l && this->r <= r) return min;\n            pushDown();\n            return std::min(lc->query(l, r), rc->query(l, r));\n        }\n\n        int bisearch(int l, int r, int val) {\n            if (this->l == this->r) return this->l;\n            int mid = this->l + ((this->r - this->l) >> 1);\n            pushDown();\n            if (r <= mid) return lc->bisearch(l, r, val);\n            if (l > mid) return rc->bisearch(l, r, val);\n            if (lc->min > val) return rc->bisearch(l, r, val);\n            else return lc->bisearch(l, r, val);\n        }\n    } *root, _pool[MAXN << 1], *_curr;\n\n    SegT() : root(NULL), _curr(_pool) {}\n\n    Node *_build(int l, int r, int *a) {\n        if (l == r) return new (_curr++) Node(l, a[l]);\n        int mid = l + ((r - l) >> 1);\n        return new (_curr++) Node(_build(l, mid, a), _build(mid + 1, r, a));\n    }\n    void build(int l, int r, int *a) {\n        _curr = _pool;\n        root = _build(l, r, a);\n    }\n\n    void update(int l, int r, int d) {\n        root->update(l, r, d);\n    }\n\n    long long query(int l, int r) {\n        return root->query(l, r);\n    }\n\n    int bisearch(int l, int r, int val) {\n        if (root->query(l, r) > val) return r + 1;\n        return root->bisearch(l, r, val);\n    }\n} segT;\n\nint d[MAXN];\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &d[i]);\n\n    std::sort(d + 1, d + n + 1, std::greater<int>());\n\n    segT.build(1, n, d);\n    int L = 0, i;\n    for (i = 1; i <= n; i++) {\n        int t = segT.query(i, i);\n        if (t <= 0) break;\n\n        L += std::max(i + t - n, 0);\n\n        if (i + t + 1 <= n) {\n            int a = segT.query(i + t, i + t);\n            int b = segT.query(i + t + 1, i + t + 1);\n            if (a == b) {\n                int pos1 = segT.bisearch(i + 1, i + t, a);\n                int pos2 = segT.bisearch(i + t + 1, n, b - 1) - 1;\n\n                int cnt = i + t + 1 - pos1;\n                segT.update(pos1, pos1 + cnt - 1, 1);\n                segT.update(pos2 - cnt + 1, pos2, -1);\n            }\n        }\n        segT.update(i + 1, i + t, -1);\n    }\n    for (; i <= n; i++) L += std::abs(segT.query(i, i));\n\n    for (int i = 1; i <= n; i++) --d[i];\n    segT.build(1, n, d);\n    int R = n;\n    for (i = 1; i <= n; i++) {\n        int t = segT.query(i, i);\n        if (t <= 0) break;\n\n        R -= std::max(i + t - n, 0);\n\n        if (i + t + 1 <= n) {\n            int a = segT.query(i + t, i + t);\n            int b = segT.query(i + t + 1, i + t + 1);\n            if (a == b) {\n                int pos1 = segT.bisearch(i + 1, i + t, a);\n                int pos2 = segT.bisearch(i + t + 1, n, b - 1) - 1;\n\n                int cnt = i + t + 1 - pos1;\n                segT.update(pos1, pos1 + cnt - 1, 1);\n                segT.update(pos2 - cnt + 1, pos2, -1);\n            }\n        }\n        segT.update(i + 1, i + t, -1);\n    }\n    for (; i <= n; i++) R -= std::abs(segT.query(i, i));\n\n    if (L > R) printf(\"-1\");\n    for (int i = L; i <= R; i += 2) printf(\"%d \", i);\n    puts(\"\");\n    \n    return 0;\n}\n```","tags":["线段树","二分","线段树上二分","Havel-Hakimi"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Educational Round 57] E The Top Scorer","url":"/Codeforces-Educational-Round-57-E-The-Top-Scorer/","content":"\n## 题目大意\n\n$p$ 个人玩一个游戏，胜者会从分数最高的人中等概率地选出。已知 $p$ 个人的分数总和 $s$ 和一号玩家的分数下限 $r$，求一号玩家获胜的概率。答案对 $998244353$ 取模。\n\n$1 \\leq p \\leq 100$\n\n$0 \\leq r \\leq s \\leq 5,000$\n\n## 题目链接\n\n[Codeforces Educational Round 57 - E The Top Scorer](https://codeforces.com/contest/1096/problem/E)\n\n<!-- more -->\n\n## 题解\n\n让一号玩家取胜，我们可以枚举一号玩家的分数 $i$，以及达到该分数的玩家数 $cnt$，其余的人分数任意但均小于 $i$，且总和为 $s - i \\times cnt$。即统计 $n$ 个不超过 $l$ 的数和为 $sum$ 的方案数，这是一个经典的容斥问题，其算式为 $\\sum_{i = 0}^{n} (-1)^i \\binom{n}{i} \\binom{sum + n - 1 - il}{n - 1}$ 。由此可在确定 $i$、$cnt$ 的情况下的算得方案数（对答案的贡献每一项要乘上 $cnt^{-1}$ ），最后除以总方案数即可。\n\n## 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 10005;\nconst int MOD = 998244353;\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nlong long inv(long long x) {\n    return qpow(x, MOD - 2);\n}\n\nlong long fact[MAXN], invFact[MAXN];\nvoid init() {\n    fact[0] = 1;\n    for (int i = 1; i < MAXN; i++) fact[i] = fact[i - 1] * i % MOD;\n    invFact[MAXN - 1] = inv(fact[MAXN - 1]);\n    for (int i = MAXN - 2; ~i; i--) invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n}\n\nlong long combi(int n, int m) {\n    if (n < 0 || n < m) return 0;\n    return fact[n] * invFact[m] % MOD * invFact[n - m] % MOD;\n}\n\nlong long calc(int n, int l, int s) {\n    if (!n) return !s;\n\n    long long res = 0;\n    for (int i = 0; i <= n; i++) {\n        long long temp = combi(n, i) * combi(s + n - 1 - i * l, n - 1) % MOD;\n        i % 2 ? res -= temp : res += temp;\n        res < 0 ? res += MOD : 0;\n        res >= MOD ? res -= MOD : 0;\n    }\n    return res;\n}\n\nint main() {\n    init();\n\n    int p, s, r;\n    scanf(\"%d %d %d\", &p, &s, &r);\n\n    long long ans = 0;\n    for (int i = r; i <= s; i++) for (int j = 1; j <= p && j * i <= s; j++) {\n        long long temp = combi(p - 1, j - 1) * calc(p - j, i, s - j * i) % MOD * inv(j) % MOD;\n        ans += temp;\n        ans >= MOD ? ans -= MOD : 0;\n    }\n\n    ans = ans * inv(calc(p, s + 1, s - r)) % MOD;\n    printf(\"%lld\\n\", ans);\n    \n    return 0;\n}\n```","tags":["计数","容斥原理","概率与期望"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Educational Round 56] F Vasya and Array","url":"/Codeforces-Educational-Round-56-F-Vasya-and-Array/","content":"\n## 题目大意\n\n定义一个数列是好的，当且仅当它的任何长为 $len$ 的连续子序列包含至少两种数字。现给出一个长为 $n$ 的数列，每个位置是 $1 \\sim k$ 中的数或 $-1$，要求替换所有的 $-1$ 为 $1 \\sim k$ 中的数，使得该数列为好数列，求替换的方案数。\n\n$1 \\leq len \\leq n \\leq 100,000$\n\n$1 \\leq k \\leq 100$\n\n## 题目链接\n\n[Codeforces Educational Round 56 - F](https://codeforces.com/contest/1093/problem/F)\n\n<!--more-->\n\n## 题解\n\n考虑 DP，$f(i, j)$ 表示已经考虑了前 $i$ 个数，最后一个是 $j$ 的答案，则在不考虑要求的情况下，有：\n$$\nf(i, j) = \\sum_{j' = 1}^{k} f(i - 1, j')\n$$\n然后考虑减去不合法的情况，由于更早的不合法情况已经考虑过了，只需考虑 $[i - len + 1, i]$ 这个区间（如果 $i - len + 1 > 0$），它们只有都是 $j$ 的情况下才不合法，这需要原数列中该区间内只有 $j$ 和 $-1$，此时减去不合法的情况数，也就是前 $i - len$ 个数的答案，此时如果第 $i - len$ 个数也为 $j$，那么它在计算 $f(i - 1, j)$ 时就被考虑了，故减去 $\\sum_{j' = 1}^{k} f(i - len, j') - f(i - len, j)$ 。\n\n## 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 100005;\nconst int MAXK = 105;\nconst int MOD = 998244353;\n\nint f[MAXN][MAXK], a[MAXN], cnt[MAXK][MAXN];\n\nint main() {\n    int n, k, len;\n    scanf(\"%d %d %d\", &n, &k, &len);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\n    for (int i = 1; i <= k; i++) for (int j = 1; j <= n; j++)\n        cnt[i][j] = cnt[i][j - 1] + (a[j] == -1 || a[j] == i);\n\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= k; j++) if (a[i] == -1 || a[i] == j) {\n            f[i][j] = f[i - 1][0];\n\n            if (i >= len && cnt[j][i] - cnt[j][i - len] == len) {\n                f[i][j] -= f[i - len][0];\n                f[i][j] < 0 ? f[i][j] += MOD : 0;\n                f[i][j] += f[i - len][j];\n                f[i][j] >= MOD ? f[i][j] -= MOD : 0;\n            }\n\n            f[i][0] += f[i][j];\n            f[i][0] >= MOD ? f[i][0] -= MOD : 0;\n        }\n    }\n\n    int ans = a[n] == -1 ? f[n][0] : f[n][a[n]];\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}\n```","tags":["DP"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Educational Round 56] E Intersection of Permutations","url":"/Codeforces-Educational-Round-56-E-Intersection-of-Permutations/","content":"\n## 题目大意\n\n两个长为 $n$ 的 $1 \\sim n$ 的排列 $\\{a_i\\}$、$\\{b_i\\}$。有 $m$ 次操作，每次操作询问在 $\\{a_i\\}$ 的 $[l_a, r_a]$ 区间内和 $\\{b_i\\}$ 的 $[l_b, r_b]$ 区间内有多少个相同的数，或交换 $\\{b_i\\}$ 中的两个数。\n\n$1 \\leq n, m \\leq 200,000$\n\n## 题目链接\n\n[Codeforces Educational Round 56 - E](https://codeforces.com/contest/1093/problem/E)\n\n<!--more-->\n\n## 题解\n\n从两个排列中，我们可以得到一个数组 $\\{pos_i\\}$ （代码中为 `b[]`）表示 $\\{b_i\\}$ 中第 $i$ 个数在 $\\{a_i\\}$ 中的位置，则可以视该数组为一组平面上的点，每次询问转换为 $i \\in [l_a, r_a], pos_i \\in [l_b, r_b]$ 这一矩阵内点的个数。解决这个问题，我们可以使用二维树状数组，但直接写会 MLE，而使用 `std::map` 会 TLE。考虑离散化，我们第一遍先得到参与运算的坐标，之后就可以离散了。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 200005;\n\nint a[MAXN], b[MAXN], temp[MAXN], n;\n\nconstexpr int lowbit(int x) {\n    return x & -x;\n}\n\nstruct BIT_PRE {\n    std::vector<int> a[MAXN];\n\n    void update(int x, int y) {\n        for (int i = x; i <= n; i += lowbit(i)) a[i].push_back(y);\n    }\n\n    void query(int x, int y) {\n        for (int i = x; i; i -= lowbit(i)) a[i].push_back(y);\n    }\n\n    void query(int x0, int y0, int x1, int y1) {\n        query(x1, y1);\n        query(x0 - 1, y0 - 1);\n        query(x1, y0 - 1);\n        query(x0 - 1, y1);\n    }\n\n    void calc() {\n        for (int i = 1; i <= n; i++) {\n            std::sort(a[i].begin(), a[i].end());\n            a[i].resize(std::unique(a[i].begin(), a[i].end()) - a[i].begin());\n        }\n    }\n};\n\nint getIndex(const std::vector<int> &vec, int a) {\n    return std::lower_bound(vec.begin(), vec.end(), a) - vec.begin() + 1;\n}\n\nstruct BIT {\n    std::vector<int> a[MAXN];\n    BIT_PRE pre;\n\n    void init() {\n        pre.calc();\n        for (int i = 1; i <= n; i++) a[i].resize(pre.a[i].size() + 1, 0);\n    }\n\n    void update(int x, int y, int d) {\n        for (int i = x; i <= n; i += lowbit(i))\n            for (int j = getIndex(pre.a[i], y); j < (int) a[i].size(); j += lowbit(j)) a[i][j] += d;\n    }\n\n    int query(int x, int y) {\n        int res = 0;\n        for (int i = x; i; i -= lowbit(i))\n            for (int j = getIndex(pre.a[i], y); j; j -= lowbit(j)) res += a[i][j];\n        return res;\n    }\n\n    int query(int x0, int y0, int x1, int y1) {\n        return query(x1, y1) + query(x0 - 1, y0 - 1) - query(x1, y0 - 1) - query(x0 - 1, y1);\n    }\n} bit;\n\nstruct Operation {\n    int op, a, b, c, d;\n\n    Operation() {}\n    Operation(int op, int a, int b, int c, int d) : op(op), a(a), b(b), c(c), d(d) {}\n    Operation(int op, int a, int b) : op(op), a(a), b(b) {}\n} O[MAXN];\n\nint main() {\n    int m;\n    scanf(\"%d %d\", &n, &m);\n\n    for (int i = 1, x; i <= n; i++) {\n        scanf(\"%d\", &x);\n        a[x] = i;\n    }\n\n    for (int i = 1, x; i <= n; i++) {\n        scanf(\"%d\", &x);\n        b[i] = a[x];\n        bit.pre.update(i, b[i]);\n    }\n\n    std::copy(b + 1, b + n + 1, temp);\n    for (int i = 0; i < m; i++) {\n        int op;\n        scanf(\"%d\", &op);\n\n        if (op == 1) {\n            int la, ra, lb, rb;\n            scanf(\"%d %d %d %d\", &la, &ra, &lb, &rb);\n\n            bit.pre.query(lb, la, rb, ra);\n\n            O[i] = Operation(op, lb, la, rb, ra);\n        } else {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n\n            bit.pre.update(x, b[x]);\n            bit.pre.update(y, b[y]);\n            std::swap(b[x], b[y]);\n            bit.pre.update(x, b[x]);\n            bit.pre.update(y, b[y]);\n\n            O[i] = Operation(op, x, y);\n        }\n    }\n\n    std::copy(temp, temp + n, b + 1);\n    bit.init();\n\n    for (int i = 1; i <= n; i++) bit.update(i, b[i], 1);\n    for (int i = 0; i < m; i++) {\n        int op = O[i].op;\n\n        if (op == 1) {\n            int lb = O[i].a, la = O[i].b, rb = O[i].c, ra = O[i].d;\n            int ans = bit.query(lb, la, rb, ra);\n            printf(\"%d\\n\", ans);\n        } else {\n            int x = O[i].a, y = O[i].b;\n            bit.update(x, b[x], -1);\n            bit.update(y, b[y], -1);\n            std::swap(b[x], b[y]);\n            bit.update(x, b[x], 1);\n            bit.update(y, b[y], 1);\n        }\n    }\n    \n    return 0;\n}\n```","tags":["树状数组","二维树状数组"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces Educational Round 56] G Multidimensional Queries","url":"/Codeforces-Educational-Round-56-G-Multidimensional-Queries/","content":"\n## 题目大意\n\n$\\{a_i\\}$ 是 $k$ 维空间内的 $n$ 个点，有 $q$ 次操作，每次操作为修改一个点的坐标，或查询下标区间在 $[l, r]$ 内的点的最大两点间曼哈顿距离。\n\n$1 \\leq n, q \\leq 200,000$\n\n$1 \\leq k \\leq 5$\n\n$-10^6 \\leq a_{i, j} \\leq 10^6$\n\n## 题目链接\n\n[Codeforces Educational Round 56 - G](https://codeforces.com/contest/1093/problem/G)\n\n<!--more-->\n\n## 题解\n\n$j$、$k$ 两点间的曼哈顿距离可表示为：\n$$\n\\sum_{i = 1}^{k} c_i a_{j, i} - \\sum_{i = 1}^{k} c_i a_{k, i}\n$$\n其中 $c_i$ 为一个 $\\{1, -1\\}$ 的系数，且可以直接证明，对任何 $c_i$，曼哈顿距离为其中最大的一个。由于 $k$ 只有 $5$，可以考虑每举所有 $2^k$ 种 $c_i$，询问即区间内求 $\\sum_{i = 1}^{k} c_i a_{j, i}$ 的最值，修改即单点修改，用 $2^k$ 棵线段树可以做到 $O((n + q) 2^k \\log n)$。由于每次操作的点或区间对所有线段树均相同，故可用一棵线段树维护，<del>复杂度降为 O((n + q)2^k + q \\log n)​ </del>，复杂度不会改变，但常数会变小很多，因为这样对内存访问更加友好；同时，由于 $c_i = c$ 时的最大值就是 $c_i = 2^k - 1 - c$ 时的最小值，故只用维护一种最值。\n\n吐槽：virtual 的时候感觉大家都会 G，而自己却一直在想什么可持久化 5-d Tree。。。QAQ\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 200005;\nconst int MAXK = 5;\n\nint K;\n\nstruct Point {\n    int x[MAXK];\n} P[MAXN], b;\n\nint calc(const Point &p, int c) {\n    int res = 0;\n    for (int i = 0; i < K; i++) (c & (1 << i)) ? res += p.x[i] : res -= p.x[i];\n    return res;\n}\n\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int l, r, max[1 << MAXK];\n\n        Node() {}\n        Node(int pos) : l(pos), r(pos), lc(NULL), rc(NULL) {}\n        Node(Node *lc, Node *rc) : l(lc->l), r(rc->r), lc(lc), rc(rc) {\n            maintain();\n        }\n\n        void maintain() {\n            for (int c = 0; c < 1 << K; c++) max[c] = std::max(lc->max[c], rc->max[c]);\n        }\n\n        void update(int pos, const Point &d) {\n            if (l == r) {\n                for (int c = 0; c < 1 << K; c++) max[c] = calc(d, c);\n                return;\n            }\n\n            int mid = l + ((r - l) >> 1);\n            if (pos <= mid) lc->update(pos, d);\n            else rc->update(pos, d);\n            maintain();\n        }\n\n        void query(int l, int r, int *ret) {\n            if (r < this->l || this->r < l) return;\n            if (l <= this->l && this->r <= r) {\n                for (int c = 0; c < 1 << K; c++)\n                    ret[c] = std::max(ret[c], max[c]);\n                return;\n            }\n            lc->query(l, r, ret);\n            rc->query(l, r, ret);\n        }\n    } *root, _pool[MAXN << 1], *_curr;\n\n    SegT() : root(NULL), _curr(_pool) {}\n\n    Node *build(int l, int r, Point *a) {\n        if (l == r) {\n            Node *u = new (_curr++) Node(l);\n            for (int c = 0; c < 1 << K; c++) u->max[c] = calc(a[l], c);\n            return u;\n        }\n        int mid = l + ((r - l) >> 1);\n        return new (_curr++) Node(build(l, mid, a), build(mid + 1, r, a));\n    }\n    void build(Point *a, int n) {\n        root = build(1, n, a);\n    }\n\n    void update(int pos, const Point &d) {\n        root->update(pos, d);\n    }\n\n    void query(int l, int r, int *ret) {\n        return root->query(l, r, ret);\n    }\n} segT;\n\nint main() {\n    int n;\n    scanf(\"%d %d\", &n, &K);\n\n    for (int i = 1; i <= n; i++) for (int j = 0; j < K; j++) scanf(\"%d\", &P[i].x[j]);\n    segT.build(P, n);\n\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int op;\n        scanf(\"%d\", &op);\n\n        if (op == 1) {\n            int pos;\n            scanf(\"%d\", &pos);\n            for (int i = 0; i < K; i++) scanf(\"%d\", &b.x[i]);\n            segT.update(pos, b);\n        } else {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n\n            static int ret[1 << MAXK];\n            std::fill(ret, ret + (1 << K), INT_MIN);\n            segT.query(l, r, ret);\n            int ans = 0;\n            for (int c = 0; c < 1 << (K - 1); c++)\n                ans = std::max(ans, std::abs(ret[c] + ret[(1 << K) - 1 - c]));\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return 0;\n}\n```","tags":["线段树"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2007] 货币兑换","url":"/NOI-2007-货币兑换/","content":"\n## 题目大意\n\n有 A、B 两种券，券的数目可以是一个实数。第 $K$ 日时，两种券的单价分别为 $A_K$、$B_K$（实数），交易比例为 $rate_K$。每日，你可以选择买入一定量的券，且 A 券数目与 B 券数目之比必须为 $rate_K$；或卖出已有券的 $OP\\%$，即所持 A 券的 $OP\\%$ 和所持 B 券的 $OP\\%$ 。同一日内可进行多次操作，也可以不操作。已知 $n$ 日内的单价与交易比例，初始时有 $S$ 的钱，但没有任何券，求 $n$ 日后的最大收益。\n\n提示：必然存在一种最优的买卖方案满足：每次买进操作使用完所有的人民币；每次卖出操作卖出所有的金券。\n\n$1 \\leq n \\leq 10^6$\n\n$0 < A_K, B_K \\leq 10$\n\n$0 < rate_K \\leq 100$\n\n## 题目链接\n\n[【NOI 2007】货币兑换 - LibreOJ 2353](https://loj.ac/problem/2353)（有 spj）\n\n<!--more-->\n\n## 题解\n\n由提示可写出以下 DP 方程：\n$$\nf(i) = \\max_\\limits{1 \\leq j < i}(A_i \\times x(j) + B_i \\times y(j))\n$$\n表示在第 $i$ 日卖出全部券的最大收益，$x(i)$、$y(i)$ 表示第 $i$ 日用最大收益买到的两种券的数目，他们满足：\n$$\n\\begin{align}\nf(i) &= A_i \\times x(i) + B_i \\times y(i) \\\\\n\\frac{x(i)}{y(i)} &= rate_i\n\\end{align}\n$$\n则答案为 $\\max_\\limits{1 \\leq i \\leq n}f(i)$ 。\n\n$f(i) = A_i \\times x(j) + B_i \\times y(i)$ 可写作 $y(i) = -\\frac{A_i}{B_i} x(j)+ \\frac{f(i)}{B_i}$，对于确定的 $i$，以 $x(j)$ 为横坐标、$y(j)$ 为纵坐标，可视作一族平行的直线，转移即要求截距最大，于是可能的决策点必在一上凸壳上。\n\n由于 $x(i)$ 和 $y(i)$ 不具单调性，只能动态维护上凸壳，用 Splay 维护之即可。\n\n本题亦可用 CDQ 分治解决：\n\n考虑可用单调队列做到 $O(n)$ 的斜率优化 DP 的题，它们满足：\n\n* 插入线性：横坐标单调不减\n* 查询线性：目标斜率单调不减\n* 默认：下标顺序\n\n于是可以考虑用 CDQ 分治解决这三个约束，大致思路是：\n\n用左侧更新右侧答案，然后归并。左侧需要维护凸壳，要满足插入线性；左侧的下标应小于右侧的下标；右侧更新答案，要满足查询线性。于是可以考虑先整体满足查询线性，然后按下标分为两侧，先计算左侧，然后左侧更新右侧，之后计算右侧，最后归并为插入线性。\n\n相比之下，Splay 的代码虽然更长，但内存更少、常数更小，而且思维上简单粗暴。\n\n## 代码\n\n### Splay 维护动态凸壳\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000005;\nconst double EPS = 1e-9;\n\nint dcmp(double a, double b = 0) {\n    double d = a - b;\n    return std::abs(d) <= EPS ? 0 : (d > 0 ? 1 : -1);\n}\n\nstruct Splay {\n    struct Node {\n        Node *c[2], *fa, *pred, *succ;\n        double x, y;\n\n        Node() {}\n        Node(Node *fa, double x, double y) : x(x), y(y), c(), fa(fa), pred(NULL), succ(NULL) {}\n\n        int relation() {\n            return fa->c[1] == this;\n        }\n    } *root, _pool[MAXN], *_curr;\n\n    Splay() : root(NULL) {}\n\n    void init() {\n        _curr = _pool;\n    }\n\n    void rotate(Node *u) {\n        Node *o = u->fa;\n        int x = u->relation();\n\n        u->fa = o->fa;\n        if (u->fa) u->fa->c[o->relation()] = u;\n\n        o->c[x] = u->c[x ^ 1];\n        if (u->c[x ^ 1]) u->c[x ^ 1]->fa = o;\n\n        u->c[x ^ 1] = o;\n        o->fa = u;\n    }\n\n    Node *splay(Node *u, Node *targetFa = NULL) {\n        while (u->fa != targetFa) {\n            if (u->fa->fa == targetFa) rotate(u);\n            else if (u->relation() == u->fa->relation()) rotate(u->fa), rotate(u);\n            else rotate(u), rotate(u);\n        }\n        if (!targetFa) root = u;\n        return u;\n    }\n\n    double predSlope(Node *u) {\n        return u->pred ? (u->y - u->pred->y) / (u->x - u->pred->x) : 1.0 / 0.0;\n    }\n\n    double succSlope(Node *u) {\n        return u->succ ? (u->y - u->succ->y) / (u->x - u->succ->x) : -1.0 / 0.0;\n    }\n\n    Node *insert(double x, double y) {\n        if (!root) {\n            root = new (_curr++) Node(NULL, x, y);\n            return root;\n        }\n\n        Node **u = &root, *fa = NULL;\n\n        while (*u && dcmp(x, (*u)->x)) {\n            fa = *u;\n            u = &(*u)->c[dcmp(x, (*u)->x) > 0];\n        }\n\n        if (*u) {\n            if (dcmp((*u)->y, y) >= 0) return splay(*u);\n            (*u)->y = y;\n        } else {\n            (*u) = new (_curr++) Node(fa, x, y);\n\n            if ((*u)->relation()) {\n                (*u)->succ = fa->succ;\n                (*u)->pred = fa;\n                if (fa->succ) fa->succ->pred = *u;\n                fa->succ = *u;\n            } else {\n                (*u)->pred = fa->pred;\n                (*u)->succ = fa;\n                if (fa->pred) fa->pred->succ = *u;\n                fa->pred = *u;\n            }\n        }\n\n        Node *v = *u;\n        if (dcmp(predSlope(v), succSlope(v)) <= 0) {\n            splay(v->pred);\n            splay(v->succ, v->pred);\n            v->pred->succ = v->succ;\n            v->succ->pred = v->pred;\n            v->succ->c[0] = NULL;\n            return NULL;\n        }\n\n        while (v->pred && dcmp(predSlope(v->pred), predSlope(v)) <= 0)\n            v->pred = v->pred->pred;\n        if (v->pred) {\n            splay(v->pred);\n            splay(v, v->pred);\n            v->pred->succ = v;\n        }\n        v->c[0] = NULL;\n\n        while (v->succ && dcmp(succSlope(v->succ), succSlope(v)) >= 0)\n            v->succ = v->succ->succ;\n        if (v->succ) {\n            splay(v->succ);\n            splay(v, v->succ);\n            v->succ->pred = v;\n        }\n        v->c[1] = NULL;\n\n        return splay(v);\n    }\n\n    Node *find(double slope) {\n        Node *u = root;\n        while (true) {\n            if (dcmp(predSlope(u), slope) < 0) u = u->c[0];\n            else if (dcmp(succSlope(u), slope) > 0) u = u->c[1];\n            else return u;\n        }\n    }\n} splay;\n\nint main() {\n    int n, S;\n    scanf(\"%d %d\", &n, &S);\n\n    double ans = S;\n    splay.init();\n    for (int i = 0; i < n; i++) {\n        double a, b, rate;\n        scanf(\"%lf %lf %lf\", &a, &b, &rate);\n\n        double slope = -a / b;\n        if (i) {\n            Splay::Node *u = splay.find(slope);\n            ans = std::max(ans, a * u->x + b * u->y);\n        }\n\n        double y = ans / (a * rate + b);\n        double x = y * rate;\n\n        splay.insert(x, y);\n    }\n    printf(\"%.6f\\n\", ans);\n    \n    return 0;\n}\n```\n\n### CDQ 分治\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 1000005;\nconst double EPS = 1e-9;\n\nint dcmp(double a, double b = 0) {\n    double d = a - b;\n    return std::abs(d) <= EPS ? 0 : (d > 0 ? 1 : -1);\n}\n\nstruct Data {\n    double a, b, rate, x, y, slope, f;\n    int id;\n\n    bool operator<(const Data &rhs) const {\n        return dcmp(slope, rhs.slope) > 0;\n    }\n} a[MAXN];\n\ndouble slope(const Data &a, const Data &b) {\n    return (a.y - b.y) / (a.x - b.x);\n}\n\nvoid divide(Data *l, Data *r, double &ans) {\n    if (l + 1 == r) {\n        ans = std::max(ans, l->f);\n        l->y = ans / (l->a * l->rate + l->b);\n        l->x = l->y * l->rate;\n        return;\n    }\n\n    static Data q[MAXN];\n    Data *mid = l + ((r - l) >> 1), *tl = q, *tr = q + (mid - l);\n    for (Data *p = l; p < r; p++) {\n        if (p->id < mid - a) *tl++ = *p;\n        else *tr++ = *p;\n    }\n    std::copy(q, tr, l);\n\n    divide(l, mid, ans);\n\n    Data *L = q + 1, *R = q;\n    for (Data *p = l; p < mid; p++) {\n        while (L < R && dcmp(slope(*(R - 1), *R), slope(*R, *p)) <= 0) --R;\n        *++R = *p;\n    }\n    for (Data *p = mid; p < r; p++) {\n        while (L < R && dcmp(slope(*L, *(L + 1)), p->slope) >= 0) ++L;\n        p->f = std::max(p->f, p->a * L->x + p->b * L->y);\n    }\n\n    divide(mid, r, ans);\n\n    tl = l, tr = mid;\n    for (Data *p = q; p < q + (r - l); p++) {\n        if (tr >= r || (tl < mid && dcmp(tl->x, tr->x) <= 0)) *p = *tl++;\n        else *p = *tr++;\n    }\n    std::copy(q, q + (r - l), l);\n}\n\nint main() {\n    int n, S;\n    scanf(\"%d %d\", &n, &S);\n\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf %lf\", &a[i].a, &a[i].b, &a[i].rate);\n        a[i].slope = -a[i].a / a[i].b;\n        a[i].id = i;\n    }\n\n    std::sort(a, a + n);\n    double ans = S;\n    divide(a, a + n, ans);\n\n    printf(\"%.6f\\n\", ans);\n    \n    return 0;\n}\n```","tags":["DP","斜率优化DP","Splay","动态凸壳"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2012] 任务安排","url":"/SDOI-2012-任务安排/","content":"\n## 题目大意\n\n机器上有 $N$ 个需要处理的任务，它们构成了一个序列，标号为 $1$ 到 $N$。这 $N$ 个任务被分成若干批，每批包含相邻的若干任务。从时刻 $0$ 开始，这些任务被分批加工，第 $i$ 个任务单独完成所需的时间是 $T_i$。在每批任务开始前，机器需要启动时间 $S$，而完成这批任务所需的时间是各个任务需要时间的总和，同一批任务将在同一时刻完成。每个任务的费用是它的完成时刻乘以一个费用系数 $F_i$。最小化总费用。\n\n$1 \\leq N \\leq 300,000$\n\n$0 \\leq S, F_i \\leq 512$\n\n$-512 \\leq T_i \\leq 512$\n\n## 题目链接\n\n[【SDOI 2012】任务安排 - Luogu 5785](https://www.luogu.com.cn/problem/P5785)\n\n<!--more-->\n\n## 题解\n\n可写出 DP 方程：\n$$\n\\begin{align}\nf(i) &= \\min_\\limits{0 \\leq j < i}(f(j) + (sumC(i) - sumC(j)) \\times sumT(i) + (sumC(n) - sumC(j)) \\times S) \\\\\n&= sumC(i) \\times sumT(i) + S \\times sumC(n) + \\min_\\limits{0 \\leq j < i}(f(j) - sumC(j) \\times (sumT(i) + S))\n\\end{align}\n$$\n对于决策点 $a, b$ $(a < b)$，假设 $a$ 更优，有：\n$$\n\\begin{align}\nf(a) - sumC(a) \\times (sumT(i) + S) &< f(b) - sumC(b) \\times (sumT(i) + S) \\\\\n\\frac{(f(a) - S \\times sumC(a)) - (f(b) - S \\times sumC(b))}{sumC(a) - sumC(b)} &< sumT(i)\n\\end{align}\n$$\n以 $sumC(j)$ 为横坐标、$f(j) - S \\times sumC(j)$ 为纵坐标，可见答案在一个下凸壳上，目标斜率是 $sumT(i)$。\n\n横坐标递增，可以用单调队列维护上凸壳；目标斜率不单调，需要用二分查找决策点。\n\n## 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 300005;\n\nlong long sumT[MAXN], sumC[MAXN], f[MAXN], S;\n\nlong long y(int x) {\n    return f[x] - S * sumC[x];\n}\n\nint bisearch(long long k, int *l, int *r) {\n    while (l < r) {\n        int *mid = l + ((r - l) >> 1);\n        if ((y(*(mid + 1)) - y(*mid)) <= k * (sumC[*(mid + 1)] - sumC[*mid])) l = mid + 1;\n        else r = mid;\n    }\n    return *l;\n}\n\nvoid dp(int n) {\n    static int q[MAXN];\n    int *l = q, *r = q;\n\n    for (int i = 1; i <= n; i++) {\n        int j = bisearch(sumT[i], l, r);\n        f[i] = f[j] + sumT[i] * (sumC[i] - sumC[j]) + S * (sumC[n] - sumC[j]);\n        while (l < r && (long double) (y(*r) - y(*(r - 1))) * (sumC[i] - sumC[*r])\n                     >= (long double) (y(i) - y(*r)) * (sumC[*r] - sumC[*(r - 1)])) --r;\n        *++r = i;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d %lld\", &n, &S);\n    for (int i = 1; i <= n; i++) scanf(\"%lld %lld\", &sumT[i], &sumC[i]);\n    for (int i = 2; i <= n; i++) {\n        sumT[i] += sumT[i - 1];\n        sumC[i] += sumC[i - 1];\n    }\n\n    dp(n);\n    printf(\"%lld\\n\", f[n]);\n    \n    return 0;\n}\n```","tags":["DP","单调队列","斜率优化DP","二分"],"categories":["题解（OI/XCPC）"]},{"title":"[ByteDance WC 2019 Online] Continued Story","url":"/ByteDance-WC-2019-Online-Continued-Story/","content":"\n> 2019 字节跳动冬令营网络赛 C 题。\n\n## 题目大意\n\n给定一棵 $n$ 个节点的带权有根树，两人轮流操作，每次操作使某条边的边权减一，若边权减至 $0$，则删去改边，并删去不含根的连通块，判断先手是否必胜，并输出先手若要胜利，所有第一步可能的决策。\n\n$T$ 组数据。\n\n$1 \\leq n \\leq 10^6$\n\n$1 \\leq w_i \\leq 10^9$\n\n$\\sum n \\leq 10^6$\n\n## 题目链接\n\n[ByteDance WC 2019 Online - C](https://ac.nowcoder.com/acm/contest/296/C)\n\n<!-- more -->\n\n## 题解\n\n现学的 [Hackenbush 博弈](http://pepcy.cf/Hackenbush-博弈学习笔记/)。\n\n计算 SG 函数：\n\n$$\n\\begin{align}\nSG(u) &= f(v_1) \\oplus f(v_2) \\oplus \\cdots \\oplus f(v_m) \\\\\nf(v) &= \\begin{cases}\nSG(v) + 1 ~ &, w_{E(u, v)} = 1 \\\\\nSG(v) ~ &, w_{E(u, v)} \\text{ is even} \\\\\nSG(v) \\oplus 1 ~ &, w_{E(u, v)} > 1 \\text{ and } w_{E(u, v)} \\text{ is odd} \n\\end{cases}\n\\end{align}\n$$\n\n如何输出方案：\n\n我们从根节点开始 dfs，同时传递一个变量 $need$（代码中为 `val`）表示需要用该子树进行一次操作凑出的 SG 函数值，初始为 $0$。对于每一个点，枚举与它儿子相连的每一条边，可以分情况计算出该儿子对应子树的 $need$ 的值（$other$ 为其余部分的 SG 值，$u, v$ 分别表示父节点、子节点）：\n\n* 边权为 $1$：$(need_v + 1) \\oplus other = need_u$\n* 边权大于 $1$ 且为奇数：$need_v \\oplus 1 \\oplus other = need_u$\n* 边权为偶数：$need_v \\oplus other = need_u$\n\n同时，可以考虑若操作该边是否能得到该点的 $need$ 值：\n\n* 边权为 $1$：$other = need_u$ 则可以\n* 边权为 $2$：$(SG(v) + 1) \\oplus other = need_u$ 则可以\n* 边权大于 $2$：$SG(v) \\oplus 1 = need_u$ 则可以\n\n## 代码\n\n吐槽1：比赛时没有给异或运算加括号，于是输给了运算符优先级。。。QAQ\n\n吐槽2：代码中的 `MAXN = 1000105` 原本是 `MAXN = 1000005`，但发生了迷之「内部错误」。\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n \nconst int MAXN = 1000105;\n \nstruct Edge;\n \nstruct Node {\n    Edge *e;\n    int sg;\n} N[MAXN];\n \nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n \n    Edge() {}\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n} _pool[MAXN], *_curr;\n \nvoid addEdge(int f, int s, int w) {\n    N[f].e = new (_curr++) Edge(&N[f], &N[s], w);\n}\n \nvoid dfs(Node *u) {\n    u->sg = 0;\n    for (Edge *e = u->e; e; e = e->next) {\n        dfs(e->v);\n \n        if (e->w == 1) u->sg ^= (e->v->sg + 1);\n        else if (e->w % 2 == 0) u->sg ^= e->v->sg;\n        else u->sg ^= (e->v->sg ^ 1);\n    }\n}\n \nstd::vector<int> ans;\nvoid dfs(Node *u, int val) {\n    if (val < 0) return;\n    for (Edge *e = u->e; e; e = e->next) {\n        int other;\n        if (e->w == 1) other = u->sg ^ (e->v->sg + 1);\n        else if (e->w % 2 == 0) other = u->sg ^ e->v->sg;\n        else other = u->sg ^ e->v->sg ^ 1;\n \n        if (other == val && e->w == 1) ans.push_back(e->v - N);\n        else if (((e->v->sg + 1) ^ other) == val && e->w == 2) ans.push_back(e->v - N);\n        else if (val == (u->sg ^ 1) && e->w > 2) ans.push_back(e->v - N);\n        \n        if (e->w == 1) dfs(e->v, (val ^ other) - 1);\n        else if (e->w % 2 == 0) dfs(e->v, val ^ other);\n        else dfs(e->v, val ^ other ^ 1);\n    }\n}\n \nvoid init(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) N[i].e = NULL;\n}\n \nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        init(n);\n \n        for (int i = 2, f, w; i <= n; i++) {\n            scanf(\"%d %d\", &f, &w);\n            addEdge(f, i, w);\n        }\n \n        dfs(&N[1]);\n        ans.clear();\n        dfs(&N[1], 0);\n        \n        std::sort(ans.begin(), ans.end());\n        printf(\"%d\\n\", ans.size());\n        for (int i : ans) printf(\"%d \", i);\n        puts(\"\");\n    }\n     \n    return 0;\n}\n```","tags":["博弈","Hackenbush"],"categories":["题解（OI/XCPC）"]},{"title":"Hackenbush 博弈学习笔记","url":"/Hackenbush-博弈学习笔记/","content":"\n两人在一张有根图上依次操作，每次操作为删去一条边，若有连通块内不含根节点，则删去整个连通块。先不能操作者输，判断先手是否必胜。\n\n<!-- more -->\n\n## 链的版本 - Bamboo Stalks\n\n两人操作 $n$ 条长度为 $l_i$ 的链，链的一端连在一条线上（图中虚线，不可操作），这一端作为链的根，具体操作同上，判断先手是否必胜。\n\n![Figure - Bamboo Stalks](https://i.loli.net/2018/12/01/5c026a735d14d.jpg)\n\n其实 Bamboo Stalks 游戏可以转化为普通的取石子 Nim 游戏：删去某条边等于在这一堆石子中取走被删掉的点数个石子。所以 Bamboo Stalks 游戏可以像取石子游戏一般定义 SG 函数。\n\n## 树的版本 - Hackenbush-Trees\n\n即在 Bamboo Stalks 的基础上将链改为树，判断先手是否必胜。\n\n![Figure - Hackenbush-Trees](https://i.loli.net/2018/12/01/5c026a74191d1.jpg)\n\n可以用一条链来代替一个顶点的儿子们，其长度等于它们的异或和，如图：\n\n![Figure - Hackenbush-Trees-alter](https://i.loli.net/2018/12/01/5c02745dec0b3.jpg)\n\n于是可按这个规律定义一棵子树的 SG 函数：\n\n$$\nSG(u) = (SG(v_1) + 1) \\oplus (SG(v_2) + 1) \\oplus \\cdots \\oplus (SG(v_m) + 1)\n$$\n\n其中 $v_1, v_2, \\dots, v_m$ 为 $u$ 的所有儿子，单节点的 SG 函数值为 $0$。\n\n## 原题 - Hackenbush-Graphs\n\n![Figure - Hackenbush-Graphs](https://i.loli.net/2018/12/01/5c026a73b9cc6.jpg)\n\n在 Hackenbush-Graphs 中，任何环内的节点可以融合成一点而不会改变图的 SG 值；同时，一个自环可以等价于一条伸出来的长为 $1$ 的链。如图：\n\n![Figure - Hackenbush-Graphs-alter-1](https://i.loli.net/2018/12/01/5c02763ba2dec.jpg)\n\n![Figure - Hackenbush-Graphs-alter-2](https://i.loli.net/2018/12/01/5c026a73c90ca.jpg)\n\n即偶数长的环可缩为一点，奇数长的环可缩为一点加一个长为 $1$ 的链。然后就可以按照 Hackenbush-Trees 做了。\n\n## 扩展\n\n在 Hackenbush-Graphs 的基础上，为每一条边加一个边权，每次操作只能使边权减一，边在权值减为 $0$ 时被删去，判断先手是否必胜。\n\n把每一条边分成权值条重边即转化为 Hackenbush-Graphs。","tags":["学习笔记","博弈","Hackenbush"],"categories":["学习笔记（OI/XCPC）"]},{"title":"2018 ICPC 南京站游记","url":"/2018-ICPC-南京站游记/","content":"\n* 队伍： Nameless_Sunstar\n* 队员：郑鸿鹄（zhhhplus）、林思仪（LIN452）、陈昱文（Pepcy_Ch）\n* 题数：6/13（A，D，G，I，J，M）\n* 罚时：771\n* 排名：32/310（31 个金牌。。。QAQ。。。）\n\n<!-- more -->\n\n## Day -2\n\n在 218 训了一场 2017 CCPC 哈尔滨，兴奋地发现吕老板在现场，同时兴奋地发现最后过题数与 Legilimens 相同，感到状态还行，是双倍的快乐呢。\n\n## Day -1\n\n训了 Dreamoon 的台大 WF 选拔赛，4 题自闭。\n\n## Day 0\n\n尴尬地睡过了头，晚了几分钟集合，之后一起去东站汇合，在 KFC 吃了早饭，之后坐上高铁就开始睡觉了，期间听到 YaSHa 没有带板子，心疼。\n\n大家准备从南京南坐地铁，发现要购票后 cjb 评价为「石器时代」，感到自己已经被杭州惯坏了，同时意外地发现车票居然不是卡片状的（孤陋寡闻了）。\n\n很快就到了南航，走了一段后到了体育馆，cjb 报完道后照了合照，之后就在体育馆看台上坐到了午饭时间，期间看到了自己队伍的牌子。\n\n吃午饭时表示南航的食堂好好啊，感觉十分厉害的样子。之后是热身赛，意外地发现 dls 就在对面，更意外的是发现没有 gedit（队里的 lsy 是 gedit 选手，我和 zhh 是 vim 选手），vim 也非常的卡，说是 Ubuntu 但看到屏幕后感到自己是不是对 Ubuntu 有什么误解。热身赛时先过了 B 和 C，A 和 D 还不会，于是用 C 题测了一下 Java 和 Python，用 B 测了一下 c++11。Reconquista 他们很早地 AK 了，站起来就看到了他们的四个气球，zhh 去问了一发 A 题，发现搞错了题意，感觉预示着什么不好的事情。D 之后知道是类欧几里得算法，发现全队都不会。\n\n吃完晚饭、回到宾馆后就睡了一会儿（一两个小时的样子），zhh 也睡了一会儿，醒后叫齐三人看了非诚勿扰。cjb 带着 YaSHa 的板子回来后开始给每个队讲一些东西，得到了**注意罚时**、看所有有人过的题等经验/要求。之后就睡晚觉了。\n\n顺便，今日被 cjb 奶了几次。\n\n## Day 1\n\n大家起来后在南航对面的 KFC 吃了早饭，YaSHa 全队一人买了一杯拿铁，感觉预示着什么不好的事情。\n\n到场后发现有了 gedit 和 emac，也不怎么卡了，于是开场后开心地写了配置，lsy 和 zhh 从两头开始看题。lsy 给 zhh 说了 A 的题意，zhh 发现是 sb 题后 WA 了一发，发现读错了题，写完配置的我从 zhh 那听了题意并给了一个结论，但少考虑了 $k$ 为 $1$ 且 $n$ 为偶数的情况，于是 **A3y26**。之后 lsy 表示 J 能写，在 lsy 写题期间，给 zhh 说了 D 的题意，得到了最小球覆盖的解法，于是准备翻红板子、把最小圆覆盖魔改一下，但直接找到了板子。lsy **J1y38** 后我去抄最小球覆盖的板子，同时让 lsy 再确认一下做法，抄完后 **WA 了一发 D**，此时 lsy 已经和 zhh 确认了 I 的做法，于是先去写了，zhh 则在序列表中找 G，期间准备去莽一发 G，并说有 $70\\%$ 的几率会 WA，于是 **G1y76**。我意识到了一些 D 的错误，于是改了一下自信一交，又 **WA 了一发 D**，立马意识到问题又 **WA 了一发 D**，于是打印在旁边对板子，发现了错，并且之前的错也都是**抄错了板子**，正准备自信一交时被 zhh 压住了。lsy **I1y89**，我改完后 **D4y90**，此时排到了第八，由于罚时过于糟糕马上又掉了下去。此时我们读了 M、B、H、K、L，而 E 在一开始有一个 naive 的做法被榜上一片红色的提交否决了，lsy 负责 M，我和 zhh 准备从 B、K 中开一道。B 一直没什么想法，K 则是两人相互构造，然后相互 hack 掉对方的做法。lsy 写了一阵 M 的 Manacher + SAM 后获得了 RE，三人尝试找到越界处但失败了，不过 lsy 找到了一个会 WA 的地方，修正后一交又是 RE。lsy 写数据生成器并发现是 dfs 爆栈了，我去改了一发手写栈的 dfs，并把两个程序拍了一会儿，无错，交上去 WA 了，于是 lsy 在本地继续对拍，改了两次后 **M6y252**。之后 lsy 问我们有没有考虑 K 的没有环的限制，发现在传达题意时漏了一个条件，准备沿着这棵树走一圈，我和 lsy 觉得正确无比但 zhh 怀疑有问题，让我在最后用随机走动填满，写完后喜获 TLE，zhh 怀疑是步数过多，我则给答案 `vector` 加了一个 `reserve()` 在前面，并各种乱搞，疯狂提交，此时评测机已经退化为 OI 赛制，在比赛结束后仍有 5 发提交在评测。\n\n赛后了解到 YaSHa 是 5 题，Reconquista 有 10 题。刚结束时我去 Reconquista 那边询问 K 的做法，感觉比较乱搞，甚至感觉自己能过，不过 5 发提交全 WA 了，算了一下是 6 题罚时 771，跟封榜时的榜对比了一下，发现需要 10 个队伍超过我们才会打银，cjb 表示 Au 稳了，甚至从 qls 那里得到了奶，wyz 也说稳了，并马上反奶**「那你凉了啊，银首rk32预定」**。lsy 在和高中同学聊天，我和 zhh 在座位上疯狂反奶，我说了句「把队名改成**『给我块金好不好』**吧」。\n\n之后等到了闭幕式，听到主持人说「让屏幕滚动起来」激动地以为会有滚榜，结果看到的是终榜（据说是技术人员没赶上，心疼），在滚动到金银分界线时，看到了位在银首的我们，与金尾罚时差了 23，瞬间感到有点失落，zhh 及其不情愿地和 YaSHa 的 hyy 去领了银牌。\n\ncjb 安慰了一下我们后大家去了夫子庙吃饭，队里一人吃了一张「金牌掉渣烧饼」，并吃到了欧阳学长安利的「回味」鸭血粉丝汤，意外地发现自己的两个浙江队友不怎么吃海鲜。\n\n## 总结\n\n正式赛中出了两个题面锅，还有我抄错的板子、没讨论细致的 A 等罚时锅，感觉每一个都可以避免但每一个感觉又无法避免，很大地暴露出了队伍里交题比较莽的问题，打银了就是有打银的原因，不过今年我们队已经没有区域赛了。\n\n希望 ZJU 的 Legilimens、Reconquista、Helianthus、EuropeSun、YaSHa、Trident-Z、ACetic_ACid、Sample_Text、Innocence 可以在之后的比赛中发挥得更好（Dogeheads 以及 Repeaters 和我们一样今年没有比赛了呢）。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"类欧几里得算法学习笔记","url":"/类欧几里得算法学习笔记/","content":"\n常见的用类欧几里得算法处理的几个函数：\n\n$$\nf(a, b, c, n) = \\sum_{i = 0}^{n} \\lfloor \\frac{ai + b}{c} \\rfloor\n$$\n$$\ng(a, b, c, n) = \\sum_{i = 0}^{n} i\\lfloor \\frac{ai + b}{c} \\rfloor\n$$\n$$\nh(a, b, c, n) = \\sum_{i = 0}^{n} \\lfloor \\frac{ai + b}{c} \\rfloor ^2\n$$\n\n并定义：\n\n$$\nm = \\lfloor \\frac{an + b}{c} \\rfloor\n$$\n\n可在 $O(\\log \\min(a, b))$ 的时间内计算以上函数。\n\n<!-- more -->\n\n## 函数 $f$ 的处理\n\n当 $a \\geq c$ 或 $b \\geq c$ 时：\n\n$$\n\\begin{align}\nf(a, b, c, n) &= \\sum_{i = 0}^{n} \\left( \\lfloor \\frac{i (a \\bmod c) + b \\bmod c}{c} \\rfloor + \\lfloor \\frac{a}{c} \\rfloor i + \\lfloor \\frac{b}{c} \\rfloor \\right) \\\\\n&= f(a \\bmod c, b \\bmod c, c, n) + \\lfloor \\frac{a}{c} \\rfloor \\frac{n(n + 1)}{2} + (n + 1) \\lfloor \\frac{b}{c} \\rfloor\n\\end{align}\n$$\n\n当 $a < c$ 且 $b < c$ 时：\n\n$$\n\\begin{align}\nf(a, b, c, n) &= \\sum_{i = 0}^{n} \\sum_{j = 1}^{m} [\\frac{ai + b}{c} \\geq j] \\\\\n&= \\sum_{i = 0}^{n} \\sum_{j = 0}^{m - 1} [ai \\geq c(j + 1) - b] \\\\\n&= \\sum_{i = 0}^{n} \\sum_{j = 0}^{m - 1} [ai > cj + c - b - 1] \\\\\n&= \\sum_{i = 0}^{n} \\sum_{j = 0}^{m - 1} [i > \\frac{cj + c - b - 1}{a}] \\\\\n&= \\sum_{j = 0}^{m - 1} \\sum_{i = 0}^{n} [i > \\frac{cj + c - b - 1}{a}] \\\\\n&= \\sum_{j = 0}^{m - 1} \\left( n - \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor \\right) \\\\\n&= nm - f(c, c - b - 1, a, m - 1)\n\\end{align}\n$$\n\n## 函数 $g$ 的处理\n\n当 $a \\geq c$ 或 $b \\geq c$ 时：\n\n$$\n\\begin{align}\ng(a, b, c, n) &= \\sum_{i = 0}^{n} \\left( \\lfloor \\frac{i (a \\bmod c) + b \\bmod c}{c} \\rfloor i + \\lfloor \\frac{a}{c} \\rfloor i^2 + \\lfloor \\frac{b}{c} \\rfloor i \\right) \\\\\n&= g(a \\bmod c, b \\bmod c, c, n) + \\lfloor \\frac{a}{c} \\rfloor \\frac{n(n + 1)(2n + 1)}{6} + \\lfloor \\frac{b}{c} \\rfloor \\frac{n(n + 1)}{2}\n\\end{align}\n$$\n\n当 $a < c$ 且 $b < c$ 时：\n\n$$\n\\begin{align}\ng(a, b, c, n) &= \\sum_{i = 0}^{n} i \\sum_{j = 1}^{m} [\\frac{ai + b}{c} \\geq j] \\\\\n&= \\sum_{i = 0}^{n} i \\sum_{j = 0}^{m - 1} [i > \\frac{cj + c - b - 1}{a}] \\\\\n&= \\sum_{j = 0}^{m - 1} \\sum_{i = 0}^{n} i [i > \\frac{cj + c - b - 1}{a}] \\\\\n&= \\sum_{j = 0}^{m - 1} \\frac{1}{2} (n + 1 + \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor) (n - \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor) \\\\\n&= \\frac{1}{2} \\sum_{j = 0}^{m - 1} \\left(n(n + 1) - \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor - \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor ^2 \\right) \\\\\n&= \\frac{1}{2} \\left( nm(n + 1) - f(c, c - b - 1, a, m - 1) - h(c, c - b - 1, a, m - 1) \\right)\n\\end{align}\n$$\n\n## 函数 $h$ 的处理\n\n当 $a \\geq c$ 或 $b \\geq c$ 时：\n\n$$\n\\begin{align}\nh(a, b, c, n) &= \\sum_{i = 0}^{n} \\left( \\lfloor \\frac{i (a \\bmod c) + b \\bmod c}{c} \\rfloor + \\lfloor \\frac{a}{c} \\rfloor i + \\lfloor \\frac{b}{c} \\rfloor \\right)^2 \\\\\n&= h(a \\bmod c, b \\bmod c, c, n) + 2 \\lfloor \\frac{a}{c} \\rfloor g(a \\bmod c, b \\bmod c, c, n) + 2 \\lfloor \\frac{b}{c} \\rfloor f(a \\bmod c, b  \\bmod c, c, n) \\\\\n&+ \\lfloor \\frac{a}{c} \\rfloor^2 \\frac{n(n + 1)(2n + 1)}{6} + \\lfloor \\frac{b}{c} \\rfloor^2(n + 1) + \\lfloor \\frac{a}{c} \\rfloor \\lfloor \\frac{b}{c} \\rfloor n(n + 1)\n\\end{align}\n$$\n\n当 $a < c$ 且 $b < c$ 时：\n\n$$\n\\begin{align}\n\\because ~&\nn^2 = 2 \\times \\frac{n(n + 1)}{2} - n = 2\\sum_{i = 1}^{n}i - n \\\\\n\\therefore ~&\nh(a, b, c, n) = \\sum_{i = 0}^{n} (2 \\sum_{j = 1}^{\\lfloor \\frac{ai + b}{c} \\rfloor} j - \\lfloor \\frac{ai + b}{c} \\rfloor)\n\\end{align}\n$$\n$$\n\\begin{align}\nh(a, b, c, n) &= \\sum_{i = 0}^{n} (2 \\sum_{j = 1}^{\\lfloor \\frac{ai + b}{c} \\rfloor} j - \\lfloor \\frac{ai + b}{c} \\rfloor) \\\\\n&= 2 \\sum_{j = 0}^{m - 1} (j + 1) \\sum_{i = 0}^{n} [\\frac{ai + b}{c} \\geq j + 1] - f(a, b, c, n) \\\\\n&= 2 \\sum_{j = 0}^{m - 1} (j + 1) \\sum_{i = 0}^{n} [i > \\frac{cj + c - b - 1}{a}] - f(a, b, c, n) \\\\\n&= 2 \\sum_{j = 0}^{m - 1} (j + 1) (n - \\lfloor \\frac{cj + c - b - 1}{a} \\rfloor) - f(a, b, c, n) \\\\\n&= nm(m + 1) - 2g(c, c - b - 1, a, m - 1) - f(a, b, c, n)\n\\end{align}\n$$\n\n","tags":["学习笔记","类欧几里得算法"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[HDU 5909] Tree Cutting","url":"/HDU-5909-Tree-Cutting/","content":"\n## 题目大意\n\n给定一棵 $n$ 个节点的树，每个点有一个权值 $v_i$。对于该树的任意一个非空子树，定义其权值为 $v_1 \\oplus v_2 \\oplus \\cdots \\oplus v_m$ （$v_i$ 为子树上的点权）。现给出 $m = 2^p$，对于 $[0, m)$ 内的每一个数 $k$，求有多少个子树的权值为 $k$。\n\n$T$ 组数据。\n\n$1 \\leq T \\leq 10$\n\n$1 \\leq n \\leq 1,000$\n\n$1 \\leq m \\leq 2^{10}$\n\n$0 \\leq v_i < m$\n\n## 题目链接\n\n[HDU 5909](http://acm.hdu.edu.cn/showproblem.php?pid=5909)\n\n<!--more-->\n\n## 题解\n\n点分治 + DP。\n\n对于一条链上的情况，可以很快想到一个简单粗暴的 DP：定义 $f(u, i)$ 表示计算到点 $u$ 时数 $i$ 的答案。但放在树上合并子树时存在困难。\n\n考虑点分治，每次考虑经过重心的链的答案。在 dfs 计算完一颗子树后，把当前的 DP 信息直接与该子树的兄弟合并，并用合并后的信息向下更新，这样每次都是合并多个数与一个数的情况，与链状时相同。之后再由低向上更新即可。\n\n类似题目：[2017-CCPC-杭州-E-Master of Subgraph](http://acm.hdu.edu.cn/showproblem.php?pid=6268)\n\n## 代码\n\n```c++\n#include <bits/stdc++.h>\n\nconst int MAXN = 1005;\nconst int MAXM = 1050;\nconst int MOD = 1000000007;\n\ninline int add(int &x, int d) {\n    x += d;\n    x >= MOD ? x -= MOD : 0;\n}\n\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int val, f[MAXM], size, max;\n    bool solved;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n}\n\nvoid dfs(Node *u, Node *fa, Node **a, int &p) {\n    u->size = 1;\n    u->max = 0;\n    a[p++] = u;\n    for (Edge *e = u->e; e; e = e->next) if (!e->v->solved && e->v != fa) {\n        dfs(e->v, u, a, p);\n        u->size += e->v->size;\n        u->max = std::max(u->max, e->v->size);\n    }\n}\n\nNode *center(Node *s) {\n    static Node *a[MAXN];\n    int p = 0;\n    dfs(s, NULL, a, p);\n\n    Node *res = NULL;\n    for (int i = 0; i < a[0]->size; i++) {\n        a[i]->max = std::max(a[i]->max, s->size - a[i]->size);\n        if (!res || res->max > a[i]->max) res = a[i];\n    }\n    return res;\n}\n\nvoid dfs(Node *u, Node *fa, int m) {\n    for (Edge *e = u->e; e; e = e->next) if (!e->v->solved && e->v != fa) {\n        std::fill(e->v->f, e->v->f + m, 0);\n        for (int i = 0; i < m; i++) if (u->f[i]) add(e->v->f[i ^ e->v->val], u->f[i]);\n        dfs(e->v, u, m);\n        for (int i = 0; i < m; i++) if (e->v->f[i]) add(u->f[i], e->v->f[i]);\n    }\n}\n\nvoid calc(Node *u, int *ans, int m) {\n    std::fill(u->f, u->f + m, 0);\n    u->f[u->val] = 1;\n    dfs(u, NULL, m);\n    for (int i = 0; i < m; i++) if (u->f[i]) add(ans[i], u->f[i]);\n}\n\nvoid solve(int *ans, int m) {\n    static std::stack<Node *> s;\n    s.push(&N[1]);\n\n    std::fill(ans, ans + m, 0);\n\n    while (!s.empty()) {\n        Node *u = s.top();\n        s.pop();\n\n        Node *root = center(u);\n        root->solved = true;\n\n        calc(root, ans, m);\n\n        for (Edge *e = root->e; e; e = e->next) if (!e->v->solved) s.push(e->v);\n    }\n}\n\nvoid init(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) {\n        N[i].e = NULL;\n        N[i].solved = false;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        init(n);\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].val);\n        for (int i = 1, u, v; i < n; i++) {\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n        }\n\n        static int ans[MAXM];\n        solve(ans, m);\n        for (int i = 0; i < m; i++) printf(\"%d%c\", ans[i], \" \\n\"[i == m - 1]);\n    }\n\n    return 0;\n}\n```","tags":["DP","点分治"],"categories":["学习笔记（OI/XCPC）"]},{"title":"ZJU 八月集训随记","url":"/ZJU-八月集训随记/","content":"\n* Day1 - SWERC 2017 - 2018.8.9 - Codeforces\n* Day2 - GCPC 2010 - 2018.8.10 - vjudge\n* Day3 - NEERC Moscow 2017 - 2018.8.11 - Codeforces\n* Day4 - 2013 Andrew Stankevich Contest 43 - 2018.8.12 - opentrains\n* Day4.5 - Makoto Soejima Contest 3 (MIPT Workshop Open 2) - 2018.8.13 - opentrains\n* Day5 - 2018 Multi-University Training Contest 7 - 2018.8.14 - vjudge\n* Day6 - NEERC Northern Subregional Contest St Petersburg 2017 - 2018.8.15 - Codeforces\n* Day 7 - CERC 2017 - 2018.8.16 - Codeforces\n* Day 8 - JAG Autumn 2014, MIPT2014 Round 1 - 2018.8.17 - opentrains\n* Day 9 - NEERC 2014 - 2018.8.18 - opentrains\n* Day 9.5 - XVIII Open Cup named after E.V. Pankratiev. GP of Urals - 2018.8.19 - opentrains\n* Day 10 - AMPPZ-2015 MIPT-2015 ACM-ICPC Workshop, Round 1 - 2018.8.20 - opentrains\n* Day 11 - NEERC St Petersburg 2017 - 2018.8.21 - Codeforces\n* Day 12 - 2018 Multi-University Training Contest 8 - 2018.8.22 - PC^2\n* Day 13 - 2015 Moscow International ACM ICPC Workshop AIM Fund Contest - 2018.8.23 - opentrains\n\n全程为 ACM 赛制组队训练，小数天数指队伍加训。**Xnyttt** 表示在时间 $ttt$ 的时候提交了题目 X 的第 $n$ 份代码并获得 AC。\n\n从 Day5 开始 rated。\n\n队友：郑鸿鹄（Codeforces@zhhhplus）、林思仪（Codeforces@LIN452）\n\n已获区域赛资格一份。\n\n<!--more-->\n\n## Day1 - SWERC 2017 - 2018.8.9 - Codeforces\n\n### 赛时流水账\n\n开场读题并未发现签到题，看了一下榜发现 F 有人过，向 lsy 读了一下发现是傻逼题，于是 **F1y18** ，之后 zhh **A1y35**，在 zhh 写题期间看到 J 也有人过，发现写一个前缀和就好了，于是 **J1y40**，之后 zhh 敲完了计算几何的板子，并写了 K 题，但一直 WA on 18，打印出来后发现把点到直线的距离写成了点到线段距离，改了之后 **K4y121** ，期间我一直在想 C 的 DP 但发现会 TLE，zhh A 完 K 后也得出了 $3^8 \\times 3^8$ 的矩阵，最终未能得到正解。期间 lsy 觉得 D 能写，我则和 zhh 讨论 G，发现可以建图跑费用流，我抄了自己的板子但是 TLE 了，而 KM 算法感觉也不能过，于是一直让 lsy 去写 D。我读了一下 E 题，虽然没看懂样例，但感觉可以先拓扑排序在背包，但由于理解错了题意，写了完全背包，而正解是 01 背包，导致连样例都过不了。最后几十分钟时，zhh 打算抄一遍 KM 的板子写 G，但写完后发现不会用，同时也到点了。最终 4 题，rk11。\n\n### 赛后\n\nE 改了一下就 A 了。C 得知可以用斐波那契数列优化成 $2^8 \\times 2^8$ 的矩阵就可以做了。lsy 之后也补掉了 B 题。\n\n## Day2 - GCPC 2010 - 2018.8.10 - vjudge\n\n### 赛时流水账\n\n开场读题并未发现签到题，看榜发现了 H 题，差分三次即可，但是有一点细节写错了 WA 了两发，最终 **H3y21**。A 完 H 看榜发现 I 也是签到题，于是 zhh **I1y35**，lsy 觉得 D 是 Tarjan 也能做，于是 **D2y98**，期间和 zhh 讨论了一下 A，我想了想细节发现十分好写，于是 **A1y89**。我给 lsy 与 zhh 说了 G 的题意后，二人给出了不同的解法，其中 zhh 的做法听起来不太对，但是好写，于是 WA 了三发后交由 lsy 写状压，由于未清空数组，又 WA 了三发后 **G7y147**，期间给 zhh 说了一下 C 的题意后发现写个拓扑排序即可，但由于开小了数组，**C2y124** 。在 lsy 调 G 的时候，zhh 给我讲了 J 的题意和做法，感觉十分的正确，但当时还没有人 AC J 题，zhh 先敲了板子，在 lsy 过了 G 后 **J1y182**。期间 lsy 读了 E 题，zhh 听后感到奇怪，交由我确认了一下题意，感觉可以 sam，于是 lsy 去看板子回忆 sam。我读了 K 的题面后感觉是个傻逼题，但一直 WA 到比赛结束，lsy 的 sam 也没有调出来。最终 7 题，rk 12。\n\n### 赛后\n\nK 发现是全队三人不认识 perpendicular，导致细节出错，改了之后 A 了。E sam 确实能做，但标算似乎是 trie，另外，用 `std::set<std::string>` 的暴力也可以过。\n\n## Day3 - 2018.8.11 - NEERC Moscow 2017 - Codeforces\n\n### 赛时流水账\n\n开场我因为少读了 E 的一个条件，WA 了一发（E 题全场唯一的一发提交）。之后 lsy 发现 D 可以签到，由于爆 `long long` WA 了一发，**D2y63**，之后 zhh **A2y68**。zhh 给我说了一下 H 的题意发现可写但细节比较多，我去推了推式子但是 WA 了三发，未能找到错误。期间 zhh 写 F 的模拟到心态爆炸，换了 lsy 去写 F，同时 lsy 告诉了 zhh C 的做法，最后 lsy **F3y208**。zhh 发现lsy 的 C 有问题，打算用树剖，于是告诉我了题意，因一些细节问题又 WA 了几发，最后 **C7y266** 。lsy 看了一下我的 H 的代码，不过还是重写了一遍 H 后 **H4y282**，最后十几分钟和 zhh 读了 G，随便写了一下果然 WA 了。最终 5 题，rk 12。\n\n### 赛后\n\n发现自己的 H 把一个减号写成了加号；G 发现是个很简单的题但由于卡题而没有去读。\n\n## Day4 - 2013 Andrew Stankevich Contest 43 - 2018.8.12 - opentrains\n\n### 赛时流水账\n\n开场和 lsy 交换了一下 B 的思路，我找了一下规律，得到了一个细节有点问题的做法，lsy 补充后 **B1y98**，之后 zhh 和 lsy 讨论了一下 I，于是 lsy **I1y147**。和 zhh 讨论了一下 H 后发现可以构建最小割模型，但一直 WA on 14。同时 zhh 告诉我了 K 的题意和做法，由于理解出了偏差，WA 了几发，最后 **K5y258**。期间 zhh 与 lsy 一直尝试构造 J 但是失败。最后 zhh 说了一下 L 可能 的解法，我写了一发但是 WA 了。最终 3 题，rk 10。\n\n### 赛后\n\nH 题把我们的拆点做法改为不拆点就能 A，但是对排了一百多组随机数据也没能找到拆点做法的错误。我在听了 J 的题意后便想到了标算的构造，到当时感觉有问题而没说，zhh 和 lsy 也没能想出这个构造（这个锅我背了。。。），L 发现 zhh 给的做法有一点问题。\n\n## Day4.5 - Makoto Soejima Contest 3 (MIPT Workshop Open 2) - 2018.8.13 - opentrains\n\n### 赛时流水账\n\n开场先和 zhh 想了 E 和 H，去机子上打了 E 的表，zhh 则打开 OEIS 书但是未能找到。lsy 发现 B 是个贪心，于是 **B3y41**。给 zhh 和 lsy 说了 C 的题意，自己则在打 H 的表，zhh 以为发现了规律，但多打了一些后发现是错的，不过我有了一个思路，但复杂度不对。lsy **C2y121** 后听了我的 H 的思路开始和 zhh 一起思考，同时给我说了 G 可以大力讨论，讨论了一下后我感觉能写，WA 了几发后发现了一个大 bug，lsy 提出了想法，但由于我理解处理偏差，半个小时后才意识到是对的，修完 bug 后还是 WA，并且还是想不到 WA 点，H 题那边 lsy 想到了做法，但感觉会 TLE 而没有写。最终 2 题。\n\n### 赛后\n\n赛后发现自己的 G 用到了可能未被算出来的数据，改了一下后 AC 了；lsy 的 H 题做法其实的对的。我学习了一下「竞赛图的强连通分量数等于划分成两个非空点集 $S$、$T$ 使得二者之间的边都是由 $S$ 指向 $T$ 的方案数加一」的姿势并补掉了 E，同时补掉了另一个计数题 D。\n\n## Day5 - 2018 Multi-University Training Contest 7 - 2018.8.14 - vjudge\n\n### 赛时流水账\n\n开场我先看了 E、F 和 H，感觉 E 可以做，稍微找了找规律，发现是完全积性的，同时回忆了一下某个经典式子的反演结果（懒地推了），敲完后发现样例过不了，又看了看发现只是普通的积性，改完后 TLE，删除了几次多余的取模操作后 **E2y99**，拿下 E 的一血。之后 zhh 给我说了 J 的题意，发现是傻逼签到题，写完后 **J1y118**。zhh 和 lsy 讨论了A，lsy 去写了，但是 TLE。zhh 卡了卡常后，lsy 发现了一处问题，修改后本地十组大数据 $3$s，时限 $2.5$s 且原题有二十组数据，但还是交了一发，**A3y201**。zhh 告诉我 H 可以树剖，I 可以 LCT，想了想确实都是板子题，考虑到我的 LCT 可能不是很好调 + LCT 的常数比较大，我选择去写 H，但是一直 WA。同时 lsy 想到了 K 的做法，也没有调出来。最终 3 题，rk 8。\n\n### 赛后\n\nH 发现一个细节写错了：二次修改一个点时我找的是初始值而非之前修改后的值，改了之后 AC，但实际上 H 有更短更好写的做法。lsy 调完了自己的 K 也 AC 了。之后用自己的 LCT 板子过了 I 发现并不用担心常数。\n\n## Day6 - NEERC Northern Subregional Contest St Petersburg 2017 - 2018.8.15 - Codeforces\n\n### 赛时流水账\n\n开场 lsy **A1y12**，zhh 想到了 L 的做法并去写，但死机了，之后 lsy **B1y44**，期间我发现 I 很可写，K 也是个傻逼构造，于是 **K1y53**，lsy 先写了一发 C，于是 **C1y75**，我想完 I 的细节，**I1y93**。十分钟后过了 L 的样例，但是 WA on 6，发现问题后又 WA on 13。lsy 和 zhh 想到了 E 的做法，但是 RE on 4 和 WA on 8。我又意识到了 L 可能会发生 `long long` 与 `double` 间的精度问题，改了一发 WA on 29，又想到一点后 **L4y169**。lsy 与 zhh 发现 E 做法的问题，zhh 改正后 **E5y212**。之后 zhh 想到了 G 的做法，我和 lsy 也思考了一下 H，感觉做出 G 的概率更大，于是我去写了 G 的点双，写了各种细节后 RE on 2。最终 7 题，rk 7。\n\n### 赛后\n\nG 发现问题后不断地 WA on 2（有 $1815$ 个子测试点），但其实有更简单的做法，lsy 补掉了 G。同时我和 lsy 补掉了 H。\n\n## Day 7 - CERC 2017 - 2018.8.16 - Codeforces\n\n### 赛时流水账\n\n开场先 WA 了三发 F，而且是 WA on 1，但是本地确实过了样例，期间修正了一些细节，我怀疑是多组数据或 PE，zhh 表示了否定，F 先放下了。之后 lsy **A1y80**，zhh 和我说了一下 J 的题意，发现很可写，于是 **J1y85**。之后 zhh 重写了 F，仍然 WA on 1，lsy 表示用 `%lld` 输出 `int` 可能会有问题，zhh 改了后 **F6y114**。我跟榜去看了 H，看了两遍后看懂了题意，发现直接建树跑 dfs 即可，于是 **H1y133**。这时发现总榜上只有 G、K 和 L 有人过，过 G 的人更多，于是 zhh 和 lsy 去想 G，不擅长期望的我准备开别的题。一段时间后，看到 EuropeSun（oyyf、wyh、zx）过了 L，于是去看 L，看到坐标范围很小，感觉可以差分，思考了一段时间细节。期间 lsy 想到了 G 的转移，在因为写错一个括号的位置 WA 了一发后 **G2y228**。之后我去写 L，调了一段时间细节后发现交不上去，五六分钟后 MLE on 1（算了一下只超了 $4$M），删去一个无用数组后 WA on 1，发现是修改时没有修改完，最后 **L3y282**，最后读了一下 D 的题意放弃。最终 6 题，rk 5。\n\n### 赛后\n\n自已的 F 改掉 `%lld` 也过了。\n\n## Day 8 - JAG Autumn 2014, MIPT2014 Round 1 - 2018.8.17 - opentrains\n\n### 赛时流水账\n\n开场跟榜知道 A 是签到题，但理解了二十分钟，写完后 WA on 1，和 zhh 浪费了二十分钟找错，最后发现是交成了 13 号的 A 题，于是 **A2y49**。之后 lsy 与 zhh 讨论出来 G，因为未初始化 + 爆了 `long long` WA 了两发，**G3y96**。期间 zhh 给我讲了 B 的高斯消元做法，我去一旁回想高消，同时 zhh 去和 lsy 讨论 D。D 在 WA 了一次后 **D2y223**，我在期间写完了 B 并开始调试，一段时间后过了样例，但是 WA on 2，zhh 指出从上三角消成对角线时的错误，仍然 WA on 2，最后 zhh 意识到最后可能还是消不成对角线并且我会 WA 在这个地方，改正后 **B6y265**。最后写了些中途看的 K 题，一直过不了样例。最终 4 题，rk 12。\n\n### 赛后\n\nzhh 指出了一个问题，K 在赛后几秒过了样例，但是 TLE，改正几发后补掉了。同时发现 H 是个傻逼题，但是没有人读了题面，赛后十几分钟后一遍过掉了。网络流的 F 和 DP 的 J 则被 lsy 补了。\n\n## Day 9 - NEERC 2014 - 2018.8.18 - opentrains\n\n### 赛时流水账\n\n开场 zhh 快速 **A1y13**，之后我暴力 **K1y23**，再之后 lsy 爆搜 **J2y48**。之后我发现 F 暴力的复杂度是对的，但是 WA 了两发，期间 zhh 与 lsy 讨论出了 B，于是 zhh **B1y86**。之后我发现我的 F 是因为把 `j` 打成了 `i`，改正后 **F4y110**。再之后 lsy 发现了 I 的性质，于是 **I1y150**。后半场 zhh 与 lsy 在思考 E，我则在想了一会儿 E 后转去想 D，突然想到了祖暅原理，觉得可以暴力微分，zhh 则提出了蒙特卡洛，但无论是哪个，推了好久式子都没能推出来；zhh 想到了 E 的做法，但由于细节比较难写而没有写出。最终 6 题，rk 5。\n\n### 赛后\n\n赛后理清了思路写了 D 题，调了几个小时后过了样例一，但是 WA 样例二，又过了几个小时发现是打错了变量名（一天两次……），最后由于精度 WA on 48 一次过了。\n\n## Day 9.5 - XVIII Open Cup named after E.V. Pankratiev. GP of Urals - 2018.8.19 - opentrains\n\n### 赛时流水账\n\n开场发现 B 是签到，三人讨论了一下后 WA on 2，再次讨论后补上一个细节后 **B2y53**。之后一个多小时思考 A 和 C，但是毫无进展。lsy 想到了 K 的做法，写好后 WA on 4，改正一些后 WA on 7，此时还剩半场的时间，而 lsy 的代码看起来比较正确，在更改了感觉更正确的写法后仍然 WA on 7，zhh 提议面向评测机调试，但返回的结果却是最难调的情况。我仔细查过 lsy 的代码后，感觉正确无比，但是 WA on 7。期间我思考了一下 D，转化为若干个 $[0, 9]$ 的数和为某个数的方案数，但式子推不出来。最终 1 题。\n\n### 赛后\n\nlsy 用 K 的标程对拍，随机了几百组数据没有拍出错误。D 在容斥时钦定超过即为 $10$ 就是对的。\n\n## Day 10 - AMPPZ-2015 MIPT-2015 ACM-ICPC Workshop, Round 1 - 2018.8.20 - opentrains\n\n### 赛时流水账\n\n开场发现 D 是签到，F 是签到，之后 zhh 与 lsy 又给出了 B 的做法，此时不到一个小时，但 opentrains 挂了（于是 unrated）。之后去想 opentrains 挂掉前有人过的题：A、H、K、L。zhh 说 A 可以不老老实实地算：当足够大时，那个 $-1$ 可以忽略，但是一开始推错了式子，最后还是写出来了。lsy 尝试暴力过 H，但是 9s 时限本地跑了 13s，虽然加了一个优化跑到了 7.5s，但感觉优化会有无效的时候；之后 lsy 就去想 L，并发现了与子树遍历顺序无关的性质，但下一步没有走下去。我企图推 K 的式子，虽然长得有规律但是化简不能。zhh 说做过 G 中只有两种点的时的题目，后来提到昨晚两个可以合并，感觉可以分治。\n\n不过以上均为嘴巴 AC，opentrains 在比赛结束五个多小时后仍未修复。。。\n\n### 赛后\n\n辣鸡 opentrains。\n\n## Day 11 - NEERC St Petersburg 2017 - 2018.8.21 - Codeforces\n\n### 赛时流水账\n\n开场发现 D 是签到，11 分钟写完后 WA on 9，之后发现是没有处理 0 比较多的情况，改了一发 **D2y15**。同时发现 B 是签到，zhh 推了推 **B1y44**。看总榜发现 D 的过题数仅次于 A 和 C，A 没有思路，C lsy 与 zhh 在讨论，于是去想了 D 的构造，但感觉细节需要想一下。期间 lsy 想出来 C，于是 **C1y89**。我想清了 D 的细节，在打错一次变量名后 **D2y98**，拿下 D 的一血。A 题 zhh 和 lsy 有一点想法，总榜上下一道是 L，于是去看了看，感觉可以树剖 + 染色做，抄了一会儿板子意识到有点问题，说出来后意识到可以按集合大小排个序，于是继续去写了，在提交前被 lsy 提醒边的数组是否够大，发现又一次忘写 `<< 1`，于是 **Ly151**，拿下 L 的一血。之后给 zhh 说之前 A 的某一个做法，应该可以实现线段树维护一段集合进行区间加一个元素，复杂度 $O(n \\log n \\log \\log n)$，写了之后 WA on 2 改了一个 bug 后仍然 WA on 2。lsy 理了理 F，但是 RE on 2。zhh 表示用他之前 $O(n \\log^2 n)$ 的做法重写，此时只剩不到 20 分钟。听清细节后 WA on 1（本地测错代码了。。。），改正后 WA on 15，zhh 表示枚举时直接 `set.erase(it)` 可能会挂，改成 `goto` 后 WA on 2，意识到问题后再次 WA on 15，zhh 表示数组应该开到 30，于是 **A7y294**。最终 6 题，rk 3（Legilimens 虽然不是一起打的，但还是算上吧）。\n\n### 赛后\n\n在此处，`set.erase(it)` 并不会出问题（但其他地方确实会有出问题的可能）。\n\n## Day 12 - 2018 Multi-University Training Contest 8 - 2018.8.22 - PC^2\n\n### 赛时流水账\n\n开场发现 E 是签到题，于是 **E1y8**，之后发现 A 是 Day 9.5 - D 约化后的问题，于是 **A1y31**（两题都是一血）。之后觉得 B 是一道水题，但是 WA 了，直到比赛结束也不知道 WA 在什么地方；zhh 给 lsy 讲了 J 错的题意，于是 WA 了；构造的 D 也是几个 WA。一段时间过去，D 终于给出了最优的构造，于是 **D5y190**；lsy 在知道 J 的正确题意后 **J3y268**。最终 4 题，rk 6。\n\n## Day 13 - 2015 Moscow International ACM ICPC Workshop AIM Fund Contest - 2018.8.23 - opentrains\n\n### 赛时流水账\n\n开场发现 E 是签到题，向 zhh 确认过后 **E1y4**（总榜并列一血）。之后发现 I 就是个大模拟，写完后意识到可能会 MLE，于是把 `int` 改成 `short`， **I1y27**（校内一血）。同时，lsy 与 zhh 在想 A 和 H，一段时间后 lsy **A1y50**，zhh 在写错一次数组下标后 **H2y82**。给 zhh 说了 G 的题意后，zhh 很快给出了做法，但是不停地 TLE on 1，加了 `assert` 交互次数后发现迷之爆了交互次数，于是决定在最后一次时直接当做答案，于是 **G4y119**（现场校内一血，但是比 Legilimens 要晚）。之后 lsy 在想 J，写了一个错误的贪心，但一开始并没有意识到；我则觉得 F 只需要求出 $k \\sim 2k$ 内满足条件的数，其倍数均可以且不会有漏，但是 WA，zhh 说搞到 $k^2$，发现确实漏了一些，但仍然是 WA。lsy 意识到 J 的错误后改写 DP，但没有调出来。最终 5 题，rk 11。\n\n### 赛后\n\nF 再多搞一搞就是对的了……\n\n## 大总结\n\n最终在 $12$ 支队伍中排名第 $8$，在预备队中排名第 $2$，踩了一支 B 队。在最后一天被 ACetic_ACid 反超，总 rating 只相差 $0.6$，有点可惜。不过有区域赛资格总是好的。\n\n自己读错题意、打错变量名、数组开小三项错误的次数在队伍中位居第一（由于 zhh 从 Day 3 开始计数，导致自己读错题的次数其实少记了三次），正式赛时不能再这样了。\n\n希望自己能在区域赛上表现得好点，希望能在区域赛上碰到能让我一眼有想法的中档题，希望队伍拿个颜色好看点的牌子，就是这样了。","tags":["随笔","ZJU"],"categories":["比赛游记"]},{"title":"ZJU 七月集训题目选讲（Contest 10 ～ 12）","url":"/ZJU-七月集训题目选讲（Contest-10-～-12）/","content":"\nZJU 七月集训（2018.7.13 ～ 2018.7.26）的题目。\n\n* Contest 10 by bits/stdc++.h - 2018.7.24\n* Contest 11 by ChugJug - 2018.7.25\n* Contest 12 by DeepDark - 2018.7.26\n\n所有题目都是多组数据，若无子测试点数的说明，则 $T$ 不会特别大。\n\n## 目录\n\n[Contest 10 - A - Bnumbers](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#10a)\n\n[Contest 10 - D - Osu](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#10d)\n\n[Contest 10 - F - Pokemon](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#10f)\n\n[Contest 11 - A - Haibara and Bit Strings](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#11a)\n\n[Contest 11 - E - JSB's Happy Life 1](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#11e)\n\n[Contest 12 - B - zx2018 and Study](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#12b)\n\n[Contest 12 - E - zx2018 and Treasures](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#12e)\n\n[Contest 12 - F - zx2018 and sequence](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-10-%EF%BD%9E-12%EF%BC%89/#12f)\n\n<!--more-->\n\n## Contest 10 - A - Bnumbers<span id = \"10a\"></span>\n\n### 题目大意\n\n一个数 $k$ 在 $a$ 进制下的表示为 $x_nx_{n-1} \\dots x_1x_0$。定义 $k$ 是 $a$ 进制下的一个 B 数，当且仅当：\n\n$$\n\\sum_{i = 0}^{n} x_i^2 = k\n$$\n\n求 $a$ 进制下共有多少个 B 数。\n\n$2 \\leq N \\leq 1,000$\n\n$2 \\leq a \\leq 10^6$\n\n$\\sum a \\leq 10^8$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n可以证明，B 数要么是 $1$，要么是一个 $a$ 进制下的两位数。写出对应的不定方程，$O(a)$ 枚举求解另一变量并判断计数即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int ans = 1;\n        for (int i = 1; i < n; i++) {\n            long long temp = (long long) (n - i) * i;\n            long long delta = 1 + temp * 4;\n            long long st = (int) (std::sqrt(delta) + 0.001);\n            if (st * st != delta) continue;\n            int j = (1 + st) / 2;\n            if (j < n) ++ans;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}\n```\n\n## Contest 10 - D - Osu<span id = \"10d\"></span>\n\n### 题目大意\n\n一个长为 $n$ 的 $01$ 序列，每个位置有 $p_i$ 的概率为 $1$。一段长为 $len$ 的连续的 $1$ 的贡献为 $len^3$。有 $Q$ 次操作，每次操作会将位置 $i$ 的概率改变，或询问 $[l, r]$ 内总贡献的期望。\n\n$1 \\leq n, Q \\leq 100,000$\n\n$1 \\leq T \\leq 5$\n\n时间限制：$2 \\text{s}$，内存限制：$128 \\text{MB}$。\n\n### 题解\n\n长度从 $len$ 变为 $len + 1$，贡献值会增加 $(len + 1)^3 - len^3 = 3len^2 + 3len + 1$。\n\n记 $f(i)$ 为以 $i$ 结尾的答案，$E(i)$ 为以 $i$ 结尾的长度期望，$E2(i)$ 为以 $i$ 结尾的长度平方的期望，则转移为：\n\n$$\nf(i) = f(i - 1) + p_i(3E2(i) + 3E(i) + 1) \\\\\nE(i) = p_i(E(i - 1) + 1) \\\\\nE2(i) = p_i(E2(i - 1) + 2E(i - 1) + 1)\n$$\n\n考虑矩阵乘法，为每一个位置构造一个转移矩阵，用线段树维护区间信息，修改时单点修改矩阵，询问时直接查询即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nint dcmp(double a, double b = 0) {\n    const static double EPS = 1e-12;\n    double d = a - b;\n    return std::abs(d) <= EPS ? 0 : (d > 0 ? 1 : -1);\n}\n\nstruct Matrix {\n    const static int N = 4;\n\n    double a[N][N];\n    int n, m;\n\n    Matrix(int n = N, int m = N, bool eye = false) : n(n), m(m) {\n        for (int i = 0; i < n; i++) std::fill(a[i], a[i] + m, 0);\n        if (eye) for (int i = 0; i < n; i++) a[i][i] = 1;\n    }\n\n    double *operator[](int i) {\n        return a[i];\n    }\n    const double *operator[](int i) const {\n        return a[i];\n    }\n\n    Matrix operator*(const Matrix &rhs) const {\n        Matrix res(n, rhs.m);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (dcmp(a[i][j]))\n            for (int k = 0; k < rhs.m; k++) res[i][k] += a[i][j] * rhs[j][k];\n        return res;\n    }\n} A;\n\nMatrix getMat(double p) {\n    Matrix res(4, 4);\n    res[0][0] = res[3][3] = 1;\n    res[0][1] = res[0][2] = 3 * p;\n    res[0][3] = res[1][1] = res[1][3] = res[2][2] = res[2][3] = p;\n    res[2][1] = 2 * p;\n    return res;\n}\n\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        Matrix val;\n\n        Node() {}\n        Node(const Matrix &val) : lc(lc), rc(rc), val(val) {}\n        Node(Node *lc, Node *rc) : lc(lc), rc(rc), val(rc->val * lc->val) {}\n\n        void maintain() {\n            val = rc->val * lc->val;\n        }\n\n        void update(int l, int r, int pos, double p) {\n            if (l == r) {\n                val = getMat(p);\n                return;\n            }\n            int mid = l + ((r - l) >> 1);\n            if (pos <= mid) lc->update(l, mid, pos, p);\n            else rc->update(mid + 1, r, pos, p);\n            maintain();\n        }\n\n        void query(int l, int r, int L, int R, Matrix &t) {\n            if (R < l || r < L) return;\n            if (L <= l && r <= R) {\n                t = val * t;\n                return;\n            }\n            int mid = l + ((r - l) >> 1);\n            lc->query(l, mid, L, R, t);\n            rc->query(mid + 1, r, L, R, t);\n        }\n    } *root, _pool[MAXN << 1], *_curr;\n    int n;\n\n    void init() {\n        _curr = _pool;\n        root = NULL;\n    }\n\n    Node *build(int l, int r, double *p) {\n        if (l == r) return new (_curr++) Node(getMat(p[l]));\n        int mid = l + ((r - l) >> 1);\n        return new (_curr++) Node(build(l, mid, p), build(mid + 1, r, p));\n    }\n    void build(double *p, int n) {\n        this->n = n;\n        root = build(1, n, p);\n    }\n\n    void update(int pos, double p) {\n        root->update(1, n, pos, p);\n    }\n\n    Matrix query(int l, int r) {\n        Matrix res = A;\n        root->query(1, n, l, r, res);\n        return res;\n    }\n} segT;\n\nint main() {\n    A = Matrix(4, 1);\n    A[3][0] = 1;\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        static double P[MAXN];\n        for (int i = 1; i <= n; i++) scanf(\"%lf\", &P[i]);\n\n        segT.init();\n        segT.build(P, n);\n\n        int q;\n        scanf(\"%d\", &q);\n        while (q--) {\n            int op;\n            scanf(\"%d\", &op);\n\n            if (op == 1) {\n                int x;\n                double p;\n                scanf(\"%d %lf\", &x, &p);\n\n                segT.update(x, p);\n            } else {\n                int l, r;\n                scanf(\"%d %d\", &l, &r);\n\n                Matrix ans = segT.query(l, r);\n                printf(\"%.2f\\n\", ans[0][0]);\n            }\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 10 - F - Pokemon<span id = \"10f\"></span>\n\n### 题目大意\n\n给定一个长为 $n$ 的序列 $\\{a_i\\}$，求至少删除多少的数后，序列的最长上升子序列的长度会减少。\n\n$0 \\leq n \\leq 1,000$\n\n$0 \\leq a_i \\leq 10^9$\n\n$1 \\leq T \\leq 5$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n考虑计算 LIS 的 DP 过程，如果 $f(i) = f(j) + 1$，则建一单向条边 $(j, i)$ ，拆点跑最小割即为答案。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1005;\n\nint a[MAXN], f[MAXN];\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN << 1];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n\n    Edge() {}\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), next(u->e), cap(cap), flow(0) {}\n} _pool[MAXN * MAXN], *_curr;\n\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v], cap);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\n\nnamespace Dinic {\nbool level(Node *s, Node *t, int n) {\n    for (int i = 0; i < n; i++) N[i].level = 0;\n\n    static std::queue<Node *> q;\n    while (!q.empty()) q.pop();\n    q.push(s);\n    s->level = 1;\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n\n        for (Edge *e = u->e; e; e = e->next) if (e->cap > e->flow && !e->v->level) {\n            e->v->level = u->level + 1;\n            if (e->v == t) return true;\n            q.push(e->v);\n        }\n    }\n\n    return false;\n}\n\nint findPath(Node *u, Node *t, int limit = INT_MAX) {\n    if (u == t) return limit;\n    for (Edge *&e = u->curr; e; e = e->next) if (e->cap > e->flow && e->v->level == u->level + 1) {\n        int flow = findPath(e->v, t, std::min(e->cap - e->flow, limit));\n        if (flow > 0) {\n            e->flow += flow;\n            e->rev->flow -= flow;\n            return flow;\n        }\n    }\n    return 0;\n}\n\nint solve(int s, int t, int n) {\n    int res = 0;\n    while (level(&N[s], &N[t], n)) {\n        for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n        int flow;\n        while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n    }\n    return res;\n}\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 0; i < n; i++) {\n        N[i].e = NULL;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        if (!n) {\n            puts(\"0\");\n            continue;\n        }\n        for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n        int lis = 0;\n        int s = 0, t = 2 * n + 1;\n        clear(t + 1);\n        for (int i = 0; i < n; i++) {\n            int max = 0;\n            for (int j = 0; j < i; j++) if (a[j] < a[i]) max = std::max(max, f[j]);\n            f[i] = max + 1;\n            lis = std::max(lis, f[i]);\n\n            for (int j = 0; j < i; j++) if (a[j] < a[i] && f[j] == max) addEdge(n + j, i, INT_MAX);\n            addEdge(i, i + n, 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (f[i] == 1) addEdge(s, i, INT_MAX);\n            if (f[i] == lis) addEdge(i + n, t, INT_MAX);\n        }\n\n        int ans = Dinic::solve(s, t, t + 1);\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## Contest 11 - A - Haibara and Bit Strings<span id = \"11a\"></span>\n\n### 题目大意\n\n长为 $n = 10^m$ 的 $01$ 串中，$01$ 作为子串出现了两次的有多少个，答案对 $1,000,000,007$ 取模。\n\n$1 \\leq m \\leq 10^7$\n\n$1 \\leq T \\leq 10,000$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n满足条件的串都长这样：\n\n$$\n1\\dots10\\dots01\\dots10\\dots01\\dots10\\dots0\n$$\n\n问题转化为 $a + b + c + d + e + f = n$ 的非负整数解的个数，由隔板法知答案为 $\\binom{n + 1}{5}$。\n\n### 代码\n\n```c++\n#include <cstdio>\n\nconst int MOD = 1000000007;\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nlong long inv = 808333339;\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int m;\n        scanf(\"%d\", &m);\n        int n = qpow(10, m);\n\n        long long ans = (n == MOD - 1 ? 0 : n + 1);\n        for (int i = 1; i < 5; i++) {\n            long long t = n + 1 - i;\n            t < 0 ? t += MOD : 0;\n            ans = ans * t % MOD;\n        }\n        ans = ans * inv % MOD;\n\n        printf(\"%lld\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 11 - E - JSB's Happy Life 1<span id = \"11e\"></span>\n\n### 题目大意\n\n有 $n$ 个数 $\\{a_i\\}$，定义其一个子集的价值为集合中 $a_i$ 的和，求其所有非空子集中，价值第 $k$ 小的价值。\n\n$1 \\leq n, k, a_i \\leq 100,000$\n\n$1 \\leq T \\leq 20$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n数的顺序对答案无影响，故可以现按升序对其排序。对于每一个状态，其后继都有两种选择：加上下一个；或先删去当前的，再加上下一个。用一个优先队列储存，先放入所有元素，每次弹出一个并放入其两个后继至完成 $k - 1$ 次操作，此时优先队列的队首即为答案。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct HeapNode {\n    int sum, pos;\n\n    HeapNode(int sum, int pos) : sum(sum), pos(pos) {}\n\n    bool operator<(const HeapNode &rhs) const {\n        return sum > rhs.sum;\n    }\n};\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        static int a[MAXN];\n        for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n        std::sort(a, a + n);\n\n        static std::priority_queue<HeapNode> q;\n        while (!q.empty()) q.pop();\n        q.push(HeapNode(a[0], 0));\n\n        for (int i = 1; i < k; i++) {\n            HeapNode u = q.top();\n            q.pop();\n\n            if (u.pos < n - 1) {\n                q.push(HeapNode(u.sum + a[u.pos + 1], u.pos + 1));\n                q.push(HeapNode(u.sum + a[u.pos + 1] - a[u.pos], u.pos + 1));\n            }\n        }\n\n        printf(\"%d\\n\", q.top().sum);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 12 - B - zx2018 and Study<span id = \"12b\"></span>\n\n### 题目大意\n\n求方程\n\n$$\n\\sum_{i = 1}^{a}i = 2\\sum_{i = 1}^{b - 1} + b\n$$\n\n从小到大的第 $n$ 组解。\n\n$1 \\leq n \\leq 10^{12}$\n\n$1 \\leq T \\leq 1,000$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n方程可变形为：\n\n$$\n(2a + 1)^2 - 8b^2 = 1\n$$\n\n令 $u = 2a + 1, v = b$，则方程为一个佩尔方程。由相关理论知：\n\n$$\n\\begin{align}\nu_n &= u_{n - 1}u_0 + v_{n - 1} + 8 \\\\\nv_n &= v_{n - 1}u_0 + u_{n - 1}v_0\n\\end{align}\n$$\n\n复原 $a, b$ ，用矩阵乘法快速幂计算即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nconst int MOD = 1000000009;\n\nstruct Matrix {\n    static const int N = 3;\n\n    long long a[N][N];\n    int n, m;\n\n    Matrix(int n = N, int m = N, bool eye = false) : n(n), m(m) {\n        for (int i = 0; i < n; i++) std::fill(a[i], a[i] + m, 0);\n        if (eye) for (int i = 0; i < n; i++) a[i][i] = 1;\n    }\n\n    long long *operator[](int i) {\n        return a[i];\n    }\n    const long long *operator[](int i) const {\n        return a[i];\n    }\n\n    Matrix operator*(const Matrix &rhs) const {\n        Matrix res(n, rhs.m);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) for (int k = 0; k < rhs.m; k++) {\n            res[i][k] += a[i][j] * rhs[j][k] % MOD;\n            res[i][k] >= MOD ? res[i][k] -= MOD : 0;\n        }\n        return res;\n    }\n\n    void print() const {\n        printf(\"Matrix(%d, %d)\\n\", n, m);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) printf(\"%lld%c\", a[i][j], \" \\n\"[j == m - 1]);\n    }\n} T, A;\n\nMatrix pow(Matrix a, long long n) {\n    Matrix res(a.n, a.m, true);\n    for (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n    return res;\n}\n\nvoid pre() {\n    T[0][0] = 3;\n    T[0][1] = 4;\n    T[0][2] = 1;\n    T[1][0] = 2;\n    T[1][1] = 3;\n    T[1][2] = 1;\n    T[2][2] = 1;\n\n    A.m = 1;\n    A[0][0] = A[1][0] = A[2][0] = 1;\n}\n\nint main() {\n    pre();\n\n    int t;\n    scanf(\"%d\", &t);\n    while (t--) {\n        long long n;\n        scanf(\"%lld\", &n);\n\n        Matrix temp = pow(T, n - 1);\n        temp = temp * A;\n\n        printf(\"%lld %lld\\n\", temp[1][0], temp[0][0]);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 12 - E - zx2018 and Treasures<span id = \"12e\"></span>\n\n### 题目大意\n\n给定 $n$ 和函数 $G(s) ~ (s \\in [0, 2^n))$ 的函数值。求\n\n$$\nF(0) \\oplus F(1) \\oplus \\cdots \\oplus F(2^n - 1) \\\\\nF(S) \\sum_{S = S | T} G(T)(|S| - |T| + 1)\n$$\n\n其中 $|$ 表示按位或运算，$|S|$ 表示 $S$ 在二进制表示下 $1$ 的个数。\n\n$0 \\leq n \\leq 18$\n\n$G(s) \\in \\{0, 1\\}$\n\n$1 \\leq T \\leq 20$\n\n### 题解\n\n$F(S) = \\sum G(T)(|S| - |T| + 1) = (|S| + 1)\\sum G(T) - \\sum G(T)|T|$，分别计算 $G(s)$ 和 $G(s)|s|$ 的 $n$ 维前缀和计算即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = (1 << 18) + 5;\n\nint g[MAXN], g2[MAXN], f[MAXN];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        for (int i = 0; i < (1 << n); i++) {\n            scanf(\"%d\", &g[i]);\n            g2[i] = g[i] * __builtin_popcount(i);\n        }\n\n        for (int i = 0; i < n; i++) for (int j = 0; j < (1 << n); j++) if (j & (1 << i)) {\n            g[j] += g[j ^ (1 << i)];\n            g2[j] += g2[j ^ (1 << i)];\n        }\n\n        int ans = 0;\n        for (int i = 0; i < (1 << n); i++) {\n            f[i] = g[i] * (__builtin_popcount(i) + 1) - g2[i];\n            ans ^= f[i];\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 12 - F - zx2018 and sequence<span id = \"12f\"></span>\n\n### 题目大意\n\n一个长为 $n$ 的数列 $\\{a_i\\}$，有 $m$ 次操作。操作有三种：\n\n* 区间按位与上同一个数\n* 区间按位或上同一个数\n* 询问区间最大值\n\n$1 \\leq n, m \\leq 10^5$\n\n$1 \\leq T \\leq 5$\n\n### 题解\n\n用线段树维护数列，当进行区间修改时，直到区间内的数均相同后才开始修改。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int val, max, tag;\n\n        Node(int val = 0) : val(val), max(val), tag(0), lc(NULL), rc(NULL) {}\n        Node(Node *lc, Node *rc) : lc(lc), rc(rc), tag(0) {\n            maintain();\n        }\n\n        void maintain() {\n            val = (lc->val == rc->val ? lc->val : -1);\n            max = std::max(lc->max, rc->max);\n        }\n\n        void add(int d) {\n            tag += d;\n            val += d;\n            max += d;\n        }\n\n        void pushDown() {\n            if (tag) {\n                lc->add(tag);\n                rc->add(tag);\n                tag = 0;\n            }\n        }\n\n        void Add(int l, int r, int L, int R, int d) {\n            if (L > r || l > R) return;\n            if (L <= l && r <= R && val != -1) {\n                int temp = (val & d) - val;\n                add(temp);\n                return;\n            }\n            pushDown();\n            int mid = l + ((r - l) >> 1);\n            lc->Add(l, mid, L, R, d);\n            rc->Add(mid + 1, r, L, R, d);\n            maintain();\n        }\n\n        void Or(int l, int r, int L, int R, int d) {\n            if (L > r || l > R) return;\n            if (L <= l && r <= R && val != -1) {\n                int temp = (val | d) - val;\n                add(temp);\n                return;\n            }\n            pushDown();\n            int mid = l + ((r - l) >> 1);\n            lc->Or(l, mid, L, R, d);\n            rc->Or(mid + 1, r, L, R, d);\n            maintain();\n        }\n\n        int query(int l, int r, int L, int R) {\n            if (L > r || l > R) return 0;\n            if (L <= l && r <= R) return max;\n            pushDown();\n            int mid = l + ((r - l) >> 1);\n            return std::max(lc->query(l, mid, L, R), rc->query(mid + 1, r, L, R));\n        }\n    } *root, _pool[MAXN << 1], *_curr;\n    int n;\n\n    void init() {\n        _curr = _pool;\n    }\n\n    Node *build(int *l, int *r) {\n        if (l == r) return new (_curr++) Node(*l);\n        int *mid = l + ((r - l) >> 1);\n        return new (_curr++) Node(build(l, mid), build(mid + 1, r));\n    }\n\n    void build(int *a, int n) {\n        this->n = n;\n        root = build(a, a + n - 1);\n    }\n\n    void Add(int l, int r, int d) {\n        root->Add(1, n, l, r, d);\n    }\n\n    void Or(int l, int r, int d) {\n        root->Or(1, n, l, r, d);\n    }\n    \n    int query(int l, int r) {\n        return root->query(1, n, l, r);\n    }\n} segT;\n\nint main() {\n    int n, q;\n    while (scanf(\"%d %d\", &n, &q) == 2) {\n        static int a[MAXN];\n        for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n\n        segT.init();\n        segT.build(a, n);\n\n        while (q--) {\n            int op, l, r;\n            scanf(\"%d %d %d\", &op, &l, &r);\n\n            if (op == 1) {\n                int d;\n                scanf(\"%d\", &d);\n                segT.Add(l, r, d);\n            } else if (op == 2) {\n                int d;\n                scanf(\"%d\", &d);\n                segT.Or(l, r, d);\n            } else {\n                int ans = segT.query(l, r);\n                printf(\"%d\\n\", ans);\n            }\n        }\n    }\n    \n    return 0;\n}\n```","tags":["DP","线段树","网络流","最小割","矩阵乘法","ZJU","佩尔方程"],"categories":["题解（OI/XCPC）"]},{"title":"ZJU 七月集训题目选讲（Contest 7 ～ 9）","url":"/ZJU-七月集训题目选讲（Contest-7-～-9）/","content":"\nZJU 七月集训（2018.7.13 ～ 2018.7.26）的题目。\n\n* Contest 7 by SBconscious - 2018.7.20\n* Contest 8 by SBconscious - 2018.7.21\n* Contest 9 by Astolfo - 2018.7.23\n\n所有题目都是多组数据，若无子测试点数的说明，则 $T$ 不会特别大。\n\n## 目录\n\n[Contest 7 - B - Die Wacht am Rhein](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#07b)\n\n[Contest 7 - C - Yet another Chess Puzzle](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#07c)\n\n[Contest 8 - C - Bulbasaur and Prime Game](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#08c)\n\n[Contest 8 - F - Totodile and Graph Theory](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#08f)\n\n[Contest 8 - G - Totodile and Another Data Structure Problem?](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#08g)\n\n[Contest 9 - A - LYK and Heltion's gifts](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#09a)\n\n[Contest 9 - H - LYK and Painting](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-7-%EF%BD%9E-9%EF%BC%89/#09h)\n\n<!--more-->\n\n## Contest 7 - B - Die Wacht am Rhein<span id = \"07b\"></span>\n\n### 题目大意\n\n给定一张 $N$ 个点、$M$ 条边的森林，每个点有一个权值 $a_i$。现要增加若干条边，使得图连通，且满足每个顶点最多连接了一条新边。定义新增一条边 $(i, j)$ 的代价为 $a_i + a_j$，求最小代价，或判断它不可能实现。\n\n$1 \\leq N \\leq 100,000$\n\n$0 \\leq M \\leq N - 1$\n\n$1 \\leq a_i \\leq 10^9$\n\n$\\sum N \\leq 2,500,000$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n如果原图只有一个连通块，则答案为 $0$；否则每个连通块内至少有一个点连接了新边，我们选择连通块内权值最小的点加入答案。\n\n由于输入是一个森林，我们可以知道原图有 $N - M$ 个连通块，连接它们需要 $N - M - 1$ 条边，即 $2(N - M - 1)$ 个点。在每个连通块加入一个点后，仍需要 $N - M - 2$ 个点。我们发现，连边 $(p, q)$ 和 $(s, t)$ 所需的代价等于连边 $(p, t)$ 和 $(s, q)$，即代价与具体连边方式无关。我们把剩下的点的权值按升序排序，取最小的 $N - M - 2$ 个点加入答案即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    bool used, vis;\n    int w;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n}\n\nint min;\nNode *minV;\n\nvoid dfs(Node *u) {\n    u->vis = true;\n    if (!minV || u->w < min) {\n        min = u->w;\n        minV = u;\n    }\n\n    for (Edge *e = u->e; e; e = e->next) if (!e->v->vis) dfs(e->v);\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 0; i < n; i++) {\n        N[i].e = NULL;\n        N[i].used = false;\n        N[i].vis = false;\n    }\n}\n\nint main() {\n    int n, m;\n    while (scanf(\"%d %d\", &n, &m) == 2) {\n        clear(n);\n\n        for (int i = 0; i < n; i++) scanf(\"%d\", &N[i].w);\n\n        for (int i = 0, u, v; i < m; i++) {\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n        }\n\n        int need = n - m - 1;\n        if (n / 2 < need) {\n            puts(\"Impossible\");\n            continue;\n        } else if (need == 0) {\n            puts(\"0\");\n            continue;\n        } else {\n            long long ans = 0;\n            for (int i = 0; i < n; i++) if (!N[i].vis) {\n                minV = NULL;\n                dfs(&N[i]);\n                ans += min;\n                minV->used = true;\n            }\n\n            --need;\n            static std::vector<int> vec;\n            vec.clear();\n            for (int i = 0; i < n; i++) if (!N[i].used) vec.push_back(N[i].w);\n            std::sort(vec.begin(), vec.end());\n\n            for (int i = 0; i < need; i++) ans += vec[i];\n\n            printf(\"%lld\\n\", ans);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 7 - C - Yet another Chess Puzzle<span id = \"07c\"></span>\n\n### 题目大意\n\n给定一个 $n \\times n$ 的网格，保证 $n + 1$ 为质数。在网格内放入 $n$ 个棋子，使它们满足：\n\n* 任意两个棋子不在同一行、列；\n* 不存在两个点对 $(A, B)$ 和 $(C, D)$ （点不完全相同即算数），满足 $|x_A - x_B| = |x_C - x_D|$ 且 $|y_A - y_B| = |y_C - y_D|$。\n\n输出一个满足以上条件的摆放方式。\n\n$2 \\leq n \\leq 5,000 ~ (n + 1 \\text{ is a prime number})$\n\n$1 \\leq T \\leq 1,000$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n我们可以求出 $n + 1$ 的一个原根 $g$，则 $(0, g^0), (1, g^1), \\dots, (n - 1, g^{n - 1})$ 即是答案。\n\n第一个限制显然满足了，下证其满足第二个限制：\n\n假设存在两个点对不满足限制二，则有：\n\n$$\n\\begin{align}\ng^{x_2} - g^{x_1} &\\equiv g^{x_4} - g^{x_3} (\\bmod n + 1) \\\\\ng^{x_1 + dx} - g^{x_1} &\\equiv g^{x_3 + dx} - g^{x_3} (\\bmod n + 1) \\\\\ng^{x_1}(g^{dx} - 1) &\\equiv g^{x_3}(g^{dx} - 1) (\\bmod n + 1) \\\\\ng^{x_1} &\\equiv g^{x_3} (\\bmod n + 1)\n\\end{align}\n$$\n\n与原根的性质不符。\n\n### 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 5005;\n\nint prime[MAXN], primeCnt;\n\nvoid sieve() {\n    static bool notPrime[MAXN];\n    notPrime[0] = notPrime[1] = true;\n    primeCnt = 0;\n\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) prime[primeCnt++] = i;\n\n        for (int j = 0; j < primeCnt && i * prime[j] < MAXN; j++)\n            notPrime[i * prime[j]] = true;\n    }\n}\n\nint pow(int a, int n, int p) {\n    int res = 1;\n    for (; n; n >>= 1, a = a * a % p) if (n & 1) res = res * a % p;\n    return res;\n}\n\nint getRoot(int p) {\n    for (int g = 2, pp = p - 1; ; g++) {\n        bool flag = true;\n        for (int i = 0; i < primeCnt && prime[i] < p; i++) {\n            if (pp % prime[i] == 0 && pow(g, pp / prime[i], p) == 1) {\n                flag = false;\n                break;\n            }\n        }\n\n        if (flag) return g;\n    }\n}\n\nint main() {\n    sieve();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int g = getRoot(n + 1), k = 1;\n        for (int i = 0; i < n; i++) {\n            k = k * g % (n + 1);\n            printf(\"%d%c\", k, \" \\n\"[i == n - 1]);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 8 - C - Bulbasaur and Prime Game<span id = \"08c\"></span>\n\n### 题目大意\n\n有 $n$ 个数 $\\{a_i\\}$ 。两个人进行游戏：当上一个被取走的数为 $a_x$ 时，该行动的一方可以从这 $n$ 个数中选取一个数 $a_y$，满足 $a_x + a_y$ 是一个质数；起初 $a_x = 0$；一方不能行动时另一方获胜。求必胜方。\n\n$1 \\leq n \\leq 1,000$\n\n$2 \\leq a_i \\leq 10^9$\n\n$\\sum n \\leq 5,000$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n对于每一对满足 $a_x + a_y$ 为质数的数对，建一条边 $(x, y)$，则可以得到一个二分图。则问题转换为一个[二分图游戏](http://cogs.pro:8080/cogs/problem/problem.php?pid=1720)。建图跑一遍网络流/匈牙利并判断即可。\n\n对于判质数，我们可以预处理一定范围内的质数，或用 Pollard's Rho。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 1005;\nconst int MAXM = 300005;\nconst int M = 100000;\n\nint prime[M], primeCnt;\nbool notPrime[M];\n\nvoid init() {\n    notPrime[0] = notPrime[1] = true;\n    primeCnt = 0;\n    for (int i = 2; i < M; i++) {\n        if (!notPrime[i]) prime[primeCnt++] = i;\n        for (int j = 0; j < primeCnt && i * prime[j] < M; j++) notPrime[i * prime[j]] = true;\n    }\n}\n\nbool isPrime(int x) {\n    if (x < M) return !notPrime[x];\n\n    bool res = true;\n    for (int i = 0; i < primeCnt && (long long) prime[i] * prime[i] <= x; i++) if (x % prime[i] == 0) {\n        res = false;\n        break;\n    }\n\n    return res;\n}\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *curr;\n    int level;\n    bool canS, canT;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n\n    Edge() {}\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n} _pool[MAXM << 1], *_curr;\n\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v], cap);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\n\nnamespace Dinic {\nbool level(Node *s, Node *t, int n) {\n    for (int i = 0; i < n; i++) N[i].level = 0;\n\n    static std::queue<Node *> q;\n    while (!q.empty()) q.pop();\n    q.push(s);\n    s->level = 1;\n\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n\n        for (Edge *e = u->e; e; e = e->next) if (e->cap > e->flow && !e->v->level) {\n            e->v->level = u->level + 1;\n            if (e->v == t) return true;\n            q.push(e->v);\n        }\n    }\n\n    return false;\n}\n\nint findPath(Node *u, Node *t, int limit = INT_MAX) {\n    if (u == t) return limit;\n\n    for (Edge *&e = u->curr; e; e = e->next) if (e->cap > e->flow && e->v->level == u->level + 1) {\n        int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n        if (flow > 0) {\n            e->flow += flow;\n            e->rev->flow -= flow;\n            return flow;\n        }\n    }\n\n    return 0;\n}\n\nint solve(int s, int t, int n) {\n    int res = 0;\n    while (level(&N[s], &N[t], n)) {\n        for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n        int flow;\n        while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n    }\n    return res;\n}\n} // namespace Dinic\n\nvoid bfs(int s, int t) {\n    static std::queue<Node *> q;\n\n    q.push(&N[s]);\n    N[s].canS = true;\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n\n        for (Edge *e = u->e; e; e = e->next) if (e->cap > e->flow && !e->v->canS) {\n            e->v->canS = true;\n            q.push(e->v);\n        }\n    }\n\n    q.push(&N[t]);\n    N[t].canT = true;\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n\n        for (Edge *e = u->e; e; e = e->next) if (e->rev->cap > e->rev->flow && !e->v->canT) {\n            e->v->canT = true;\n            q.push(e->v);\n        }\n    }\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 0; i < n; i++) {\n        N[i].e = NULL;\n        N[i].canS = N[i].canT = false;\n    }\n}\n\nint main() {\n    init();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n\n        int odd = 0, even = 0;\n        static int w[2][MAXN];\n        for (int i = 0, x; i < n; i++) {\n            scanf(\"%d\", &x);\n\n            if (x % 2) w[1][++odd] = x;\n            else w[0][++even] = x;\n        }\n\n        int s = 0, t = odd + even + 1;\n        n = odd + even + 2;\n        clear(n);\n\n        for (int i = 1; i <= odd; i++) addEdge(s, i, 1);\n        for (int i = 1; i <= even; i++) addEdge(i + odd, t, 1);\n        for (int i = 1; i <= odd; i++) for (int j = 1; j <= even; j++) if (isPrime(w[1][i] + w[0][j]))\n            addEdge(i, j + odd, 1);\n\n        Dinic::solve(s, t, n);\n\n        bfs(s, t);\n\n        bool flag = false;\n        for (int i = 1; i <= odd; i++) if (N[i].canS && isPrime(w[1][i])) {\n            flag = true;\n            break;\n        }\n        for (int i = 1; i <= even; i++) if (N[i + odd].canT && isPrime(w[0][i])) {\n            flag = true;\n            break;\n        }\n\n        puts(flag ? \"Bulbasaur\" : \"Totodile\");\n    }\n    \n    return 0;\n}\n```\n\n## Contest 8 - F - Totodile and Graph Theory<span id = \"08f\"></span>\n\n### 题目大意\n\n给定一张 $n$ 个点、$m$ 条边的图和一个数 $K$。要求给图进行 $K$ 染色，或输出一条长为 $K$ 的简单路径，或判断以上两问均无法实现。\n\n$2 \\leq n \\leq 100,000$\n\n$0 \\leq m \\leq \\min(\\frac{n(n - 1)}{2}, 100,000)$\n\n$2 \\leq K \\leq n$\n\n$\\sum n, \\sum m \\leq 1,000,000$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n随便选取一个点作为起点进行 dfs。若最深深度大于等于 $K$，则一定存在一条长度为 $K$ 的路径；否则为深度相同的点染相同的色、不同的点染不同的色，由于 dfs 树的性质，不存在一条非树边连接两个深度相同的点，即一定可以 $K$ 染色。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e, *pre;\n    int dep;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n}\n\nvoid dfs(Node *u) {\n    for (Edge *e = u->e; e; e = e->next) if (!e->v->dep) {\n        e->v->pre = e;\n        e->v->dep = u->dep + 1;\n        dfs(e->v);\n    }\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) {\n        N[i].e = N[i].pre = NULL;\n        N[i].dep = 0;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m, k;\n        scanf(\"%d %d %d\", &n, &m, &k);\n        clear(n);\n\n        for (int i = 0, u, v; i < m; i++) {\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n        }\n\n        for (int i = 1; i <= n; i++) if (!N[i].dep) {\n            N[i].dep = 1;\n            dfs(&N[i]);\n        }\n\n        Node *max = NULL;\n        for (int i = 1; i <= n; i++) if (!max || N[i].dep > max->dep) max = &N[i];\n\n        if (max->dep >= k) {\n            printf(\"2\\n%d\", max - N);\n            int cnt = 1;\n            for (Edge *e = max->pre; e, cnt < k; e = e->u->pre, cnt++) printf(\" %d\", e->u - N);\n            puts(\"\");\n        } else {\n            puts(\"1\");\n            for (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].dep, \" \\n\"[i == n]);\n        }\n    }\n    return 0;\n}\n```\n\n## Contest 8 - G - Totodile and Another Data Structure Problem?<span id = \"08g\"></span>\n\n### 题目大意\n\n给定一个长为 $n$ 的序列 $\\{a_i\\} ~ (a_i \\in \\{1, 2\\})$。定义一个数 $g$ 是好的，当且仅当存在区间 $[l, r]$ 满足 $\\sum_{i = l}^{r} a_i = g$。求所有不超过 $k$ 的好数的异或和。\n\n$1 \\leq n \\leq 100,000$\n\n$1 \\leq k \\leq 10^9$\n\n$\\sum n \\leq 1,000,000$\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n可以证明，一个至少有一端为 $1$ 的序列的好数为 $[1, \\sum a_i]$ 内的所有整数（称这种序列为好序列）。对于两端均为 $2$ 的序列，可以拆成一段连续的 $2$ 和一个好序列 $\\{b_i\\}$。枚举 $2$ 的个数 $k$，则 $2k + \\sum b_i$ 为好数。最后直接计算异或和即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nint sum[MAXN], pre[MAXN], a[MAXN], sor[MAXN << 1];\n\nvoid init() {\n    for (int i = 1; i < MAXN << 1; i++) sor[i] = sor[i - 1] ^ i;\n}\n\nint main() {\n    init();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n        sum[0] = pre[n + 1] = 0;\n        for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];\n        for (int i = n; i; i--) pre[i] = pre[i + 1] + a[i];\n        k = std::min(k, sum[n]);\n\n        if (!(a[1] == a[n] && a[1] == 2)) {\n            printf(\"%d\\n\", sor[k]);\n            continue;\n        }\n\n        int left = -1, right = -1;\n        for (int i = 1; i <= n; i++) if (a[i] == 1) {\n            left = i - 1;\n            break;\n        }\n        if (left == -1) left = n;\n        for (int i = n; i; i--) if (a[i] == 1) {\n            right = i + 1;\n            break;\n        }\n        if (right == -1) right = 1;\n\n        int lc = left, rc = n - right + 1, S;\n        if (lc < rc) S = pre[left + 1];\n        else S = sum[right - 1];\n        int ans = sor[std::min(S, k)];\n        for (int i = 1; i <= std::min(lc, rc); i++) {\n            if (S + 2 * i <= k) ans ^= (S + 2 * i);\n            else break;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```\n\n## Contest 9 - A - LYK and Heltion's gifts<span id = \"09a\"></span>\n\n### 题目大意\n\n用两种颜色染一个有 $n$ 个珠子的首饰，要求不能有相邻的黑色珠子，求可能的染色方案数，旋转相同视为同一种，答案对 $1,000,000,007$ 取模。\n\n$2 \\leq n \\leq 10^6$\n\n$1 \\leq T \\leq 1,000$\n\n时间限制：$2 \\text{s}$，内存限制：$512 \\text{MB}$。\n\n### 题解\n\n旋转同构用 Burnside 引理处理。对于不考虑旋转时的答案（记为 $f(n)$）可以发现是：\n\n$$\n\\begin{align}\nf(2) &= 3 \\\\\nf(3) &= 4 \\\\\nf(n) &= f(n - 1) + f(n - 2)\n\\end{align}\n$$\n\n### 代码\n\n```c++\n#include <cstdio>\n\nconst int MAXN = 1000005;\nconst int MOD = 1000000007;\n\nint phi[MAXN], prime[MAXN], primeCnt;\n\nvoid sieve() {\n    static bool notPrime[MAXN];\n    notPrime[0] = notPrime[1] = true;\n    primeCnt = 0;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[primeCnt++] = i;\n            phi[i] = i - 1;\n        }\n\n        for (int j = 0; j < primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            }\n            phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n        }\n    }\n}\n\nlong long f[MAXN], inv[MAXN];\n\nvoid pre() {\n    sieve();\n\n    f[1] = 1;\n    f[2] = 3;\n    f[3] = 4;\n    for (int i = 4; i < MAXN; i++) {\n        f[i] = f[i - 1] + f[i - 2];\n        f[i] >= MOD ? f[i] -= MOD : 0;\n    }\n\n    inv[1] = 1;\n    for (int i = 2; i < MAXN; i++) inv[i] = (MOD - MOD / i) * inv[MOD % i] % MOD;\n}\n\nlong long calc(int n) {\n    int x = n;\n    long long res = f[n] + phi[n] * f[1] % MOD;\n    res >= MOD ? res -= MOD : 0;\n    for (int i = 2; i <= n / 2; i++) if (n % i == 0) {\n        int t = phi[n / i];\n        res += f[i] * t % MOD;\n        res >= MOD ? res -= MOD : 0;\n    }\n    res = res * inv[n] % MOD;\n    return res;\n}\n\nint main() {\n    pre();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        \n        long long ans = calc(n);\n        printf(\"%lld\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 9 - H - LYK and Painting<span id = \"09h\"></span>\n\n### 题目大意\n\n长为 $N$ 的序列上，每次可以让一段长为 $K$ 的子区间染成同一种颜色（可覆盖），一共有 $M$ 种颜色。最终使得每个位置上都有颜色，求能得到的最终序列的种数，答案对 $1,000,000,007$ 取模。\n\n$1 \\leq N \\leq 2^{31} - 1$\n\n$1 \\leq M \\leq 100,000$\n\n$1 \\leq K \\leq 100$\n\n$1 \\leq T \\leq 10$，大测试点不超过 $3$ 个。\n\n时间限制：$2 \\text{s}$，内存限制：$512 \\text{MB}$。\n\n### 题解\n\n最终的序列中，必有一段长度至少为 $K$ 的子区间上颜色相同。由于 $N$ 太大，我们可以考虑用 $M^N$ 减去不存在这样子区间的种数。记 $f(n)$ 为长为 $n$ 的、不存在这样子区间的种数，则转移为：\n\n$$\nf(n) = \\begin{cases}\nM^n &1 \\leq n < M \\\\\n(M - 1) \\sum_{i = 1}^{K - 1} f(n - 1) &n \\geq M\n\\end{cases}\n$$\n\n用矩阵乘法快速幂优化即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXK = 105;\nconst int MOD = 1000000007;\n\nstruct Matrix {\n    long long a[MAXK][MAXK];\n    int n, m;\n\n    Matrix(int n, int m, bool eye = false) : n(n), m(m) {\n        for (int i = 0; i < n; i++) std::fill(a[i], a[i] + m, 0);\n        if (eye) for (int i = 0; i < n; i++) a[i][i] = 1;\n    }\n\n    long long *operator[](int index) {\n        return a[index];\n    }\n    const long long *operator[](int index) const {\n        return a[index];\n    }\n\n    Matrix operator*(const Matrix &rhs) const {\n        Matrix res(n, rhs.m);\n        for (int i = 0; i < n; i++) for (int j = 0; j < m; j++) if (a[i][j]) {\n            for (int k = 0; k < rhs.m; k++) {\n                res[i][k] += a[i][j] * rhs[j][k] % MOD;\n                res[i][k] >= MOD ? res[i][k] -= MOD : 0;\n            }\n        }\n        return res;\n    }\n};\n\nMatrix pow(Matrix &a, long long n) {\n    Matrix res(a.n, a.m, true);\n    for (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n    return res;\n}\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nint main() {\n    int n, m, k;\n    while (scanf(\"%d %d %d\", &n, &m, &k) == 3) {\n        long long ans = qpow(m, n);\n\n        if (n < k) {\n            puts(\"0\");\n            continue;\n        }\n\n        Matrix A(k - 1, 1);\n        for (int i = 0; i < k - 1; i++) A[i][0] = qpow(m, k - i - 1);\n\n        Matrix T(k - 1, k - 1);\n        for (int i = 0; i < k - 1; i++) {\n            T[0][i] = m - 1;\n            i < k - 2 ? T[i + 1][i] = 1 : 0;\n        }\n\n        Matrix temp = pow(T, n - k + 1);\n        temp = temp * A;\n\n        ans = (ans - temp[0][0] + MOD) % MOD;\n        printf(\"%lld\\n\", ans);\n    }\n    \n    return 0;\n}\n```","tags":["DP","网络流","贪心","矩阵乘法","博弈","ZJU","原根","Burnside","二分图博弈"],"categories":["题解（OI/XCPC）"]},{"title":"ZJU 七月集训题目选讲（Contest 4 ～ 6）","url":"/ZJU-七月集训题目选讲（Contest-4-～-6）/","content":"\nZJU 七月集训（2018.7.13 ～ 2018.7.26）的题目。\n\n* Contest 4 by ChugJug - 2018.7.16\n* Contest 5 by DeepDark - 2018.7.17\n* Contest 6 by SBconscious - 2018.7.19\n\n所有题目都是多组数据，若无子测试点数的说明，则 $T$ 不会特别大。\n\n## 目录\n\n[Contest 4 - B - Positive Eigenvalues](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#04b)\n\n[Contest 4 - C - String Set](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#04c)\n\n[Contest 4 - E - Candies](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#04e)\n\n[Contest 5 - B - MUJI](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#05b)\n\n[Contest 5 - C - Magical Tree](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#05c)\n\n[Contest 5 - F - Simple Counting](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#05f)\n\n[Contest 6 - A - SmartLy's Game](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#06a)\n\n[Contest 6 - E - Heltion and Sequence](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#06e)\n\n[Contest 6 - G - Heltion and Backpack](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-4-%EF%BD%9E-6%EF%BC%89/#06g)\n\n<!--more-->\n\n## Contest 4 - B - Positive Eigenvalues<span id = \"04b\"></span>\n\n### 题目大意\n\n给出一个 $n \\times n$ 的 $01$ 矩阵，判断其是否为正定矩阵。\n\n$1 \\leq n \\leq 50$\n\n$1 \\leq T \\leq 1,000$，$n \\geq 10$ 的子测试点不超过 $10$ 个。\n\n时间限制：$1 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n$$\n\\begin{align}\n&\\because \\lambda_i > 0 ~ (1 \\leq i \\leq n) \\\\\n&\\therefore \\det(\\textbf{A}) = \\prod_{i = 1}^{n} \\lambda_i > 0 \\\\\n&\\because \\prod_{i = 1}^{n} \\lambda_i \\leq (\\frac{\\sum_{i = 1}^{n} \\lambda_i}{n})^n = (\\frac{\\sum_{i = 1}^{n} \\textbf{A}_{i, i}}{n})^n \\leq 1 ~ (\\textbf{A}_{i, i} \\text { is either } 1 \\text{ or } 0) \\\\\n&\\therefore \\det(\\textbf{A}) = 1 \\\\\n&\\therefore \\lambda_i = 1 ~ (1 \\leq i \\leq n), \\textbf{A}_{i, i} = 1 ~ (1 \\leq i \\leq n)\n\\end{align}\n$$\n\n根据行列式计算的定义式，我们知道，矩阵 $\\textbf{A}$ 的除主对角线外其他 $1 \\sim n$ 的置换上的位置的值不全为 $1$。即，以该矩阵为某一有向图的邻接矩阵，该有向图无环（自环除外）。判断主对角线上是否全为 $1$ ，然后建图跑拓扑排序判断是否存在环即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n\nconst int MAXN = 55;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    int deg;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN * MAXN], *_curr;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    ++N[v].deg;\n}\n\nbool topo(int n) {\n    static std::stack<Node *> s;\n\n    for (int i = 1; i <= n; i++) if (!N[i].deg) s.push(&N[i]);\n    while (!s.empty()) {\n        Node *u = s.top();\n        s.pop();\n\n        for (Edge *e = u->e; e; e = e->next) if (!(--e->v->deg)) s.push(e->v);\n    }\n\n    for (int i = 1; i <= n; i++) if (N[i].deg) return false;\n    return true;\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) {\n        N[i].e = NULL;\n        N[i].deg = 0;\n    }\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        clear(n);\n\n        bool flag = true;\n        for (int i = 1, x; i <= n; i++) for (int j = 1; j <= n; j++) {\n            scanf(\"%d\", &x);\n            if (i != j && x) addEdge(i, j);\n            if (i == j && !x) flag = false;\n        }\n\n        if (flag) flag = topo(n);\n\n        puts(flag ? \"YES\" : \"NO\");\n    }\n    \n    return 0;\n}\n```\n\n## Contest 4 - C - String Set<span id = \"04c\"></span>\n\n### 题目大意\n\n给出一个字符串的可重集合 $A$（初始为空），定义一个字符串的最长匹配前缀长度（MMPL）为：\n$$\n\\text{MMPL}(S) = \\max(|T|, T \\in A \\text{ and } T \\text{ is a prefix of } S)\n$$\n有 $n$ 次操作，每次操作向 $A$ 中放入一个字符串 $s$，或删除一个已有的字符串。有 $m$ 次询问。每次询问一个字符串 $S$ 在操作区间 $[l, r]$ 内 $\\text{MMPL}(S)$ 变化了几次（操作从头开始，但只在询问区间计数）。\n\n所有字符串为 $01$ 串。\n\n$1 \\leq n, m \\leq 10^5$\n\n$1 \\leq |s| \\leq 32, |S| = 32$\n\n$1 \\leq T \\leq 10$，大测试点的数目不会超过 $4$。\n\n时间限制：$2 \\text{s}$，内存限制：$1024 \\text{MB}$。\n\n### 题解\n\n离线所有的操作与查询（拆为两个）并按时间排序。建立一个 Trie。\n\n插入时直接插入，给其单词计数器值加 $1$。如果是第一次插入该字符串，打一个 $-1$ 的 tag，给其贡献计数器值加 $1$。\n\n删除入沿 Trie 走到末尾节点，给其单词计数器值减 $1$。如果此时计数器为 $0$，打一个 $-1$ 的tag，给其贡献计数器加 $1$。\n\n查询时沿 Trie 走，累加贡献计数器的值即可。\n\n传递标记时：如果其无子节点，不传递；如果子节点的单词计数器为 $0$，将 tag 的值加给子节点的 tag；如果子节点的单词计数器不为 $0$，将 tag 的值加给子节点的贡献计数器。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int N = 33;\nconst int MAXN = 100005;\n\ntemplate <typename T, size_t SIZE>\nstruct Pool {\n    char mem[SIZE * sizeof (T)], *top;\n\n    void init() {\n        top = mem;\n    }\n\n    void *alloc() {\n        char *res = top;\n        top += sizeof (T);\n        return (void *) res;\n    }\n};\n\nstruct Trie {\n    static const int MAXN = ::MAXN << 1;\n\n    struct Node {\n        Node *c[2];\n        int val, tag, cnt;\n        static Pool<Node, MAXN> pool;\n\n        Node() : val(0), tag(0), cnt(0) {\n            c[0] = c[1] = NULL;\n        }\n\n        void *operator new(size_t) {\n            return pool.alloc();\n        }\n\n        void pushDown() {\n            if (tag) {\n                if (c[0]) {\n                    if (c[0]->cnt) c[0]->val += tag;\n                    else c[0]->tag += tag;\n                }\n                if (c[1]) {\n                    if (c[1]->cnt) c[1]->val += tag;\n                    else c[1]->tag += tag;\n                }\n                tag = 0;\n            }\n        }\n\n        void insert(char *l, char *r) {\n            pushDown();\n            if (l == r) {\n                if (!cnt) {\n                    ++val;\n                    tag = -1;\n                }\n                ++cnt;\n                return;\n            }\n            int L = *(l++) - '0';\n            if (!c[L]) c[L] = new Node();\n            c[L]->insert(l, r);\n        }\n\n        void erase(char *l, char *r) {\n            pushDown();\n            if (l == r) {\n                --cnt;\n                if (!cnt) {\n                    ++val;\n                    tag = -1;\n                }\n                return;\n            }\n            int L = *(l++) - '0';\n            if (!c[L]) return;\n            c[L]->erase(l, r);\n        }\n\n        void check(char *l, char *r, int &ans) {\n            pushDown();\n            ans += val;\n            if (l == r) return;\n            int L = *(l++) - '0';\n            if (!c[L]) return;\n            c[L]->check(l, r, ans);\n        }\n    } *root;\n\n    void init() {\n        root = new Node();\n    }\n\n    void insert(char *l, char *r) {\n        root->insert(l, r);\n    }\n\n    void erase(char *l, char *r) {\n        root->erase(l, r);\n    }\n\n    int check(char *l, char *r) {\n        int res = 0;\n        root->check(l, r, res);\n        return res;\n    }\n} trie;\nPool<Trie::Node, Trie::MAXN> Trie::Node::pool;\n\nstruct Operation {\n    int op, pos, len, ans, id;\n    char s[N];\n\n    Operation() {}\n    Operation(int id, int op, int pos, char s[N]) : id(id), op(op), pos(pos), ans(0) {\n        len = strlen(s);\n        std::copy(s, s + len, this->s);\n    }\n} O[MAXN * 3];\n\nbool compareByPos(const Operation &a, const Operation &b) {\n    return a.pos == b.pos ? a.op < b.op : a.pos < b.pos;\n}\nbool compareById(const Operation &a, const Operation &b) {\n    return a.id == b.id ? a.pos < b.pos : a.id < b.id;\n}\n\nvoid init() {\n    Trie::Node::pool.init();\n    trie.init();\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        init();\n\n        int n, q;\n        scanf(\"%d %d\", &n, &q);\n        for (int i = 0; i < n; i++) {\n            static char op[2];\n            scanf(\"%s %s\", op, O[i].s);\n            O[i].op = (op[0] == '+' ? 0 : 1);\n            O[i].pos = i + 1;\n            O[i].id = q;\n            O[i].len = strlen(O[i].s);\n        }\n        for (int i = 0, l, r; i < q; i++) {\n            static char s[N];\n            scanf(\"%s %d %d\", s, &l, &r);\n            O[i + n] = Operation(i, 2, r, s);\n            O[i + n + q] = Operation(i, 2, l - 1, s);\n        }\n\n        int N = n + q * 2;\n        std::sort(O, O + N, compareByPos);\n\n        for (int i = 0; i < N; i++) {\n            if (O[i].op == 0) {\n                trie.insert(O[i].s, O[i].s + O[i].len);\n            } else if (O[i].op == 1) {\n                trie.erase(O[i].s, O[i].s + O[i].len);\n            } else {\n                O[i].ans = trie.check(O[i].s, O[i].s + O[i].len);\n            }\n        }\n\n        std::sort(O, O + N, compareById);\n        for (int i = 0; i < 2 * q; i += 2) {\n            int ans = O[i + 1].ans - O[i].ans;\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 4 - E - Candies<span id = \"04e\"></span>\n\n### 题目大意\n\nAlice 和 Bob 分 $n$ 支蜡烛，每只蜡烛有一个价值 $w_i$。两人分得的蜡烛数目应尽量相等，在此基础上，两人分得的蜡烛的价值和应尽量相等。若无法让二人的蜡烛价值和相等，Alice 分得的蜡烛价值和应小于 Bob 的。求二人分得的蜡烛价值和。\n\n$1 \\leq n \\leq 100$\n\n$\\sum_{i = 1}^{n} w_i \\leq 100,000$\n\n$1 \\leq T \\leq 100$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n$f(i, j)$ 表示数 $i$ 是否可有 $j$ 个数拼成，第二维可用一个 `long long` 或 `std::bitset` 储存，则转移为： `f[i] |= (f[i - w[i]] << 1)`。\n\n计算答案时从 $\\sum w_i / 2$ 开始向下枚举，判断是否能由一半的 $n$ 的个数（$n$ 为奇数时要判断两个）的数拼成即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 105;\nconst int MAX_SUM = 100005;\n\nlong long f[MAX_SUM];\nint w[MAXN];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int kase = 1; kase <= T; kase++) {\n        int n, sum = 0;\n        scanf(\"%d\", &n);\n\n        std::fill(f, f + MAX_SUM, 0);\n        f[0] = 1;\n        for (int i = 0, x; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n            sum += w[i];\n        }\n\n        for (int i = 0; i < n; i++) for (int j = sum >> 1; j >= w[i]; j--)\n            f[j] |= (f[j - w[i]] << 1);\n\n        long long a = (1ll << ((n + 1) >> 1ll)), b = (1ll << (n >> 1ll));\n        for (int i = sum >> 1; i; i--) if ((f[i] & a) || (f[i] & b)) {\n            printf(\"Case %d: %d %d\\n\", kase, i, sum - i);\n            break;\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 5 - B - MUJI<span id = \"05b\"></span>\n\n### 题目大意\n\n给定一棵 $n$ 个点的树，每个点上有一个权值 $v_i$。有 $q$ 次询问，每次询问两个点，从一个点开始，沿它们间的简单路径走到另一个点，每到一个点（含端点），就可以选择获得或失去 $kv_i$ 个物品（$k \\in \\mathbb{N}$，自行选择），求最终所持有物品的正最小值。\n\n$1 \\leq n, q \\leq 200,000$\n\n$1 \\leq T \\leq 10$，大测试点不超过 $3$ 个。\n\n时间限制：$2 \\text{s}$，内存限制：$128 \\text{MB}$。\n\n### 题解\n\n由裴蜀定理，答案即路径上顶点权值的最大公约数，树上倍增即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 200005;\nconst int MAXN_LOG = 18;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    Node *f[MAXN_LOG];\n    int dep, w, gcd[MAXN_LOG];\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e)  {}\n} _pool[MAXN << 1], *_curr;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n}\n\nvoid dfs(Node *u, Node *fa = NULL) {\n    u->dep = (fa ? fa->dep : 0) + 1;\n    u->f[0] = (fa ? fa : u);\n    u->gcd[0] = (fa ? std::__gcd(u->w, fa->w) : u->w);\n\n    for (int i = 1; i < MAXN_LOG; i++) {\n        u->f[i] = u->f[i - 1]->f[i - 1];\n        u->gcd[i] = std::__gcd(u->gcd[i - 1], u->f[i - 1]->gcd[i - 1]);\n    }\n\n    for (Edge *e = u->e; e; e = e->next) if (e->v != fa) dfs(e->v, u);\n}\n\nint lca(Node *u, Node *v) {\n    int res = std::__gcd(u->w, v->w);\n    if (u->dep < v->dep) std::swap(u, v);\n\n    for (int i = MAXN_LOG - 1; ~i; i--) if (u->f[i]->dep >= v->dep) {\n        res = std::__gcd(res, u->gcd[i]);\n        u = u->f[i];\n    }\n\n    for (int i = MAXN_LOG - 1; ~i; i--) if (u->f[i] != v->f[i]) {\n        res = std::__gcd(res, std::__gcd(u->gcd[i], v->gcd[i]));\n        u = u->f[i];\n        v = v->f[i];\n    }\n\n    if (u != v) res = std::__gcd(res, u->gcd[0]);\n    return res;\n}\n\nvoid clear(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) N[i].e = NULL;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        clear(n);\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].w);\n\n        for (int i = 1, u, v; i < n; i++) {\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n        }\n\n        dfs(&N[1]);\n\n        int q;\n        scanf(\"%d\", &q);\n        while (q--) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            int ans = lca(&N[x], &N[y]);\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 5 - C - Magical Tree<span id = \"05c\"></span>\n\n### 题目大意\n\n给定一棵 $n$ 个点的树，每个点是黑色或白色，每条边有一个权值 $c_i$。要求删去权值和最小的边集使得每一个连痛快内最多有一个黑点。同时有 $m$ 次操作，每次操作会把一个点变为黑点（该点原来可能为黑点）。求操作前以及每次操作后，需要删去的边集的最小权值和。\n\n$1 \\leq n, m \\leq 100,000$\n\n$1 \\leq c_i \\leq 1,000$\n\n$1 \\leq T \\leq 10$\n\n时间限制：$2 \\text{s}$，空间限制：$64 \\text{MB}$。\n\n### 题解\n\n考虑把操作倒过来，即把黑点变为白点，则每次需要恢复一条与该点所在连通块相连的、权值最小的边。一开始让所有的点为黑点，即所有的边都删去，为每一个连通块维护一个可并堆（小根堆），在恢复边时，选择堆顶的边，并弹出、标记这条边，将被合并的两个连通块的可并堆合并。连通块可用并查集维护。注意处理改变前后颜色不变的情况。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <ext/pb_ds/priority_queue.hpp>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct UFS {\n    int f[MAXN];\n\n    void init(int n) {\n        for (int i = 1; i <= n; i++) f[i] = i;\n    }\n\n    int find(int x) {\n        return x == f[x] ? x : f[x] = find(f[x]);\n    }\n\n    void merge(int x, int y) {\n        f[find(y)] = find(x);\n    }\n} ufs;\n\nstruct Node {\n    int c;\n    __gnu_pbds::priority_queue<std::pair<int, int> > q;\n} N[MAXN];\n\nstruct Edge {\n    int u, v, w;\n    bool used;\n} E[MAXN];\n\nstruct Operation {\n    int x, ans;\n    bool exist;\n} O[MAXN];\n\nvoid clear(int n) {\n    for (int i = 1; i <= n; i++)\n        N[i].q.clear();\n\n    ufs.init(n);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        clear(n);\n\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].c);\n\n        int sum = 0;\n        for (int i = 1; i < n; i++) {\n            scanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w);\n            sum += E[i].w;\n            N[E[i].u].q.push(std::make_pair(E[i].w, i));\n            N[E[i].v].q.push(std::make_pair(E[i].w, i));\n            E[i].used = false;\n        }\n\n        int q;\n        scanf(\"%d\", &q);\n        for (int i = 1; i <= q; i++) {\n            scanf(\"%d\", &O[i].x);\n            if (N[O[i].x].c == 1) {\n                O[i].exist = true;\n            } else {\n                O[i].exist = false;\n                N[O[i].x].c = 1;\n            }\n        }\n\n        for (int i = 1; i <= n; i++) if (!N[i].c) {\n            int x = ufs.find(i);\n\n            while (N[x].q.size() && E[N[x].q.top().second].used) N[x].q.pop();\n            if (N[x].q.empty()) continue;\n            auto e = N[x].q.top();\n            sum -= e.first;\n            N[x].q.pop();\n            E[e.second].used = true;\n\n            int y = (ufs.find(E[e.second].u) == x ? ufs.find(E[e.second].v) : ufs.find(E[e.second].u));\n            ufs.merge(x, y);\n            N[x].q.join(N[y].q);\n        }\n\n        for (int i = q; i; i--) if (!O[i].exist) {\n            O[i].ans = sum;\n\n            int x = ufs.find(O[i].x);\n\n            while (N[x].q.size() && E[N[x].q.top().second].used) N[x].q.pop();\n            if (N[x].q.empty()) continue;\n            auto e = N[x].q.top();\n            sum -= e.first;\n            N[x].q.pop();\n            E[e.second].used = true;\n\n            int y = (ufs.find(E[e.second].u) == x ? ufs.find(E[e.second].v) : ufs.find(E[e.second].u));\n            ufs.merge(x, y);\n            N[x].q.join(N[y].q);\n        }\n\n        printf(\"%d\\n\", O[0].ans = sum);\n        for (int i = 1; i <= q; i++) {\n            // printf(\"i = %d, i.before = %d\\n\", i, O[i].before);\n            printf(\"%d\\n\", O[i].exist ? (O[i].ans = O[i - 1].ans) : O[i].ans);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 5 - F - Simple Counting<span id = \"05f\"></span>\n\n### 题目大意\n\n求有多少个 $X$ 满足：\n$$\n\\lfloor \\sqrt[K]{X} \\rfloor \\;|\\; X ~ (X \\in [1, N], X \\in \\mathbb{Z})\n$$\n其中 $a | b$ 表示 $b$ 是 $a$ 的倍数。\n\n$1 \\leq N \\leq 2^{31} - 1$\n\n$2 \\leq K \\leq 4$\n\n$1 \\leq T \\leq 1,000,000$\n\n时间限制：$2 \\text{s}$，空间限制：$64 \\text{MB}$。\n\n### 题解\n\n$[x^K, (x + 1)^K)$ 内的数的 $K$ 次根号的值均为 $x$，该区间内合法的数的个数为：\n$$\n\\frac{(x + 1)^K - x^K - 1}{x} + 1\n$$\n按 $K$ 分类手推式子，对于最后一个不完整的区间单独考虑即可。\n\n```c++\n#include <cstdio>\n#include <cmath>\n\nint main() {\n    int n, k;\n    while (scanf(\"%d %d\", &n, &k) == 2) {\n        if (k == 2) {\n            long long t = pow(n, 0.5);\n            if ((t + 1) * (t + 1) <= n) ++t;\n            long long ans = 2 * (t - 1) + n / t;\n            printf(\"%d\\n\", ans);\n        } else if (k == 3) {\n            long long t = pow(n, 1.0 / 3.0);\n            if ((t + 1) * (t + 1) * (t + 1) <= n) ++t;\n            long long ans = t * (5 + t) / 2 - 3 + n / t;;\n            printf(\"%d\\n\", ans);\n        } else {\n            long long t = pow(n, 0.25);\n            if ((t + 1) * (t + 1) * (t + 1) * (t + 1) <= n) ++t;\n            long long ans = t * (t * t + 8) / 3 + t * t - 4 + n / t;\n            printf(\"%d\\n\", ans);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 6 - A - SmartLy's Game<span id = \"06a\"></span>\n\n### 题目大意\n\n两个人玩游戏：有 $n$ 堆石子，每堆有一些石子。先手可以在石子数不少于 $A$ 的石堆中取走 $A$ 个石子，后手可以在石子数不少于 $B$ 的石堆中取走 $B$ 个石子。一方不能行动则另一方获胜，问先手是否必胜。\n\n$1 \\leq N \\leq 100$\n\n$1 \\leq A, B \\leq 10^9$\n\n$1 \\leq T \\leq 10,000$\n\n时间限制：$1 \\text{s}$，空间限制：$64 \\text{MB}$。\n\n### 题解\n\n每堆石子数可以对 $A + B$ 取模而对答案无影响。取模后按石子数分类：\n\n* $a_i < \\min(A, B)$：双方都不能取，可以无视；\n* $\\min(A, B) \\leq a_i < \\max(A, B)$：只有小的一方可以取，如果存在这样的堆，则小的一方必胜；\n* $a_i \\geq \\max(A, B) \\text{ and } a_i \\geq 2\\min(A, B)$：大的一方只能取一次，而小的一方可以取多次。当小的一方取过一次后转化为情况二，而大的一方取过一次后转化为情况一。如果存在这样的堆且先手为小者，先手必胜；存在至少 $2$ 个这样的堆且后手为小者，后手必胜；\n* $a_i \\geq \\max(A, B)$：当不能根据之前的情况判定胜负时，每一个这种堆只能被双方取一次（只存在一个情况三的堆且后手为小者时，先手会先抢走这堆），故根据这种堆数目的奇偶判断胜负。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 105;\n\nint a[MAXN];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, A, B;\n        scanf(\"%d %d %d\", &n, &B, &A);\n        int min = std::min(A, B), max = std::max(A, B);\n\n        int t = A + B;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &a[i]);\n            a[i] %= t;\n        }\n\n        bool flag = false;\n        for (int i = 0; i < n; i++) if (min <= a[i] && a[i] < max) {\n            puts(A < B ? \"GIRL\" : \"JSB\");\n            flag = true;\n            break;\n        }\n\n        if (flag) continue;\n\n        int cnt2Min = 0;\n        for (int i = 0; i < n; i++) if (max <= a[i] && 2 * min <= a[i]) ++cnt2Min;\n        if (A < B && cnt2Min) {\n            puts(\"GIRL\");\n            continue;\n        }\n        if (B < A && cnt2Min > 1) {\n            puts(\"JSB\");\n            continue;\n        }\n\n        int cnt = 0;\n        for (int i = 0; i < n; i++) if (max <= a[i]) ++cnt;\n        puts(cnt % 2 ? \"GIRL\" : \"JSB\");\n    }\n\n    return 0;\n}\n```\n\n## Contest 6 - E - Heltion and Sequence<span id = \"06e\"></span>\n\n### 题目大意\n\n给定一个初始有 $n$ 个元素的数组 $\\{a_i\\}$，之后有 $q$ 个操作。一共有 $4$ 种操作：\n\n* `1 u v`：在位置 $u$ 前插入数 $v$；\n* `2 l r`：询问区间 $[l, r]$ 的元素和；\n* `3 u v`：将位置 $u$ 的数改为 $v$；\n* `4`：按升序排序数组。\n\n$1 \\leq n, q \\leq 200,000$\n\n$0 \\leq v, a_i \\leq 32767$\n\n$\\sum n \\leq 233,333, ~ \\sum q \\leq 466,666$\n\n时间限制：$10 \\text{s}$，空间限制：$1024 \\text{MB}$。\n\n### 题解\n\n除操作四外均为 Splay 的基本操作。我们每修改或插入一个数后，将对应节点放入一个修改数组，排序时将修改数组内的点全部删除，然后重新插入到 Splay 里即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cassert>\n\nconst int MAXN = 400005;\n\ntemplate <typename T, size_t SIZE>\nstruct Pool {\n    char mem[SIZE * sizeof (T)], *top, *del[SIZE], **delTop;\n\n    void init() {\n        top = mem;\n        delTop = del;\n    }\n\n    void *alloc() {\n        if (delTop != del) return (void *) *(--delTop);\n        char *res = top;\n        top += sizeof (T);\n        return (void *) res;\n    }\n\n    void free(void *p) {\n        *(delTop++) = (char *) p;\n    }\n};\n\nstruct Splay {\n    struct Node {\n        Node *c[2], *fa, **root;\n        int val, size;\n        long long sum;\n        bool isBound;\n        static Pool<Node, MAXN> pool;\n\n        Node () {}\n        Node(Node **root, Node *fa, int val, bool isBound = false)\n            : root(root), fa(fa), size(1), val(val), sum(isBound ? 0 : val), isBound(isBound) {\n            c[0] = c[1] = nullptr;\n        }\n\n        ~Node() {\n            if (c[0]) delete c[0];\n            if (c[1]) delete c[1];\n        }\n\n        void *operator new(size_t) {\n            return pool.alloc();\n        }\n\n        void operator delete(void *p) {\n            pool.free(p);\n        }\n\n        void maintain() {\n            size = (c[0] ? c[0]->size : 0) + 1 + (c[1] ? c[1]->size : 0);\n            sum = (c[0] ? c[0]->sum : 0) + (isBound ? 0 : val) + (c[1] ? c[1]->sum : 0);\n        }\n\n        int rel() {\n            return fa->c[1] == this;\n        }\n\n        void rotate() {\n            Node *o = fa;\n            int x = rel();\n\n            fa = o->fa;\n            if (fa) fa->c[o->rel()] = this;\n\n            o->c[x] = c[x ^ 1];\n            if (c[x ^ 1]) c[x ^ 1]->fa = o;\n\n            c[x ^ 1] = o;\n            o->fa = this;\n\n            o->maintain();\n            maintain();\n\n            if (!fa) *root = this;\n        }\n\n        Node *splay(Node *tarFa = nullptr) {\n            while (fa != tarFa) {\n                if (fa->fa == tarFa) rotate();\n                else if (rel() == fa->rel()) fa->rotate(), rotate();\n                else rotate(), rotate();\n            }\n            return this;\n        }\n\n        Node *pred() {\n            Node *u = c[0];\n            while (u->c[1]) u = u->c[1];\n            return u;\n        }\n\n        Node *succ() {\n            Node *u = c[1];\n            while (u->c[0]) u = u->c[0];\n            return u;\n        }\n\n        int lSize() const {\n            return (c[0] ? c[0]->size : 0) + 1;\n        }\n    } *root, *modified[MAXN];\n    int modifiedCnt;\n\n    void init() {\n        root = new Node(&root, nullptr, -1, true);\n        root->c[1] = new Node(&root, root, 32768, true);\n        root->size = 2;\n        modifiedCnt = 0;\n    }\n\n    Node *select(int pos) {\n        Node *u = root;\n        while (pos != u->lSize()) {\n            if (pos < u->lSize()) {\n                u = u->c[0];\n            } else {\n                pos -= u->lSize();\n                u = u->c[1];\n            }\n        }\n        return u;\n    }\n\n    Node *insert(int pos, int val) {\n        Node *pred = select(pos), *succ = select(pos + 1);\n        pred->splay();\n        succ->splay(pred);\n\n        succ->c[0] = new Node(&root, succ, val);\n        modified[modifiedCnt++] = succ->c[0];\n\n        succ->maintain();\n        pred->maintain();\n    }\n\n    Node *insert(int val) {\n        Node **u = &root, *fa = nullptr;\n        while ((*u) && (*u)->val != val) {\n            fa = *u;\n            ++fa->size;\n            fa->sum += val;\n            u = &(*u)->c[val > (*u)->val];\n        }\n\n        if (*u) {\n            Node *v = (*u)->splay();\n            Node *succ = v->succ();\n            succ->splay(v);\n            succ->c[0] = new Node(&root, succ, val);\n\n            succ->maintain();\n            v->maintain();\n\n            u = &succ->c[0];\n        } else {\n            (*u) = new Node(&root, fa, val);\n        }\n\n        return (*u)->splay();\n    }\n\n    void modify(int pos, int val) {\n        Node *u = select(pos + 1);\n        u->splay();\n\n        u->val = val;\n        u->maintain();\n        modified[modifiedCnt++] = u;\n    }\n\n    void erase(Node *u) {\n        u->splay();\n        Node *pred = u->pred(), *succ = u->succ();\n        pred->splay();\n        succ->splay(pred);\n\n        u->size = -1;\n        delete succ->c[0];\n        succ->c[0] = nullptr;\n        \n        succ->maintain();\n        pred->maintain();\n    }\n\n    long long sum(int l, int r) {\n        Node *pred = select(l), *succ = select(r + 2);\n        pred->splay();\n        succ->splay(pred);\n\n        long long res = succ->c[0] ? succ->c[0]->sum : 0;\n        return res;\n    }\n\n    void sort() {\n        static int val[MAXN];\n        int p = 0;\n        for (int i = 0; i < modifiedCnt; i++) {\n            Node *u = modified[i];\n            if (u->size == -1) continue;\n            val[p++] = u->val;\n            erase(u);\n        }\n        for (int i = 0; i < p; i++) insert(val[i]);\n        modifiedCnt = 0;\n    }\n} splay;\nPool<Splay::Node, MAXN> Splay::Node::pool;\n\nvoid init() {\n    Splay::Node::pool.init();\n    splay.init();\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) == 1) {\n        init();\n\n        for (int i = 1, x; i <= n; i++) {\n            scanf(\"%d\", &x);\n            splay.insert(i, x);\n        }\n\n        int q;\n        scanf(\"%d\", &q);\n        while (q--) {\n            int op;\n            scanf(\"%d\", &op);\n\n            if (op == 1) {\n                int u, v;\n                scanf(\"%d %d\", &u, &v);\n                splay.insert(u, v);\n            } else if (op == 2) {\n                int l, r;\n                scanf(\"%d %d\", &l, &r);\n                long long ans = splay.sum(l, r);\n                printf(\"%lld\\n\", ans);\n            } else if (op == 3) {\n                int u, v;\n                scanf(\"%d %d\", &u, &v);\n                splay.modify(u, v);\n            } else {\n                splay.sort();\n            }\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 6 - G - Heltion and Backpack<span id = \"06g\"></span>\n\n### 题目大意\n\n有 $n$ 种物品，每种物品的价值是 $v_i$，每种物品有无数个，求取出正好 $k$ 个物品能得到多少种价值和。\n\n$1 \\leq n, k, v_i \\leq 1,000$\n\n$1 \\leq T \\leq 10, ~ \\sum \\max(n, k, v_i) \\leq 3,333$\n\n时间限制：$3 \\text{s}$，空间限制：$512 \\text{MB}$。\n\n### 题解\n\n对于每个价值为 $v_i$ 的物品，令多项式 $f(x)$ 中 $x^{v_i}$ 的系数为 $1$，则答案为 $f(x)^k$ 的非零系数个数。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MOD = 998244353;\nconst int G = 3;\n\nlong long qpow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\n\nlong long inv(long long a) {\n    return qpow(a, MOD - 2);\n}\n\nnamespace FFT {\n    const int N = 1048576;\n\n    long long omega[2][N];\n\n    void init() {\n        long long g = qpow(G, (MOD - 1) / N), ig = inv(g);\n        omega[0][0] = omega[1][0] = 1;\n        for (int i = 1; i < N; i++) {\n            omega[0][i] = omega[0][i - 1] * g % MOD;\n            omega[1][i] = omega[1][i - 1] * ig % MOD;\n        }\n    }\n\n    int extend(int n) {\n        int res = 1;\n        while (res < n) res <<= 1;\n        return res;\n    }\n\n    void reverse(long long *a, int n) {\n        for (int i = 0, j = 0; i < n; i++) {\n            if (i < j) std::swap(a[i], a[j]);\n            for (int l = n >> 1; (j ^= l) < l; l >>= 1) {}\n        }\n    }\n\n    void transform(long long *a, int n, long long *omega) {\n        reverse(a, n);\n\n        for (int l = 2; l <= n; l <<= 1) {\n            int hl = l >> 1, k = N / l;\n            for (long long *x = a; x != a + n; x += l) {\n                for (int i = 0; i < hl; i++) {\n                    long long t = omega[k * i] * x[i + hl] % MOD;\n                    x[i + hl] = (x[i] - t + MOD) % MOD;\n                    x[i] += t;\n                    x[i] >= MOD ? x[i] -= MOD : 0;\n                }\n            }\n        }\n    }\n\n    void dft(long long *a, int n) {\n        transform(a, n, omega[0]);\n    }\n\n    void idft(long long *a, int n) {\n        transform(a, n, omega[1]);\n        long long ni = inv(n);\n        for (int i = 0; i < n; i++) a[i] = a[i] * ni % MOD;\n    }\n}\n\nlong long A[FFT::N];\n\nvoid clear() {\n    std::fill(A, A + FFT::N, 0ll);\n}\n\nint main() {\n    FFT::init();\n\n    int n, k;\n    while (scanf(\"%d %d\", &n, &k) == 2) {\n        clear();\n\n        int max = 0, min = 1000;\n        for (int i = 0, x; i < n; i++) {\n            scanf(\"%d\", &x);\n            A[x] = 1;\n            max = std::max(x, max);\n            min = std::min(x, min);\n        }\n        int sum = max * k + 1;\n        int sum_min = min * k;\n        int N = FFT::extend(sum);\n\n        FFT::dft(A, N);\n        for (int j = 0; j < N; j++) A[j] = qpow(A[j], k);\n        FFT::idft(A, N);\n\n        int ans = 0;\n        for (int i = sum_min; i < sum; i++) if (A[i]) ++ans;\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n```","tags":["FFT","DP","Trie","拓扑排序","离线","树上倍增","博弈","Splay","ZJU","裴蜀定理","可并堆","生成函数"],"categories":["题解（OI/XCPC）"]},{"title":"ZJU 七月集训题目选讲（Contest 1 ～ 3）","url":"/ZJU-七月集训题目选讲（Contest-1-～-3）/","content":"\n# ZJU 七月集训题目选讲（Contest 1 ～ 3）\n\nZJU 七月集训（2018.7.13 ～ 2018.7.26）的题目。\n\n* Contest 1 by SBconscious - 2018.7.13\n* Contest 2 by Astolfo - 2018.7.14\n* COntest 3 by bits/stdc++.h - 2018.7.15\n\n所有题目都是多组数据，若无子测试点数的说明，则 $T$ 不会特别大。\n\n## 目录\n\n[Contest 1 - A - Saber](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#01a)\n\n[Contest 1 - B - Lancer](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#01b)\n\n[Contest 1 - G - Berserker](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#01g)\n\n[Contest 2 - C - Ibrahimovic and the Angry Cashier](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#02c)\n\n[Contest 2 - D - Kylian Mbappe and His Challenge](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#02d)\n\n[Contest 2 - G - Neuer and His Manhattan Counting](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#02g)\n\n[Contest 3 - A - #include &lt;set>](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#03a)\n\n[Contest 3 - B - #include &lt;numeric>](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#03b)\n\n[Contest 3 - C - #include &lt;ctime>](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#03c)\n\n[Contest 3 - E - #include &lt;deque>](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#03e)\n\n[Contest 3 - G - #include &lt;bits/stdc++.h>](http://pepcy.cf/ZJU-%E4%B8%83%E6%9C%88%E9%9B%86%E8%AE%AD%E9%A2%98%E7%9B%AE%E9%80%89%E8%AE%B2%EF%BC%88Contest-1-%EF%BD%9E-3%EF%BC%89/#03g)\n\n<!--more-->\n\n## Contest 1 - A - Saber<span id = \"01a\"></span>\n\n### 题目大意\n\n给定一棵 $n$ 个节点的树，每条边有一个权值 $w$。有 $Q$ 次询问，每次询问两个点，判断它们之间的路径上的边中，是否存在三条边使得它们的权值可以组成一个三角形。\n\n$1 \\leq n, Q \\leq 100,000$\n\n$1 \\leq w \\leq 10^9$\n\n$1 \\leq T \\leq 5$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n权值最小的一段不能组成三角形的权值是斐波那契数列，而斐波那契数列的第 $45$ 项已经超过了 $10^9$ ，所以，当路径上的边数超过 $45$ 时即可直接输出 `YES`，否则暴力判断。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <set>\n#include <algorithm>\n\nconst int MAXN = 100005;\nconst int MAXN_LOG = 18;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n    Edge *e;\n    Node *f[MAXN_LOG];\n    int dep, w;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n\n    Edge() {}\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n} _pool[MAXN << 1], *_curr;\n\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v], w);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u], w);\n}\n\nvoid dfs(Node *u, Node *fa = NULL) {\n    u->dep = (fa ? fa->dep : 0) + 1;\n    u->f[0] = fa;\n\n    for (int i = 1; i < MAXN_LOG; i++) {\n        if (u->f[i - 1]) u->f[i] = u->f[i - 1]->f[i - 1];\n        else break;\n    }\n\n    for (Edge *e = u->e; e; e = e->next) if (e->v != fa) {\n        e->v->w = e->w;\n        dfs(e->v, u);\n    }\n}\n\nstd::pair<Node *, int> lca(Node *u, Node *v) {\n    int dist = 0;\n\n    if (u->dep < v->dep) std::swap(u, v);\n\n    for (int i = MAXN_LOG - 1; ~i; i--) if (u->f[i] && u->f[i]->dep >= v->dep) {\n        dist += (1 << i);\n        u = u->f[i];\n    }\n\n    for (int i = MAXN_LOG - 1; ~i; i--) if (u->f[i] && v->f[i] && u->f[i] != v->f[i]) {\n        dist += (1 << (i + 1));\n        u = u->f[i];\n        v = v->f[i];\n    }\n\n    if (u != v) {\n        u = u->f[0];\n        dist += 2;\n    }\n\n    return std::make_pair(u, dist);\n}\n\nbool brute(Node *u, Node *v, Node *lca) {\n    static std::set<int> set;\n    set.clear();\n\n    for (; u != lca; u = u->f[0]) set.insert(u->w);\n    for (; v != lca; v = v->f[0]) set.insert(v->w);\n\n    bool res = false;\n    for (auto i = set.begin(); i != set.end(); i++) {\n        auto j = i;\n        ++j;\n        auto k = j;\n        ++k;\n        if (k == set.end()) break;\n\n        if ((*i) + (*j) > (*k)) {\n            res = true;\n            break;\n        }\n    }\n\n    return res;\n}\n\nvoid init(int n) {\n    _curr = _pool;\n    for (int i = 1; i <= n; i++) N[i].e = NULL;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    for (int kase = 1; kase <= T; kase++) {\n        printf(\"Case #%d:\\n\", kase);\n\n        int n;\n        scanf(\"%d\", &n);\n        init(n);\n\n        for (int i = 1, u, v, w; i < n; i++) {\n            scanf(\"%d %d %d\", &u, &v, &w);\n            addEdge(u, v, w);\n        }\n\n        dfs(&N[1]);\n\n        int q;\n        scanf(\"%d\", &q);\n        while (q--) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n\n            auto ret = lca(&N[u], &N[v]);\n\n            bool ans = ret.second < 44 ? (ret.second >= 3 ? brute(&N[u], &N[v], ret.first) : false) : true;\n            puts(ans ? \"Yes\" : \"No\");\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 1 - B - Lancer<span id = \"01b\"></span>\n\n### 题目大意\n\n有 $n$ 个物品，每个物品有一个字符（小写字母）和一个权值（$1 \\sim 9$）。从这些物品中连续取出 $i \\times l$ 个，其中 $i \\geq S$，$l \\in [L, R]$，并且满足对于这 $i$ 个长为 $l$ 的子段，不存在某两个子段在某一个相对位置上的字符相同，可获得它们权值和的价值。求可获得的最大价值。\n\n$1 \\leq n \\leq 500,000$\n\n$0 \\leq R - L \\leq 10$\n\n$1 \\leq T \\leq 10, \\sum n \\leq 2,500,000$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n注意到 $R - L$ 很小，我们可以枚举长度 $l$。对于每一个长度，暴力搞出从某一个位置开始，每次向后跳 $l$ 个物品所能到的最远距离，答案就是每一个长为 $l$ 的连续子段中该最远距离的最小值，可以用单调队列来维护。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 500005;\n\nchar str[MAXN], num[MAXN];\nint sum[MAXN], max[MAXN];\n\nstruct MonoQ {\n    std::deque<int> q, m;\n\n    void push(int x) {\n        q.push_back(x);\n        while (!m.empty() && m.back() > x) m.pop_back();\n        m.push_back(x);\n    }\n\n    void pop() {\n        int x = q.front();\n        q.pop_front();\n        if (x == m.front()) m.pop_front();\n    }\n\n    int top() {\n        return m.front();\n    }\n\n    void clear() {\n        q.clear();\n        m.clear();\n    }\n} q;\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, l, r, s;\n        scanf(\"%d %d %d %d %s %s\", &n, &l, &r, &s, str, num); \n\n        sum[0] = 0;\n        for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + num[i] - '0';\n\n        int ans = 0;\n        for (int len = l; len <= std::min(r, n); len++) {\n            for (int x = 0; x < n; x++) {\n                static bool exist[128];\n                std::fill(exist, exist + 128, false);\n                exist[str[x]] = true;\n\n                int i;\n                for (i = len; x + i < n; i += len) {\n                    if (!exist[str[x + i]]) exist[str[x + i]] = true;\n                    else break;\n                }\n                max[x] = i / len;\n            }\n\n            q.clear();\n            for (int i = 0; i < len - 1; i++) q.push(max[i]);\n            for (int i = len - 1; i < n; i++) {\n                q.push(max[i]);\n                if (q.top() >= s) ans = std::max(ans, sum[i + (q.top() - 1) * len + 1] - sum[i - len + 1]);\n                q.pop();\n            }\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 1 - G - Berserker<span id = \"01g\"></span>\n\n### 题目大意\n\n求从 $1 \\sim n$ 中选出不超过 $k$ 个不同的数满足它们的乘积不是除 $1$ 外其他完全平方数的倍数的方案数，答案对 $1,000,000,007$ 取模。\n\n$1 \\leq n, k \\leq 500$\n\n$1 \\leq T \\leq 10$\n\n时间限制：$2 \\text{s}$，内存限制：$512 \\text{MB}$。\n\n### 题解\n\n对每个数进行质因数分解并按质因子分组，每组最多选一个数以保证乘积无平方因子（忽略有平方因子的数）。但有一些数可以被分到多个组中。\n\n注意到 $19^2 = 361, 23^2 = 529$，即只有 $\\{2, 3, 5, 7, 11, 13, 17, 19\\}$ 的倍数会被分到多组。除去这些质因子后，每个数可以被分到唯一的组。\n\n对于这 $8$ 个质因子，用二进制位的方式保证乘积无平方因子。\n\n具体地说，对于只含这 $8$ 个质因子的数，我们进行如下 DP 转移：\n$$\nf(j, s) = \\sum_{g_i \\subset s} f(j - 1, s \\oplus g_i)\n$$\n其中 $f(i, s)$ 表示选择了 $i$ 个数，它们乘积的质因子为 $s$（状压表示）的方案数，$g_i$ 表示数 $i$ 的质因子（状压表示）。\n\n对于其他的组，也进行类似的 DP，但是其他组需要满足组内只能选一个数。我们可以通过改变枚举顺序来实现。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 505;\nconst int MOD = 1000000007;\n\nconst int PRIME[8] = {2, 3, 5, 7, 11, 13, 17, 19};\n\nstd::vector<int> vec[MAXN];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, k;\n        scanf(\"%d %d\", &n, &k);\n\n        for (int i = 1; i <= n; i++) vec[i].clear();\n\n        for (int i = 1; i <= n; i++) {\n            int x = i, temp = 0;\n            bool flag = false;\n            for (int j = 0; j < 8; j++) if (x % PRIME[j] == 0) {\n                x /= PRIME[j];\n                if (x % PRIME[j] == 0) {\n                    flag = true;\n                    break;\n                }\n                temp |= (1 << j);\n            }\n            if (flag) continue;\n            vec[x].push_back(temp);\n        }\n\n        static int f[MAXN][1 << 8];\n        memset(f, 0, sizeof (f));\n        f[0][0] = 1;\n\n        for (auto i : vec[1]) {\n            for (int j = k; j; j--) for (int s = 0; s < (1 << 8); s++) if (f[j - 1][s] && !(s & i)) {\n                f[j][s | i] += f[j - 1][s];\n                f[j][s | i] >= MOD ? f[j][s | i] -= MOD : 0;\n            }\n        }\n\n        for (int i = 2; i <= n; i++) if (!vec[i].empty()) {\n            for (int j = k; j; j--) for (int s = 0; s < (1 << 8); s++) if (f[j - 1][s]) for (auto p : vec[i]) if (!(s & p)) {\n                f[j][s | p] += f[j - 1][s];\n                f[j][s | p] >= MOD ? f[j][s | p] -= MOD : 0;\n            }\n        }\n\n        int ans = 0;\n        for (int i = 1; i <= k; i++) for (int s = 0; s < (1 << 8); s++) {\n            ans += f[i][s];\n            ans >= MOD ? ans -= MOD : 0;\n        }\n\n        printf(\"%d\\n\", ans);\n    }\n\n    return 0;\n}\n```\n\n## Contest 2 - C - Ibrahimovic and the Angry Cashier<span id = \"02c\"></span>\n\n### 题目大意\n\n有 $m$ 张一元的硬币和无限张一百元的纸币，进行 $n$ 次购物，每次的价格为 $c_i$，每次售货员会获得 $x_i \\times w_i$ 的怒气值，其中 $x_i$ 为本次需要找零的钱数。售货员找零时只会给一百元的纸币和少于 $100$ 个的一元的硬币，并且这些钱可以用于后续的购物。求 $n$ 次购物后售货员怒气值的最小值。\n\n$1 \\leq n, c_i, w_i \\leq 100,000$\n\n$0 \\leq m \\leq 10^9$\n\n$1 \\leq T \\leq 20$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n显然，所有的 $c_i$ 可以对 $100$ 取模。每次都用硬币付款，当硬币不够时，可以从之前的几次中选择未选择过的、 $(100 - c_i)w_i$ 最小的一次，使用纸币付款，相当于换到了 $100$ 个硬币。用优先队列维护最小的 $(100 - c_i)w_i$ 即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nint c[MAXN], w[MAXN];\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while(T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &c[i]);\n            c[i] %= 100;\n        }\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d\", &w[i]);\n            w[i] = w[i] * (100 - c[i]);\n        }\n\n        long long ans = 0;\n        static std::priority_queue<int, std::vector<int>, std::greater<int> > q;\n        while (!q.empty()) q.pop();\n\n        for (int i = 0; i < n; i++) if (c[i]) {\n            q.push(w[i]);\n            m -= c[i];\n            if (m < 0) {\n                ans += q.top();\n                q.pop();\n                m += 100;\n            }\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 2 - D - Kylian Mbappe and His Challenge<span id = \"02d\"></span>\n\n### 题目大意\n\n有两个数 $a$ 和 $b$，初始时 $a = 1, b = 0$，每次操作可以让 $a = a \\times b$ 或让 $b = b + 1$。求通过不超过 $p$ 次操作，可以得到多少个在 $[l, r]$ 范围内的数。\n\n$0 \\leq l, r \\leq 10^9$\n\n$0 \\leq q \\leq 100$\n\n$1 \\leq T \\leq 10$， $r \\geq 10^8$ 的子测试点不超过 $4$ 个。\n\n时间限制：$5 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n因为 $p \\leq 100$，所以得到的数的质因数不会超过 $100$。用 $100$ 以内的质数 dfs 一遍求出用它们能得到的数（数量级在 $10^6$）并排序，用 $a_i$ 表示这些数中的第 $i$ 个（排序后）。\n\n$f(i)$ 表示得到 $a_i$ 所需的最少操作， $g(i)$ 表示得到 $a_i$ 所需的最少的乘法操作，则转移为：\n$$\ng(i) = \\min\\limits_{1 \\leq k \\leq 100 \\text{ and } a_j \\times k = a_i} g(j) + 1 \\\\\nf(i) = \\min\\limits_{1 \\leq k \\leq 100 \\text{ and } a_j \\times k = a_i} g(i) + k\n$$\n 对同一个 $k$，满足 $a_j \\times k = a_i$ 的 $i$ 是随 $j$ 递增的。我们先枚举 $k$，后枚举 $j$，记录指针地扫可得到满足条件的 $i$，并更新 $g(i)$ 和 $f(i)$。\n\n询问时在 $\\{a_i\\}$ 里枚举判断即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nconst int MAXA = 1000000000;\nconst int MAXN = 3000000;\nconst int PRIME_CNT = 25;\nconst int PRIME[PRIME_CNT] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97};\n\nstd::vector<long long> num;\nvoid dfs(int p, long long curr) {\n    if (p == PRIME_CNT) {\n        num.push_back(curr);\n        return;\n    }\n\n    do {\n        dfs(p + 1, curr);\n        curr *= PRIME[p];\n    } while (curr <= MAXA);\n}\n\nint mulCnt[MAXN], cnt[MAXN];\nvoid pre() {\n    dfs(0, 1);\n    std::sort(num.begin(), num.end());\n\n    for (int i = 0; i < num.size(); i++) {\n        mulCnt[i] = MAXA;\n        cnt[i] = num[i];\n    }\n    mulCnt[0] = cnt[0] = 0;\n    for (int i = 1; i <= 100; i++) {\n        int k = 0;\n        for (int j = 0; j < num.size() && num[j] * i <= MAXA; j++) {\n            while (num[k] < num[j] * i && k < num.size()) ++k;\n            if (num[k] == num[j] * i) {\n                mulCnt[k] = std::min(mulCnt[k], mulCnt[j] + 1);\n                cnt[k] = std::min(cnt[k], mulCnt[k] + i);\n            }\n        }\n    }\n}\n\nint main() {\n    pre();\n\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int l, r, p;\n        scanf(\"%d %d %d\", &l, &r, &p);\n\n        int ans = 0;\n        for (int i = 0; i < num.size(); i++) if (l <= num[i] && num[i] <= r && cnt[i] <= p) ++ans;\n        printf(\"%d\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 2 - G - Neuer and His Manhattan Counting<span id = \"02g\"></span>\n\n### 题目大意\n\n平面上有 $K$ 个整点 $(x_i, y_i)$ ，其中 $1 \\leq x_i、y_i \\leq N$。定义函数\n$$\nF(u, v) = \\sum_{i = 1}^{K} f(u, v, i) \\\\\nf(u, v, i) = \\begin{cases}\n(u - x_i) + (v - y_i) &u \\geq x_i \\text{ and } v \\geq y_i \\\\\n0 &\\text{else}\n\\end{cases}\n$$\n有 $Q$ 次询问，每次询问有多少 $1 \\leq u、 v \\leq N$ 的整点 $(u, v)$ 满足 $F(u, v) = C_i$。\n\n$1 \\leq K, N \\leq 10^5$\n\n$1 \\leq Q \\leq 10$\n\n$0 \\leq C_i \\leq 10^9$\n\n$N, K \\geq 10^4$ 的子测试点不超过 $20$ 个，小测试点有 $1,000$ 个。\n\n时间限制：$2 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n在同一 $x$轴上 $F(u, v)$ 随 $y$ 坐标递增，同一 $y$轴同理。我们从点 $(1, N)$ 开始，按如下方式扫一遍统计答案：\n\n* $F(u, v) > C$ ：下移一格；\n* $F(u, v) = C$ ：下移一格，右移一格；\n* $F(u, v) > C$ ：右移一格。\n\n考虑如何快速计算 $F(u, v)$ ：我们动态地维护 $(u, v)$ 左下部分的点数 $c$ 和这些点的横纵坐标和 $sum$，则 $F(u, v) = (u + y)c - sum$。把点按横、纵坐标各排一个序，在两个数组里记录指针地扫即可在移动时更新 $c$ 和 $sum$。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n} X[MAXN], Y[MAXN], *px, *py;\nbool cmpX(const Point &a, const Point &b) {\n    return a.x == b.x ? a.y < b.y : a.x < b.x;\n}\nbool cmpY(const Point &a, const Point &b) {\n    return a.y == b.y ? a.x < b.x : a.y < b.y;\n}\n\nint count, n, k;\nlong long sum;\nint calc(int x, int y, long long c) {\n    int res = 0;\n    bool flag = false;\n    while (y > 0 && x <= n) {\n        for (; px->x <= x && px < X + k; px++) if (px->y <= y) {\n            ++count;\n            sum += px->x + px->y;\n        }\n        for (; py->y > y && py >= Y; py--) if (py->x <= (flag ? x - 1 : x)) {\n            --count;\n            sum -= py->x + py->y;\n        }\n\n        long long F = (long long) count * (x + y) - sum;\n        if (F == c) {\n            ++res;\n            ++x;\n            --y;\n            flag = true;\n        } else if (F > c) {\n            --y;\n            flag = false;\n        } else {\n            ++x;\n            flag = false;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        scanf(\"%d %d\", &n, &k);\n        for (int i = 0; i < k; i++) scanf(\"%d %d\", &X[i].x, &X[i].y);\n\n        std::copy(X, X + k, Y);\n        std::sort(X, X + k, cmpX);\n        std::sort(Y, Y + k, cmpY);\n\n        int q;\n        scanf(\"%d\", &q);\n        while (q--) {\n            long long c;\n            scanf(\"%lld\", &c);\n\n            count = 0;\n            sum = 0;\n            px = X;\n            py = Y + k - 1;\n\n            int ans = calc(1, n, c);\n            printf(\"%d%c\", ans, \"\\n \"[q]);\n        }\n    }\n    \n    return 0;\n}\n```\n\n## Contest 3 - A - include &lt;set><span id = \"03a\"></span>\n\n### 题目大意\n\n给定 $n$ 个点，每个点有一个质量 $m_i$。你可以平移或旋转点集，但必须：\n\n* 保持各个点之间的相对位置不变；\n* 点的纵坐标不得为负。\n\n以 $x$轴为零势面，最小化点的重力势能和。\n\n$0 \\leq n, x, y \\leq 10,000$\n\n$0 \\leq m \\leq 100$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n答案最小时，凸包的一条边与 $x$轴重合。求出重心和凸包，然后求出重心到凸包上的边的最短距离即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct Point {\n    double x, y;\n\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n\n    bool operator<(const Point &rhs) {\n        return x == rhs.x ? y < rhs.y : x < rhs.x;\n    }\n\n    Point operator+(const Point &rhs) const {\n        return Point(x + rhs.x, y + rhs.y);\n    }\n\n    Point operator-(const Point &rhs) const {\n        return Point(x - rhs.x, y - rhs.y);\n    }\n\n    Point operator*(double rhs) const {\n        return Point(x * rhs, y * rhs);\n    }\n\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n} P[MAXN], ch[MAXN], M;\nint mass[MAXN];\n\nint getConvexHell(int n) {\n    int p = 1;\n    std::sort(P, P + n);\n    for (int i = 1; i < n; i++) if (P[i].x != P[i - 1].x || P[i].y != P[i - 1].y) P[p++] = P[i];\n    n = p;\n    std::sort(P, P + n);\n\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        while (m > 1 && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n\n    int k = m;\n    for (int i = n - 1; ~i; i--) {\n        while (m > k && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n\n    m > 1 ? --m : 0;\n    return m;\n}\n\ndouble distFromPointToLine(const Point &p, const Point &a, const Point &b) {\n    double A = a.y - b.y;\n    double B = b.x - a.x;\n    double C = cross(a, b);\n    return std::abs(A * p.x + B * p.y + C) / sqrt(A * A + B * B);\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n), n) {\n        M = Point(0, 0);\n        int sumM = 0;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %lf %lf\", &mass[i], &P[i].x, &P[i].y);\n            M = M + P[i] * mass[i];\n            sumM += mass[i];\n        }\n        M = M * (1.0 / sumM);\n\n        int m = getConvexHell(n);\n        double ans = m == 1 ? 0 : DBL_MAX;\n        ch[m] = ch[0];\n\n        for (int i = 0; i < m; i++) {\n            double dist = distFromPointToLine(M, ch[i], ch[i + 1]);\n            ans = std::min(ans, dist * sumM * 9.8);\n        }\n\n        printf(\"%.4f\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 3 - B - include &lt;numeric><span id = \"03b\"></span>\n\n### 题目大意\n\n求 $[L, R]$ 内有多少数满足偶数位和与奇数位和的最大公约数不超过 $k$。\n\n$1 \\leq L \\leq R \\leq 10^{18}$\n\n$1 \\leq T \\leq 2,000$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n直接数位 DP 会超时。\n\n因为 $k$ 相同的点，数为 DP 的数组在不顶头时的值是相同的，所以我们先读入所有的测试点，按 $k$ 排序，同一 $k$ 下 DP 时只清空顶头的位置的值即可。\n\n（「顶头」指下一位的数不能随便选的位置）\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n\nconst int MAXT = 2005;\nconst int MAXBIT = 19;\n\nlong long F[MAXBIT + 1][100][100][2];\nint num[20], K;\n\nlong long calc(int i, int f, int g, int limits) {\n    if (i == 0) return F[i][f][g][limits] = int(f && g && std::__gcd(f, g) <= K);\n    if (F[i][f][g][limits] != -1) return F[i][f][g][limits];\n\n    F[i][f][g][limits] = 0;\n    if (!limits) for (int n = 0; n <= 9; n++) {\n        if (i % 2) F[i][f][g][limits] += calc(i - 1, f + n, g, 0);\n        else F[i][f][g][limits] += calc(i - 1, f, g + n, 0);\n    } else {\n        for (int n = 0; n < num[i]; n++) {\n            if (i % 2) F[i][f][g][limits] += calc(i - 1, f + n, g, 0);\n            else F[i][f][g][limits] += calc(i - 1, f, g + n, 0);\n        }\n        if (i % 2) F[i][f][g][limits] += calc(i - 1, f + num[i], g, 1);\n        else F[i][f][g][limits] += calc(i - 1, f, g + num[i], 1);\n    }\n\n    return F[i][f][g][limits];\n}\n\nlong long calc(long long M) {\n    num[0] = 0;\n    for (int i = 1; i <= MAXBIT; i++) {\n        num[i] = M % 10;\n        M /= 10;\n    }\n\n    long long res = calc(MAXBIT, 0, 0, 1);\n\n    return res;\n}\n\nvoid clear() {\n    int o = 0, e = 0;\n    for (int i = MAXBIT; ~i; i--) {\n        F[i][o][e][1] = -1;\n\n        if (i % 2) o += num[i];\n        else e += num[i];\n    }\n}\n\nstruct Query {\n    long long l, r, ans;\n    int k, id;\n\n    Query() {}\n    Query(long long l, long long r, int k, int id) : l(l), r(r), k(k), id(id) {}\n} Q[MAXT];\n\nbool compareByK(const Query &a, const Query &b) {\n    return a.k < b.k;\n}\n\nbool compareById(const Query &a, const Query &b) {\n    return a.id < b.id;\n}\n\nint main() {\n    memset(F, -1, sizeof (F));\n    int T;\n    scanf(\"%d\", &T);\n    for (int i = 0; i < T; i++) {\n        long long l, r, k;\n        scanf(\"%lld %lld %lld\", &k, &l, &r);\n        if (k > 90) k = 90;\n        Q[i] = Query(l, r, k, i);\n    }\n\n    std::sort(Q, Q + T, compareByK);\n\n    int p = 0;\n    for (K = 1; K <= 90; K++) {\n        for (; Q[p].k == K; p++) {\n            long long L = calc(Q[p].l - 1);\n            clear();\n\n            long long R = calc(Q[p].r);\n            clear();\n\n            Q[p].ans = R - L;\n        }\n\n        memset(F, -1, sizeof (F));\n    }\n\n    std::sort(Q, Q + T, compareById);\n    for (int i = 0; i < T; i++) printf(\"%lld\\n\", Q[i].ans);\n\n    return 0;\n}\n```\n\n## Contest 3 - C - include &lt;ctime><span id = \"03c\"></span>\n\n### 题目大意\n\n给定一张 $n$ 个顶点、$m$ 条边的带权无向图，求从 $1$ 号顶点出发、又回到 $1$ 号顶点的最短路径距离。\n\n$1 \\leq n \\leq 10,000$\n\n$1 \\leq m \\leq 40,000$\n\n$1 \\leq w_i \\leq 10,000$\n\n$1 \\leq T \\leq 5$\n\n时间限制：$1 \\text{s}$，内存限制：$256 \\text{MB}$。\n\n### 题解\n\n给与 $1$ 号顶点相邻的顶点重新编号，按二进制位分类设为起点与终点跑多源最短路并更新答案。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nconst int MAXN = 10005;\nconst int MAXN_LOG = 14;\nconst int MAXM = 40005;\n\nstruct Node;\nstruct Edge;\n\nstruct Node {\n    Edge *e;\n    bool vis;\n    int dist;\n} N[MAXN];\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n\n    Edge() {}\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n} _pool[MAXM << 1], *_curr;\n\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v], w);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u], w);\n}\n\nstd::vector<std::pair<int, int> > vec;\n\nnamespace Dijkstra {\nstruct HeapNode {\n    Node *u;\n    int dist;\n\n    HeapNode() {}\n    HeapNode(Node *u, int dist) : u(u), dist(dist) {}\n\n    bool operator<(const HeapNode &rhs) const {\n        return dist > rhs.dist;\n    }\n};\n\nstd::priority_queue<HeapNode> q;\n\nvoid solve() {\n    while (!q.empty()) {\n        Node *u = q.top().u;\n        q.pop();\n\n        if (u->vis) continue;\n        u->vis = true;\n\n        for (Edge *e = u->e; e; e = e->next) if (e->v->dist > u->dist + e->w) {\n            e->v->dist = u->dist + e->w;\n            q.push(HeapNode(e->v, e->v->dist));\n        }\n    }\n}\n\nvoid init(int n) {\n    for (int i = 1; i <= n; i++) {\n        N[i].vis = false;\n        N[i].dist = INT_MAX >> 1;\n    }\n}\n} // namespace Dijkstra\n\nvoid clear(int n) {\n    for (int i = 1; i <= n; i++) N[i].e = NULL;\n    _curr = _pool;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        clear(n);\n\n        vec.clear();\n        for (int i = 0, u, v, w; i < m; i++) {\n            scanf(\"%d %d %d\", &u, &v, &w);\n            if (u != 1 && v != 1) addEdge(u, v, w);\n            else {\n                if (v == 1) std::swap(u, v);\n                vec.push_back(std::make_pair(v, w));\n            }\n        }\n\n        int ans = INT_MAX;\n        for (int bit = 0; (1 << bit) < vec.size(); bit++) {\n            Dijkstra::init(n);\n            for (int i = 0; i < vec.size(); i++) if (i & (1 << bit)) {\n                N[vec[i].first].dist = vec[i].second;\n                Dijkstra::q.push(Dijkstra::HeapNode(&N[vec[i].first], vec[i].second));\n            }\n            Dijkstra::solve();\n\n            for (int i = 0; i < vec.size(); i++) if (!(i & (1 << bit)))\n                ans = std::min(ans, N[vec[i].first].dist + vec[i].second);\n        }\n\n        printf(\"%d\\n\", ans == INT_MAX ? -1 : ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 3 - E - #include &lt;deque><span id = \"03e\"></span>\n\n### 题目大意\n\n要清空一个目前有 $n$ 个元素的双端队列，每个元素为 $w_i$。从左侧弹出元素会有 $w_i \\times L$ 的不高兴值，从右侧则会有 $w_i \\times R$ 的不高兴值。如果本次与上次均从左侧弹出，会有 $q_L$ 的额外不高兴值，右侧则会有 $q_R$ 的额外不高兴值。求最小的不高兴值。\n\n$1 \\leq n \\leq 100,000$\n\n$1 \\leq L, R, q_L, q_R \\leq 100$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n以双端队列的某个位置位为界，左侧的只能从左侧弹出，右侧的只能从右侧弹出，为了最小化不高兴值，弹出方式只能为 $LRLRLRLLLL$ 或 $RLRLRLRRRR$ 。求出前缀后缀和，枚举分界线计算即可。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nint w[MAXN];\nlong long pre[MAXN], suf[MAXN], ex[MAXN];\n\nint main() {\n    int n, l, r, ql, qr;\n    while (scanf(\"%d %d %d %d %d\", &n, &l, &r, &ql, &qr) == 5) {\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &w[i]);\n        pre[0] = 0;\n        for (int i = 1; i <= n; i++) pre[i] = pre[i - 1] + w[i];\n        suf[n + 1] = 0;\n        for (int i = n; i; i--) suf[i] = suf[i + 1] + w[i];\n        \n        for (int i = 0; i <= n; i++) {\n            if (n - 2 * i - 1 > 0) ex[i] = (n - 2 * i - 1ll) * qr;\n            else if (n - 2 * (n - i) - 1 > 0) ex[i] = (n - 2 * (n - i) - 1ll) * ql;\n            else ex[i] = 0;\n        }\n\n        long long ans = LLONG_MAX;\n        for (int i = 0; i <= n; i++)\n            ans = std::min(ans, ex[i] + l * pre[i] + r * suf[i + 1]);\n\n        printf(\"%lld\\n\", ans);\n    }\n    \n    return 0;\n}\n```\n\n## Contest 3 - G - #include &lt;bits/stdc++.h><span id = \"03g\"></span>\n\n### 题目大意\n\n做一个支持区间合并的并查集，有 $n$ 个元素， $q$ 次操作，操作有四种：\n\n* 合并元素 $x$ 与元素 $y$\n* 合并 $[x, y]$ 内的元素\n* 询问 $x$ 与 $y$ 是否合并\n* 询问 $x$ 所在的块有多少个元素\n\n$1 \\leq n, q \\leq 100,000$\n\n$1 \\leq T \\leq 5$\n\n时间限制：$2 \\text{s}$，内存限制：$64 \\text{MB}$。\n\n### 题解\n\n用一个线段树维护并查集的 `fa` 数组。合并两个元素时修改单点；合并区间时，递归到区间内的元素的 `fa` 值相等时才进行修改。\n\n由于一段区间之可能从不等变为相等，不可能从相等变为不等，所以区间修改时并不需要懒标记。\n\n### 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n\nconst int MAXN = 100005;\n\nstruct UFS {\n    int f[MAXN], size[MAXN];\n\n    void init(int n) {\n        for (int i = 1; i <= n; i++) f[i] = i;\n        for (int i = 1; i <= n; i++) size[i] = 1;\n    }\n\n    int find(int x) {\n        if (x == f[x]) return x;\n        size[f[x]] += size[x];\n        return f[x] = find(f[x]);\n    }\n\n    void merge(int x, int y) {\n        if (!test(x, y)) {\n            size[find(x)] += size[find(y)];\n            size[find(y)] = 0;\n            f[find(y)] = find(x);\n        }\n    }\n\n    bool test(int x, int y) {\n        return find(x) == find(y);\n    }\n} ufs;\n\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int val;\n\n        Node(int val = -1) : val(val), lc(lc), rc(rc) {}\n        Node(Node *lc, Node *rc) : lc(lc), rc(rc), val(lc->val == rc->val ? lc->val : -1) {}\n\n        void maintain() {\n            val = (lc->val == rc->val ? lc->val : -1);\n        }\n\n        void update(int l, int r, int L, int R, int x) {\n            if (R < l || r < L) return;\n            if (L <= l && r <= R && val != -1) {\n                ufs.merge(x, val);\n                val = ufs.find(x);\n                return;\n            }\n            int mid = l + ((r - l) >> 1);\n            lc->update(l, mid, L, R, x);\n            rc->update(mid + 1, r, L, R, x);\n            maintain();\n        }\n    } *root, _pool[MAXN << 1], *_curr;\n    int n;\n\n    Node *build(int l, int r) {\n        if (l == r) return new (_curr++) Node(l);\n        int mid = l + ((r - l) >> 1);\n        return new (_curr++) Node(build(l, mid), build(mid + 1, r));\n    }\n\n    void init(int n) {\n        _curr = _pool;\n        this->n = n;\n        root = build(1, n);\n    }\n\n    void update(int l, int r, int x) {\n        root->update(1, n, l, r, x);\n    }\n} segT;\n\nvoid clear(int n) {\n    ufs.init(n);\n    segT.init(n);\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, q;\n        scanf(\"%d %d\", &n, &q);\n\n        clear(n);\n\n        while (q--) {\n            int op, x, y;\n            scanf(\"%d %d\", &op, &x);\n\n            if (op == 1) {\n                scanf(\"%d\", &y);\n                segT.update(x, x, ufs.find(y));\n            } else if (op == 2) {\n                scanf(\"%d\", &y);\n                if (x > y) std::swap(x, y);\n                segT.update(x, y, ufs.find(x));\n            } else if (op == 3) {\n                scanf(\"%d\", &y);\n                puts(ufs.test(x, y) ? \"YES\" : \"NO\");\n            } else {\n                printf(\"%d\\n\", ufs.size[ufs.find(x)]);\n            }\n        }\n    }\n    \n    return 0;\n}\n```","tags":["DP","计算几何","单调队列","并查集","线段树","凸包","贪心","单源最短路","数位DP","ZJU"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4161] Shlw loves matrixI","url":"/BZOJ-4161-Shlw-loves-matrixI/","content":"\n## 题目大意\n\n给定数列 $\\{h_n\\}$ 的前 $k$ 项（从 $0$ 开始）及 $a_1, a_2 \\dots a_k$，数列的每一项满足：\n$$\nh_n = \\sum_{i = 1}^{k} a_ih_{k - i}\n$$\n求 $h_n$ 对 $1,000,000,007$ 取模的结果。\n\n$|h_i|, |a_i|, n \\leq 10^9$\n\n$k \\leq 2000$\n\n## 题目链接\n\n[BZOJ 4161](http://www.lydsy.com/JudgeOnline/problem.php?id=4161)\n\n<!--more-->\n\n## 题解\n\n多项式取模求线性齐次递推的模版题（但模数不太好啊）。\n\n矩阵快速幂的解法复杂度为 $O(k^3\\log n)$，显然无法解决这个问题，所以我们考虑其他方法。\n\n以下方法会用到多项式取模，关于用 FFT 优化这个东西（本题暴力取模也是可以过的），可以看 Miskcoo 的这两篇博文：\n\n[多项式求逆 - Miskcoo' Space](http://blog.miskcoo.com/2015/05/polynomial-inverse)\n\n[多项式除法及求模 - MIskcoo's Space](http://blog.miskcoo.com/2015/05/polynomial-division)\n\n定义转移矩阵：\n$$\nA = \\begin{vmatrix}\na_1 & a_2 & a_3 & \\cdots & a_k \\\\\n1 & 0 & 0 & \\cdots & 0 \\\\\n0 & 1 & 0 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & 0 & \\cdots & 0\n\\end{vmatrix}\n$$\n顺便定义这样一个矩阵，以便后续表示方便：\n$$\nH^{(i)} = \\begin{vmatrix}\nh_i \\\\\nh_{i - 1} \\\\\nh_{i - 2} \\\\\n\\vdots \\\\\nh_{i - k + 1}\n\\end{vmatrix}\n$$\n考虑 $A$ 的特征多项式：\n$$\nf(x) = |xI - A| = x^k - \\sum_{i = 1}^{k} a_ix^{k - i}\n$$\n由 Hamilton-Cayley 定理知：$f(A) = 0$。\n\n因为要求 $h_n$，相当于求 $H^{(n)} = A^{n}H^{(0)}$。\n\n考虑下式：\n$$\nx^n = Q(x) f(x) + M(x) \\Leftrightarrow x^n \\equiv M(x) (\\bmod f(x))\n$$\n带入 $x = A$，由 $f(A) = 0$ 有：\n$$\nA^n = M(A) = \\sum_{i = 0}^{k - 1}m_iA^i\n$$\n两侧同时乘 $H^{(0)}$：\n$$\nH^{(n)} = A^nH^{(0)} = \\sum_{i = 0}^{k - 1}m_iA^iH^{(0)} = \\sum_{i = 0}^{k - 1}m_iH^{(i)}\n$$\n考虑第一行：\n$$\nh_n = \\sum_{i = 0}^{k - 1}m_ih_i\n$$\n故我们可以用多项式取模求出 $M(x)$，然后带值即可求出 $h_n$。\n\n计算 $x^n$ 时用快速幂，取模可以 FFT，也可以暴力，用 FFT 的时间复杂度是 $O(k \\log k \\log n)$，用暴力的时间复杂度是 $O(k^2 \\log n)$。\n\n## 代码\n\n只写了暴力取模。。。太弱了不会在模 $1,000,000,007 = 500,000,003 \\times 2 + 1$ 下用 NTT。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n \nconst int MOD = 1000000007;\nconst int MAXK = 2005;\n \nlong long a[MAXK];\nvoid mul(long long *A, long long *B, long long *r, int k) {\n    static long long res[MAXK << 1];\n    // std::fill(res, res + (k << 1), 0);\n    memset(res, 0, sizeof (res));\n \n    for (int i = 0; i < k; i++) for (int j = 0; j < k; j++) {\n        res[i + j] += A[i] * B[j] % MOD;\n        res[i + j] >= MOD ? res[i + j] -= MOD : 0;\n    }\n \n    for (int i = (k << 1) - 2; i >= k; i--) if (res[i]) for (int j = k - 1; ~j; j--) {\n        res[i - k + j] += res[i] * a[j] % MOD;\n        res[i - k + j] >= MOD ? res[i - k + j] -= MOD : 0;\n    }\n \n    for (int i = 0; i < k; i++) r[i] = res[i];\n}\n \nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n     \n    static long long h[MAXK];\n    for (int i = k - 1; ~i; i--) { // 这里倒着输入的原因是，我想让 -a[i] 表示特征多项式 x^i 的系数\n        scanf(\"%lld\", &a[i]);\n        a[i] < 0 ? a[i] += MOD : 0;\n    }\n \n    for (int i = 0; i < k; i++) {\n        scanf(\"%lld\", &h[i]);\n        h[i] < 0 ? h[i] += MOD : 0;\n    }\n \n    if (n < k) return printf(\"%lld\\n\", h[n]), 0;\n \n    static long long m[MAXK], t[MAXK];\n    m[0] = t[1] = 1;\n \n    for (int i = n; i; i >>= 1, mul(t, t, t, k)) {\n        if (i & 1) mul(m, t, m, k);\n    }\n \n    long long hn = 0;\n    for (int i = 0; i < k; i++) hn = (hn + m[i] * h[i] % MOD) % MOD;\n \n    printf(\"%lld\\n\", hn);\n \n    return 0;\n}\n```","tags":["FFT","模版","线性齐次递推"],"categories":["题解（OI/XCPC）"]},{"title":"再见，OI","url":"/再见，OI/","content":"\nNOI 2017 结束后，也就退役了啊。。。那就按套路写一写 OI 历程吧，估计是「想到什么写什么」系列 + 「小学生写作」系列了。。。（估计以后看到这篇博文的我会十分想删掉它吧。。。）\n\n<!-- more -->\n\n## 初遇编程\n\n初二的国庆假期，接触到了 Minecraft，因为之前在贴吧看到过这个游戏，于是就玩了起来。当时的我还不知道，Minecraft 会对我的人生产生多大的影响。\n\n大概是初二的寒假，抱着「那么多人都可以写一点 mod，我为什么不可以呢」的心态，开始自学 Java。（虽然到现在也不会写 mod）\n\nJava 的学习是在慕课网。在一开始，我连看到个数组都会感到好奇，对 OOP 的那一套理论就吃了个表层地学了下来。大括号不换行、小驼峰命名变量、大驼峰命名类、四格空格长的 tab、运算符两侧的空格等习惯都是从那时开始的。\n\n说来，直到初中毕业，我也没有告诉任何人我在学编程，包括我的父母。。。\n\n## 初入高中\n\n虽然在中考前拿了一些保障分，但还是没有使用任何一个地考上了西北师大附中——甘肃最好的高中。同时，靠着我的数学，我考进了学校的「鸿宇」理科实验班，其前身被称作「奥班」，故相当于竞赛班。\n\n通过学校的宣传，我知道了竞赛是五大学科而不是四大学科，想着初中学过编程，于是向父母坦白，想要搞一搞信竞。不过，当时的我更希望搞的化竞。于是在高一下半学期的四分之一学期后，我学完了高中化学，而信竞上毫无进展——因为，我根本不知道具体会是怎样难度的题，不知道有什么地方可以刷题，也没有什么书看。自然，NOIP 2015 我是没有能力去参加的，所以就没有报名。\n\n不过，我有幸参加了「英才计划」，并在高一的寒假因为活动到 THU 玩了一圈。期间无意中看到了一本算法书，后来我才知道是刘汝佳的书。同时认识了几个外省大佬，然而后来发现只有一人在搞 OI 的样子——成都七中的程思哲。\n\n多亏了那次偶然的发现，我买了刘汝佳的两本书，算是开始了信竞的学习。\n\n## 开始探索\n\n在省选前，lrj 的书看到了 DP 之前（期间同时在看黑皮无机），有幸进了省队。接下来的时间就是在看 lrj 的两本书。然而，只看书的效率真的很低，后来才发现，这段时间的学习几乎没有什么用。。。\n\nNOI 2016，又一次见到了吕欣（visit_world）大佬，以及省队的另外两个小伙伴。什么都不会的我在 NOI 2016 以 261 的分数胸牌滚粗。不过，也是在 NOI 2016 期间，我知道了 BZOJ，并在比赛期间刷了三道题（含 a + b problem），并学习了第一个数据结构——线段树。\n\n不过，NOI 2016 也发生了一些令人不快的事情：我省的信息并未被收录，所以那一年的秩序册上是没有甘肃的、合照位置本是没有甘肃的、开幕式座位是在最后一排的后面补的凳子、胸牌也是补发的。。。（现在胸牌也找不到了。。。除了省上开的省队证明外，我好像无法证明自己参加了 NOI 2016。。。）\n\n接下来就是 NOI 2016 之后，也就是高二上半学期的事了。竞赛中心我已经放到了 OI 上，化竞已不再搞了。不过，虽然注册了 BZOJ，但由于作业，在学期内几乎没有刷一道题，NOIP 2016 也是只有 $240$+，直到 WC 2017，刷题量只有 $60$ 左右。\n\n## 正式学习\n\nWC 2017 到了，NOI 2016 省队的各位除吕欣外都只有去高考了，于是就有新的伙伴加入了：同校另一个特色班的同级同学与两个学弟，以及另一个学校的高二学生。\n\nWC 2017 的考试依旧滚粗，就不多说了。不过算是让我记下了 wys。。。\n\nWC 2017 期间，加入了 Universal OJ 用户群，发现了一位很活跃的大佬——Menci。又在 WC 上课期间，无意间瞥见有人在 Menci 的博客上看[「上下界网络流」的那篇文章](https://oi.men.ci/network-flow-with-bounds/)。于是我就去看 Menci 的博客了。跟着 Menci 的博客学习了 Splay。自此，我的数据结构之类的东西，一概是指针式写法；代码风格也有了一定的改变（主要是左大括号前的空格）。\n\nWC 2017 结束后，我开始不管假期作业地整天刷题。新学期的开学考试后，向学校请了一个学期的假来搞 OI，请假过程意外的顺利。\n\n在三月末吧，参加了湖南师大附中的培训。当时的我几乎什么都听不懂，五场模拟赛只有两道题能 AC：一道是毕克的，好像叫「B 君的教育」，就是虚数的那道，因忘写文件爆零了；另一道是彭天翼的一道打表找规律题，因为手贱用了 `floor()` 而因精度问题只有 $30$ 。期间见到了吴雨伦（阮行止）、柴东辰（cdcq）、石响宇（sxy） 等大佬的真身，同时知道了一位在 BZOJ 第一页的大佬——刘昀（leoly）（后来发现好像是 NOI 2017 最后一个集训队），以及认识了／知道了安徽的蒋梦旭、云南的万仞峰、唐山的王予曦、巴蜀的杨翔云、柳州的闭浩扬（scPointer）等（以上真的只是认识了有这么个人）。\n\n培训后，发现只刷题有时效果并不好，我需要一个 OI 博客来记录一些东西，比如一些新学的东西，以及一道题是怎么搞出正解的。于是在 Menci 的博客中知道了 Hexo，并自己搞了一个 Hexo 博客，也就是这个博客。\n\n之后一直在自已一个人刷着题。四月份时，BZOJ 被卡了几次评测，张晴川（zqc）说着要搞新 OJ，有人搞事搞了个 new_bzoj。。。总之那段日子让人有点不快。感觉自己还是在一点点地进步，学了一个又一个的算法／数据结构，又发现自己还是不能自己切题。期间，Splay 让我很是痛苦，本身并不难，但我总是会在一些细节上写错，然后调上半天到一天。网络流又感觉总是有新的套路（在 NOI 2017 都还是这样呢。。。）。应该是六省联考之后，吕欣说这套比较简单，然而我依然做不出来。。。曾一度把 YNOI 系列当作「云南 OI」，还惊异于题目的难度，后来才发现是「Yuno OI」。。。\n\n我妈在湖南师大附中培训后，给我报了一个培训机构，其中包括之前提到的不少人，也有报名后才知道的大佬，比如祁展华、毛嘉怡、吴佳龙（Manchery）、姜度等。。。（能认识这些大佬真是太好了）\n\n接下来是 THUSC，莫名其妙地能去。同时听说 SD 的人几乎都去 PKUSC 了。在 THUSC 期间，与蒋梦旭、万仞峰有一定的交流。THUSC 最后在预料内的滚粗了。最后一天听着吕欣的讲话，听着拿约大佬们的名字，感到自己还是太弱，技不如人，甘拜下风。。。之前提到的几位中有几位有约。不过，当听到钊爷的名字时还是很惊讶的，我本以为 SD 大佬们都去 PKUSC 了。。。\n\n紧接着就是 CTSC & APIO，不过我省并不能去，因为对于我省来说，这段时间是省选。GS 的省选为三小时四题，虽然是传统题，但却以类似提答的形式在考。。。由于看错了题，差点就直接退役了。。。由于我省直接报了五个男生 + 上面没有发现，我省省队是五个男 A 队（直到 NOI 2017 结束时才被胡浦云发现）。省队队员与 WC 2017 时阵容相同（当然，吕欣已经退役了）。\n\n接下来的时间，一边刷题一边准备着会考。同时，之前提到的培训机构开始一周发一套模拟题做。我总是倒数一二的样子，而 Manchery、姜度两位大佬则一直在第一第二。\n\n说来大概是这会儿，知道了 Libre OJ，也就是四月 zqc 说要搞的 OJ（创立 Libre OJ 的这群人对 OI 届确实有很大的贡献啊）。参加了 LBR#1 与 LBR#2，不过结果都很惨。LibreOJ 提供的数据对我刷题有很大的帮助，毕竟我总是会写错一点细节或忘掉一点细节。\n\n应该也是这会儿，开始较大频率地打 cf。曾在四月打了一局 cf，却只 AC 了一道题，rating 只有 $1340$+ 的我一步步地打到了 $1630$+ 。每次总是写三道，有时还会 fst；有一次写了第四道，结果那场 unrated（连续几场 unrated 中的一场，那时真的很不爽啊）。\n\n然后就是 LNR 与 UNR 了。LNR d1 AC 了签到题，暴力了 t3，d2 写了写暴力，差六七名到 cu，不过拿到了随机的衣服；UNR d1 暴力都写挂了，d2 勉强打了一点暴力，结果也是差十名左右 cu。。。两场模拟赛下来，再加上培训机构的模拟赛，我对我 NOI 2017 拿牌几乎不抱希望。\n\nNOI 2017 的前一周，整理了大部分的数据结构／算法的模版。传送门：[NOI 前的代码模版整理及复习](http://pepcy.cf/NOI-%E5%89%8D%E7%9A%84%E4%BB%A3%E7%A0%81%E6%A8%A1%E7%89%88%E6%95%B4%E7%90%86%E5%8F%8A%E5%A4%8D%E4%B9%A0/)。\n\n然后就到了 NOI 2017。直接放传送门：[NOI 2017 游记](http://pepcy.cf/NOI-2017-%E6%B8%B8%E8%AE%B0/)。\n\n虽然对 NOI 2017 的结果有些不满（比如差一点拿到 ag，不能去最想去的 buaa），但总体还是很满意的，算是比较圆满地退役了吧。。。真的很感谢 OI，也很喜欢 OI。当 zju 的老师问到「你大学后是否还会继续搞 ACM」时，我认真想了想 OI 带给了我什么，然后真心地回答了「当然想啊」。\n\n虽然最后更多地在 Libre OJ 刷题，但毕竟 BZOJ 还是老牌。在退役时，BZOJ 的通过题数是 $404$ ，总提交次数是 $888$，真是两个神奇的数字。。。\n\n## 感谢\n\n感谢我的父母对我搞 OI 的大力支持，以及对我的理解。\n\n感谢吕欣学长对我的帮助，是对我 OI 影响最大的人。\n\n感谢[黄浩睿（Menci）的博客](https://oi.men.ci/#blog)，改善了我的码风，一定程度上改变了我对 OI 的态度，让我从中学到了大部分 OI 中会用到的数据结构／算法，是对我 OI 影响次大的人。\n\n感谢[黄哲威（hzwer）](http://hzwer.com/)、[PoPoQQQ](http://blog.csdn.net/popoqqq?viewmode=list)、[Sengxian](https://blog.sengxian.com/) 的博客，提供了大量高质量的题解。同时[吕欣](http://blog.csdn.net/visit_world)、[Fancy](https://fancypei.github.io/)、[Miskcoo](http://blog.miskcoo.com/)、[xehoth](https://blog.xehoth.cc/) 等的博客也对我有一定的帮助。\n\n感谢蒋梦旭，成为第一个与我交流的外省 OIer。\n\n感谢 [BZOJ](http://www.lydsy.com/JudgeOnline/problemset.php)、[Libre OJ](https://loj.ac/)、[Universal OJ](http://uoj.ac/)、[CodeVS](http://codevs.cn/problemset/)、[COGS](http://cogs.pro/cogs/problem/index.php)、[POJ](http://poj.org/problemlist)、[Codeforces](http://codeforces.com/) 提供的题库与比赛，尤其感谢 Libre OJ 的创始人们。\n\n感谢 ZJU、BUAA 的招生办，为我提供了签约的机会。\n\n## 一些个其他的\n\n在停课的一学期里，也经常会摸鱼。。。主要是黄学长的 2048 和补番。\n\n这一学期，2048 从最多凑出 1024 到能凑出 2048 + 1024。NOI 2017 期间也来了一局，意外地发现图全换了。\n\n至于补番嘛。。。这一学期一共补了 $30$ 部季番、$3$ 部半年番、$7$ 部特别篇、$7$ 部剧场动画（不包括新番）。好像变得喜欢新房的风格了。。。（我真的没有花太多时间在补番上啊。。。）","tags":["随笔"],"categories":["其他随笔"]},{"title":"NOI 2017 游记","url":"/NOI-2017-游记/","content":"\n## day -1\n\n报到日。\n\n要不是有一个接站小哥提醒，差点直接去绍一旧校区了。\n\n下午到的宿舍，与同校的在一起。独立卫生间/浴室很棒棒啊，空调很棒棒啊。\n\n晚饭后去 lca 那里拿了 LibreOJ 的衣服。之后把 UNR2 的两个 t1 写了。\n\n<!-- more -->\n\n## day 0\n\n试机/笔试。\n\n开幕式就不多说了。\n\n试机题全是传统题，而且是去年 NOIP 题，怕是六道传统题；又不开氧气，我这个喜欢用 STL 的选手有点慌啊。\n\n笔试检查了四五遍，稳稳地 $100$ 了。\n\n晚上与同学聊聊天，打打炉石就睡了。\n\n## day 1\n\n考前：\n\n有人看到了 wys（吓），有人看到了吉利。\n\n考试：\n\nt1 先花了两个小时写了个 $O(32n \\log^2 n)$ 的，最慢的样例跑了 $1.7$s；之后想到了优化到一个 $\\log$ 的方法，又写了\n\n两个小时，最慢的样例跑了 $0.8$s。期望得分 $60 \\sim 80$。\n\nt2 只剩一个小时，用 `std::vector` 暴力搞合并、分裂，匹配用 AC 自动机。期望得分 $20$。\n\nt3 没有时间了。。。期望得分 $0$。\n\n最终成绩：\n\nt1 mle 暴零（用了 $1300$+ M 内存的我）。\n\nt2 暴力居然有 $56$！\n\nt3 自然是 $0$ 了。\n\n讲题时：\n\nt1 果然是 wys 的题，不过比冬令营正常多了，比较简单的一题。\n\nt2 的题解方向没有想到啊。\n\nt3 的 dp 没有想好。（不过猜对是吉利的题了）\n\n## day 1.5\n\n一整天都在宿舍内打炉石、补番，中午写了一道 LibreOJ 上新放的网络流 24 题的题。\n\n## day 2\n\n考试：\n\nt1 一眼看出 2-sat，但我一直在研究一个“三决策 2-sat”，强行忘掉了字符串内的要求。乱搞了一通，过了样例。之\n\n后又 hack 掉了自己。一共写了 $4$ 个细节不同的拓扑排序后时间到了。心里乱糟糟的，期望得分 $0$。\n\nt2 看出了费用流，但有一点地方的容量没搞清，没写。期望得分 $0$。\n\nt3 只写了 $20$ 分暴力后就放下了。期望得分 $20$。\n\n最终成绩：\n\nt1 莫名其妙地 AC 了，最慢的点 $0.128$s。\n\nt2 自然是 $0$。\n\nt3 自然是 $20$。\n\n讲题时：\n\nt1 自己的复杂度似乎踩了标程，上台吐了个槽。\n\nt2 我居然没看到每天每个菜的出售上限 $k$。以及，网络流居然还有这种操作！\n\nt3 论文题出 NOI 真的大丈夫？分层凸包！？鬼畜的题解啊。。。\n\n总成绩及分数线：\n\nd1t1 要是算一算内存就是 ag 了，而且会比钊爷、menci 高。。。cu 有点尴尬啊。\n\n签约：\n\n去了 zju 和 buaa，zju 第一遍以成绩为由婉拒了，buaa 面试题太过鬼畜，计算机原理的那一套理论完全不知道，zju 又面了一遍一本了。。。\n\n## day 3\n\n早上 buaa 给了我 $60$ 分，但已经签了 zju（虽然我特别想去 buaa）。\n\n颁奖：\n\n诶，scPointer 大佬怎么只有 cu 啊。。。qzh 大佬怎么也是啊。。。\n\n晚上就离开绍一了。。。","tags":["比赛游记"],"categories":["比赛游记"]},{"title":"[ZJOI 2015] 诸神眷顾的幻想乡","url":"/BZOJ-3926-ZJOI-2015-诸神眷顾的幻想乡/","content":"\n## 题目大意\n\n给定一棵含 $n$ 个节点的树，每个节点有一个权值 $c_i$。在树上选定两个点，顺序得到由节点权值组成的数列，求一共能得到多少不同的数列。\n\n只与一个节点相连的节点不超过 $20$ 个。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant c_i \\leqslant 10$\n\n## 题目链接\n\n[【ZJOI 2015】诸神眷顾的幻想乡 - LibreOJ 2137](https://loj.ac/problem/2137)\n\n<!-- more -->\n\n## 题解\n\n只与一个节点相连的节点不超过 $20$ 个，意味着叶子最多有 $20$ 个。\n\n以每个叶子为起点遍历整颗树，沿途建立广义 SAM。用 SAM 求本质不同子串数就是裸题了。\n\n## 代码\n\nLibreOJ 的 64 位机 + 内存比 BZOJ 少一半卡了我 SAM 的指针式写法。。。\n\nBZOJ（指针式的 SAM）：\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 100005;\nconst int CHAR_SET = 10;\nstruct SuffixAutomaton {\n    struct Node {\n        Node *c[CHAR_SET], *next;\n        int max;\n        Node(int max = 0) : max(max), c(), next(NULL) {}\n        int getMin() {\n            return next->max + 1;\n        }\n    } *start, _pool[MAXN * 40], *_curr;\n    SuffixAutomaton() {\n        init();\n    }\n    void init() {\n        _curr = _pool;\n        start = new (_curr++) Node();\n    }\n    Node *extend(Node *v, int c) {\n        if (v->c[c] && v->c[c]->max == v->max + 1) return v->c[c];\n        Node *u = new (_curr++) Node(v->max + 1);\n        while (v && !v->c[c]) {\n            v->c[c] = u;\n            v = v->next;\n        }\n        if (!v) {\n            u->next = start;\n        } else if (v->c[c]->max == v->max + 1) {\n            u->next = v->c[c];\n        } else {\n            Node *n = new (_curr++) Node(v->max + 1), *o = v->c[c];\n            std::copy(o->c, o->c + CHAR_SET, n->c);\n            n->next = o->next;\n            o->next = u->next = n;\n            for (; v && v->c[c] == o; v = v->next) v->c[c] = n;\n        }\n        return u;\n    }\n    long long calc() {\n        long long res = 0;\n        for (Node *p = _pool + 1; p != _curr; p++) res += p->max - p->getMin() + 1;\n        return res;\n    }\n} sam;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int c, deg;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr = _pool;\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n    N[u].deg++;\n    N[v].deg++;\n}\nvoid dfs(Node *u, Node *fa, SuffixAutomaton::Node *last) {\n    SuffixAutomaton::Node *v = sam.extend(last, u->c);\n    for (Edge *e = u->e; e; e = e->next) if (e->v != fa) dfs(e->v, u, v);\n}\nint main() {\n    int n;\n    scanf(\"%d %*d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].c);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    for (int i = 1; i <= n; i++) if (N[i].deg == 1) dfs(&N[i], NULL, sam.start);\n    printf(\"%lld\\n\", sam.calc());\n    return 0;\n}\n```\n\nLibreOJ（非指针的 SAM）：\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 100005;\nconst int CHAR_SET = 10;\nstruct SuffixAutomaton {\n    struct Node {\n        int c[CHAR_SET], next;\n        int max;\n        Node() : max(0), next(-1) {\n            std::fill(c, c + CHAR_SET, -1);\n        }\n    } N[MAXN * 40];\n    int start, nodeCnt;\n    SuffixAutomaton() {\n        init();\n    }\n    void init() {\n        start = 0;\n        nodeCnt = 1;\n    }\n    int getMin(int u) {\n        return N[N[u].next].max + 1;\n    }\n    int extend(int v, int c) {\n        if (N[v].c[c] != -1 && N[N[v].c[c]].max == N[v].max + 1) return N[v].c[c];\n\t\tint u = nodeCnt++;\n        N[u].max = N[v].max + 1;\n        while (v != -1 && N[v].c[c] == -1) {\n            N[v].c[c] = u;\n            v = N[v].next;\n        }\n        if (v == -1) {\n            N[u].next = start;\n        } else if (N[N[v].c[c]].max == N[v].max + 1) {\n            N[u].next = N[v].c[c];\n        } else {\n            int n = nodeCnt++, o = N[v].c[c];\n            N[n].max = N[v].max + 1;\n            std::copy(N[o].c, N[o].c + CHAR_SET, N[n].c);\n            N[n].next = N[o].next;\n            N[o].next = N[u].next = n;\n            for (; v != -1 && N[v].c[c] == o; v = N[v].next) N[v].c[c] = n;\n        }\n        return u;\n    }\n    long long calc() {\n        long long res = 0;\n        for (int p = 1; p != nodeCnt; p++) res += N[p].max - getMin(p) + 1;\n        return res;\n    }\n} sam;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int c, deg;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr = _pool;\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n    N[u].deg++;\n    N[v].deg++;\n}\nvoid dfs(Node *u, Node *fa, int last) {\n    int v = sam.extend(last, u->c);\n    for (Edge *e = u->e; e; e = e->next) if (e->v != fa) dfs(e->v, u, v);\n}\nint main() {\n    int n;\n    scanf(\"%d %*d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].c);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    for (int i = 1; i <= n; i++) if (N[i].deg == 1) dfs(&N[i], NULL, sam.start);\n    printf(\"%lld\\n\", sam.calc());\n    return 0;\n}\n```","tags":["字符串","后缀自动机"],"categories":["题解（OI/XCPC）"]},{"title":"[LibreOJ 6109][2017 山东二轮集训 Day4]增添","url":"/LibreOJ-6109-2017-山东二轮集训-Day4-增添/","content":"\n## 题目大意\n\n有一个长度为 $n$ 的序列，要求支持三种操作（$m$ 次）：\n\n* `1 l r x` 将 $[l, r]$ 中的数增加 $x$。\n* `2 l r x` 用 $[l, l+x]$ 中的数对应替换 $[r, r+x]$ 中的数。\n* `3 l r` 求 $[l, r]$ 中所有数的和。\n\n$1 \\leqslant n, m \\leqslant 100,000$\n\n$x \\leqslant 10,000$\n\n## 题目链接\n\n[LibreOJ 6109](https://loj.ac/problem/6109)\n\n<!-- more -->\n\n## 题解\n\n可持久化 Treap。\n\n用可持久化 Treap 是因为，操作二要求用 Treap 在裂开时只是「假装」裂开，在合并时只是「假装」合并，用可持化的历史版本即可做到。\n\n我因为所有操作都开新节点了（包括 `pushDown()` 、`add()`），所以用了 $250$ 倍空间。。。（LOJ 上第二大。。。）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\nconst int MAXN = 100005;\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n    char mem[sizeof (T) * SIZE], *top;\n    MemoryPool() : top(mem) {}\n    void *alloc() {\n        char *res = top;\n        top += sizeof (T);\n        return (void *) res;\n    }\n};\nstruct Treap {\n    struct Node {\n        int val, tag, size;\n        long long sum;\n        Node *lc, *rc;\n        static const int POOL_SIZE = 250 * MAXN;\n        static MemoryPool<Node, POOL_SIZE> pool;\n        Node() {}\n        Node(Node *lc, Node *rc, int val)\n            : lc(lc), rc(rc), val(val), \n              sum((lc ? lc->sum : 0) + (rc ? rc->sum : 0) + val), tag(0), \n              size((lc ? lc->size : 0) + (rc ? rc->size : 0) + 1) {}\n        Node(Node *lc, Node *rc, int val, long long sum, int tag)\n            : lc(lc), rc(rc), val(val), sum(sum), tag(tag), \n              size((lc ? lc->size : 0) + 1 + (rc ? rc->size : 0)) {}\n        void *operator new(size_t) {\n            return pool.alloc();\n        }\n        Node *add(int d) {\n            return new Node(lc, rc, val + d, sum + (long long) size * d, tag + d);\n        }\n        Node *pushDown() {\n            if (tag) return new Node(lc ? lc->add(tag) : NULL, \n                                     rc ? rc->add(tag) : NULL, val);\n            else return this;\n        }\n    } *root;\n    Treap() : root(NULL) {}\n    static int size(const Node *u) {\n        return u ? u->size : 0;\n    }\n    Node *merge(Node *a, Node *b) {\n        if (!a) return b;\n        if (!b) return a;\n        if (rand() % (a->size + b->size) < a->size) {\n            a = a->pushDown();\n            return new Node(a->lc, merge(a->rc, b), a->val);\n        } else {\n            b = b->pushDown();\n            return new Node(merge(a, b->lc), b->rc, b->val);\n        }\n    }\n    std::pair<Node *, Node *> split(Node *u, int pos) {\n        std::pair<Node *, Node *> res(NULL, NULL);\n        if (!u) return res;\n        u = u->pushDown();\n        if (size(u->lc) >= pos) {\n            res = split(u->lc, pos);\n            res.second = new Node(res.second, u->rc, u->val);\n        } else {\n            res = split(u->rc, pos - size(u->lc) - 1);\n            res.first = new Node(u->lc, res.first, u->val);\n        }\n        return res;\n    }\n    Node *build(int *l, int *r) {\n        if (l > r) return NULL;\n        int *mid = l + (r - l) / 2;\n        return new Node(build(l, mid - 1), build(mid + 1, r), *mid);\n    }\n    void add(int l, int r, int d) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, r - l + 1);\n        R.first = R.first->add(d);\n        root = merge(merge(L.first, R.first), R.second);\n    }\n    void copy(int l, int r, int len) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, len + 1);\n        Node *target = R.first;\n        L = split(root, r - 1);\n        R = split(L.second, len + 1);\n        root = merge(merge(L.first, target), R.second);\n    }\n    long long query(int l, int r) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, r - l + 1);\n        return R.first->sum;\n    }\n} treap;\nMemoryPool<Treap::Node, Treap::Node::POOL_SIZE> Treap::Node::pool;\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    static int a[MAXN];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    treap.root = treap.build(a, a + n);\n    while (q--) {\n        int op, l, r;\n        scanf(\"%d %d %d\", &op, &l, &r);\n        if (op == 1) {\n            int x;\n            scanf(\"%d\", &x);\n            treap.add(l, r, x);\n        }\n        if (op == 2) {\n            int x;\n            scanf(\"%d\", &x);\n            treap.copy(l, r, x);\n        }\n        if (op == 3) printf(\"%lld\\n\", treap.query(l, r));\n    }\n    return 0;\n}\n```","tags":["可持久化Treap","Treap"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[POJ 3580]SuperMemo","url":"/POJ-3580-SuperMemo/","content":"\n## 题目大意\n\n给定一个长为 $n$ 的整数列，并给出 $m$ 次操作。操作如下：\n\n* `ADD x y D` ：区间 $[x, y]$ 加 $D$。\n* `REVERSE x y` ：区间 $[x, y]$ 翻转。\n* `REVOLVE x y T` ：区间 $[x, y]$ 循环向右移动 $T$ 次。\n* `INSERT x P` ：在第 $x$ 个数后插入 $P$。\n* `DELETE x` ：删除第 $x$ 个数。\n* `MIN x y` ：询问区间 $[x, y]$ 的最小值。\n\n$1 \\leqslant n, m \\leqslant 100,000$\n\n## 题目链接\n\n[POJ 3580](http://poj.org/problem?id=3580)\n\n<!-- more -->\n\n## 题解\n\nTreap（其实 Splay 也可以）。\n\n因为是为了可持久化 Treap 而学的 Treap，所以是 $split-merge$ 式的。\n\n其余操作不说了，对于 `revolve` 操作，Treap 直接裂开合并即可，Splay 用 $3$ 次翻转。\n\n我的实现其实是「伪·无旋式 Treap」，因为在插入时旋转了。如果不用随机权值小根堆，而是随机合并，就变成了「真·无旋式 Treap」。\n\n## 代码\n\n本来有个 `srand(2333)` ，但加上就 WA 了。。。\n\n以及析构器应该是不需要的，毕竟一次只会删除一个节点。\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\nconst int MAXN = 100005;\ntemplate <typename T, size_t SIZE>\nstruct MemoryPool {\n    char mem[sizeof (T) * SIZE], *del[SIZE], *memTop, **delTop;\n    MemoryPool() : memTop(mem), delTop(del) {}\n    void *alloc() {\n        if (delTop != del) return (void *) *--delTop;\n        char *res = memTop;\n        memTop += sizeof (T);\n        return (void *) res;\n    }\n    void free(void *p) {\n        *delTop++ = (char *) p;\n    }\n};\nstruct Treap {\n    struct Node {\n        int val, min, tag, key, size;\n        bool rev;\n        Node *c[2];\n        static MemoryPool<Node, MAXN << 1> pool;\n        Node() {}\n        Node(int val, int key = rand() & ~(1u << 31)) \n            : val(val), key(key), min(val), size(1), tag(0), rev(false), c() {}\n        ~Node() {\n            if (c[0]) delete c[0];\n            if (c[1]) delete c[1];\n        }\n        void *operator new(size_t) {\n            return pool.alloc();\n        }\n        void operator delete(void *p) {\n            pool.free(p);\n        }\n        void reverse() {\n            std::swap(c[0], c[1]);\n            rev ^= 1;\n        }\n        void add(int d) {\n            min += d;\n            val += d;\n            tag += d;\n        }\n        void pushDown() {\n            if (rev) {\n                if (c[0]) c[0]->reverse();\n                if (c[1]) c[1]->reverse();\n                rev = false;\n            }\n            if (tag) {\n                if (c[0]) c[0]->add(tag);\n                if (c[1]) c[1]->add(tag);\n                tag = 0;\n            }\n        }\n        void maintain() {\n            min = std::min(val, std::min(c[0] ? c[0]->min : INT_MAX, \n                                         c[1] ? c[1]->min : INT_MAX));\n            size = (c[0] ? c[0]->size : 0) + 1 + (c[1] ? c[1]->size : 0);\n        }\n    } *root;\n    Treap() : root(NULL) {}\n    static int size(const Node *u) {\n        return u ? u->size : 0;\n    }\n    Node *merge(Node *a, Node *b) {\n        if (!a) return b;\n        if (!b) return a;\n        if (a->key < b->key) {\n            a->pushDown();\n            a->c[1] = merge(a->c[1], b);\n            a->maintain();\n            return a;\n        } else {\n            b->pushDown();\n            b->c[0] = merge(a, b->c[0]);\n            b->maintain();\n            return b;\n        }\n    }\n    std::pair<Node *, Node *> split(Node *u, int pos) {\n        std::pair<Node *, Node *> res(NULL, NULL);\n        if (!u) return res;\n        u->pushDown();\n        if (size(u->c[0]) >= pos) {\n            res = split(u->c[0], pos);\n            u->c[0] = res.second;\n            u->maintain();\n            res.second = u;\n        } else {\n            res = split(u->c[1], pos - size(u->c[0]) - 1);\n            u->c[1] = res.first;\n            u->maintain();\n            res.first = u;\n        }\n        return res;\n    }\n    void build(int n, int *a) {\n        static Node *stack[MAXN];\n        stack[0] = root = new Node(0, INT_MIN);\n        int top = 1;\n        for (int i = 0; i < n; i++) {\n            int p = top - 1;\n            Node *u = new Node(a[i]);\n            while (stack[p]->key > u->key) stack[p--]->maintain();\n            if (p != top - 1) u->c[0] = stack[p + 1];\n            stack[p]->c[1] = u;\n            top = p + 1;\n            stack[top++] = u;\n        }\n        while (top) stack[--top]->maintain();\n        root = root->c[1];\n    }\n    void insert(Node *&u, int pos, int val) {\n        if (!u) {\n            u = new Node(val);\n            return;\n        }\n        u->pushDown();\n        int lSize = size(u->c[0]), x = lSize < pos;\n        if (!x) insert(u->c[0], pos, val);\n        else insert(u->c[1], pos - lSize - 1, val);\n        Node *v = u->c[x];\n        if (v->key < u->key) {\n            v->pushDown();\n            u->c[x] = v->c[x ^ 1];\n            v->c[x ^ 1] = u;\n            u = v;\n            u->c[x ^ 1]->maintain();\n        }\n        u->maintain();\n    }\n    void insert(int pos, int val) {\n        insert(root, pos, val);\n    }\n    void del(int pos) {\n        std::pair<Node *, Node *> L = split(root, pos - 1);\n        std::pair<Node *, Node *> R = split(L.second, 1);\n        root = merge(L.first, R.second);\n        delete R.first;\n        R.first = NULL;\n    }\n    void add(int l, int r, int d) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, r - l + 1);\n        R.first->add(d);\n        merge(merge(L.first, R.first), R.second);\n    }\n    void reverse(int l, int r) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, r - l + 1);\n        R.first->reverse();\n        merge(merge(L.first, R.first), R.second);\n    }\n    void revolve(int l, int r, int k) {\n        int len = (r - l + 1);\n        k = (k % len + len) % len;\n        if (!k) return;\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, len);\n        std::pair<Node *, Node *> M = split(R.first, len - k);\n        merge(merge(L.first, M.second), merge(M.first, R.second));\n    }\n    int query(int l, int r) {\n        std::pair<Node *, Node *> L = split(root, l - 1);\n        std::pair<Node *, Node *> R = split(L.second, r - l + 1);\n        int res = R.first->min;\n        merge(merge(L.first, R.first), R.second);\n        return res;\n    }\n} treap;\nMemoryPool<Treap::Node, MAXN << 1> Treap::Node::pool;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    static int a[MAXN];\n    for (int i = 0; i < n; i++) scanf(\"%d\", &a[i]);\n    treap.build(n, a);\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        char op[10];\n        scanf(\"%s\", op);\n        if (op[0] == 'A') {\n            int l, r, d;\n            scanf(\"%d %d %d\", &l, &r, &d);\n            treap.add(l, r, d);\n        } else if (op[0] == 'I') {\n            int pos, val;\n            scanf(\"%d %d\", &pos, &val);\n            treap.insert(pos, val);\n        } else if (op[0] == 'D') {\n            int pos;\n            scanf(\"%d\", &pos);\n            treap.del(pos);\n        } else if (op[0] == 'M') {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            printf(\"%d\\n\", treap.query(l, r));\n        } else if (op[3] == 'E')  {\n            int l, r;\n            scanf(\"%d %d\", &l, &r);\n            treap.reverse(l, r);\n        } else {\n            int l, r, k;\n            scanf(\"%d %d %d\", &l, &r, &k);\n            treap.revolve(l, r, k);\n        }\n    }\n    return 0;\n}\n```","tags":["Treap"],"categories":["题解（OI/XCPC）"]},{"title":"[POJ 1785]Binary Search Heap Construction","url":"/POJ-1785-Binary-Search-Heap-Construction/","content":"\n## 题目大意\n\n以 `label/priority` 的形式给出 $n$ 个节点的值，以 `label` （由小写字母组成）为二分搜索树、`priority` （整数）为大根堆建立一棵 Treap ，并以 `(<left sub-treap><label>/<priority><right sub-treap>)` 的形式输出。多组数据。\n\n$1 \\leqslant n \\leqslant 50,000$\n\n## 题目链接\n\n[POJ 1785](http://poj.org/problem?id=1785)\n\n<!-- more -->\n\n## 题解\n\n无题解。。。\n\n因为看到一道可持久化 Treap 的题才学的 Treap 。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <string>\n#include <algorithm>\nconst int MAXN = 50005;\nconst int MAXL = 105;\nstruct Pair {\n    char key[MAXL];\n    int val;\n    bool operator<(const Pair &rhs) const {\n        return strcmp(key, rhs.key) < 0;\n    }\n} a[MAXN];\nstruct Treap {\n    struct Node {\n        Node *c[2];\n        int val;\n        char key[MAXL];\n        Node() : key(), val(0), c() {}\n        Node(char *key, int val) : val(val), c() {\n            std::copy(key, key + MAXL, this->key);\n        }\n        void print() const {\n            putchar('(');\n            if (c[0]) c[0]->print();\n            printf(\"%s/%d\", key, val);\n            if (c[1]) c[1]->print();\n            putchar(')');\n        }\n    } *root, _pool[MAXN], *_curr;\n    Treap() : root(NULL) {\n        init();\n    }\n    void init() {\n        _curr = _pool;\n    }\n    void build(int n, Pair *a) {\n        init();\n        root = new (_curr++) Node(\"\", INT_MAX);\n        static Node *stack[MAXN];\n        stack[0] = root;\n        int top = 1;\n        for (int i = 0; i < n; i++) {\n            int p = top - 1;\n            Node *u = new (_curr++) Node(a[i].key, a[i].val);\n            while (stack[p]->val < u->val) p--;\n            if (p != top - 1) u->c[0] = stack[p + 1];\n            stack[p]->c[1] = u;\n            top = p + 1;\n            stack[top++] = u;\n        }\n        root = root->c[1];\n    }\n    void print() {\n        root->print();\n        puts(\"\");\n    }\n} treap;\nint main() {\n    int n;\n    while (scanf(\"%d\", &n) && n) {\n        for (int i = 0; i < n; i++) scanf(\" %[a-z]/%d\", a[i].key, &a[i].val);\n        std::sort(a, a + n);\n        treap.build(n, a);\n        treap.print();\n    }\n    return 0;\n}\n```","tags":["Treap"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2010]软件安装","url":"/BZOJ-2427-HAOI-2010-软件安装/","content":"\n## 题目大意\n\n有 $n$ 个软件，对于软件 $i$，它要占用 $W_i$ 的磁盘空间，价值为 $V_i$ 。从中选择一些软件安装到一台磁盘容量为 $M$ 的 计算机上，使得这些软件的价值尽可能大。软件之间存在依赖关系，即软件 $i$ 只有在安装了软件 $j$（包括直接或间接依赖）的情况下才能发挥价值，一个软件最多依赖另外一个软件。\n\n$1 \\leqslant n \\leqslant 100$\n\n$0 \\leqslant W_i \\leqslant m \\leqslant 500$\n\n$0 \\leqslant V_i \\leqslant 1,000$\n\n## 题目链接\n\n[【HAOI 2010】软甲安装 - Luogu 2515](https://www.luogu.com.cn/problem/P2515)\n\n<!-- more -->\n\n## 题解\n\nTarjan 缩圈 + 树形 DP + 背包 DP。\n\n依赖关系会有环，环上的软件要么同时选，要么同时不选，缩成的点的软件大小、价值均为和。\n\n对于依赖关系 $i$ 依赖 $j$ ，从 $j$ 向 $i$ 连边。把某节点的所有子节点当物品进行背包 DP（物品大小要枚举一下）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <algorithm>\nconst int MAXN = 105;\nconst int MAXM = 505;\ntemplate <typename T>\nstruct Edge {\n    T *u, *v;\n    Edge() {}\n    Edge(T *u, T *v) : u(u), v(v) {}\n};\nstruct Conn {\n    std::vector<Edge<Conn> > e;\n    int w, v, deg, f[MAXM];\n} C[MAXN];\nint sccCnt;\nvoid addEdge(Conn *u, Conn *v) {\n    u->e.push_back(Edge<Conn>(u, v));\n    v->deg++;\n}\nstruct Node {\n    std::vector<Edge<Node> > e;\n    Conn *conn;\n    int w, v, dfn, low;\n    bool ins;\n} N[MAXN];\nvoid addEdge(int u, int v) {\n    N[u].e.push_back(Edge<Node>(&N[u], &N[v]));\n}\nnamespace Tarjan {\n    std::stack<Node *> s;\n    int dfsClock;\n    void dfs(Node *u) {\n        s.push(u);\n        u->ins = true;\n        u->dfn = u->low = ++dfsClock;\n        for (std::vector<Edge<Node> >::iterator e = u->e.begin(); e != u->e.end(); e++) {\n            if (!e->v->dfn) {\n                dfs(e->v);\n                u->low = std::min(u->low, e->v->low);\n            } else if (e->v->ins) u->low = std::min(u->low, e->v->dfn);\n        }\n        if (u->dfn == u->low) {\n            sccCnt++;\n            Node *v;\n            do {\n                v = s.top();\n                s.pop();\n                v->ins = false;\n                v->conn = &C[sccCnt];\n                C[sccCnt].w += v->w;\n                C[sccCnt].v += v->v;\n            } while (u != v);\n        }\n    }\n    void findSCC(int n) {\n        dfsClock = 0;\n        while (!s.empty()) s.pop();\n        for (int i = 1; i <= n; i++) if (!N[i].dfn) dfs(&N[i]);\n    }\n}\nvoid rebuild(int n) {\n    for (int i = 1; i <= n; i++) for (std::vector<Edge<Node> >::iterator e = N[i].e.begin(); e != N[i].e.end(); e++)\n        if (e->u->conn != e->v->conn) addEdge(e->u->conn, e->v->conn);\n    for (int i = 1; i <= sccCnt; i++) if (!C[i].deg) addEdge(&C[0], &C[i]);\n}\nint m;\nvoid dfs(Conn *u) {\n    for (int i = u->w; i <= m; i++) u->f[i] = u->v;\n    for (std::vector<Edge<Conn> >::iterator e = u->e.begin(); e != u->e.end(); e++) {\n        dfs(e->v);\n        for (int j = m; j >= u->w; j--) for (int k = 0; k <= j - u->w; k++)\n            u->f[j] = std::max(u->f[j], u->f[j - k] + e->v->f[k]);\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].w);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].v);\n    for (int i = 1; i <= n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        if (x) addEdge(x, i);\n    }\n    Tarjan::findSCC(n);\n    rebuild(n);\n    dfs(&C[0]);\n    int ans = 0;\n    for (int i = 0; i <= m; i++) ans = std::max(ans, C[0].f[i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["树形DP","DP","背包DP","Tarjan"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2016] 幸运数字","url":"/BZOJ-4568-SCOI-2016-幸运数字/","content":"\n## 题目大意\n\n给定一棵 $n$ 个节点的树，每个节点上有权值。有 $q$ 个询问，每次询问 $u$ 与 $v$ 的路径上的节点权值（含两端）的最大子集异或和。\n\n$1 \\leqslant n \\leqslant 20,000$\n\n$1 \\leqslant q \\leqslant 200,000$\n\n$0 \\leqslant G_i \\leqslant 2^{60}$ （节点权值）\n\n## 题目链接\n\n[【SCOI 2015】幸运数字 - LibreOJ 2013](https://loj.ac/problem/2013)\n\n<!-- more -->\n\n## 题解\n\n树上倍增 + 线性基，不多说了。\n\n线性基在合并时，不必用 $O(\\log n)$ 的次数，在找到 lca 后，可以像 Sparse Table 一样合并两个线性基即可。（我自己的代码还是 $O(\\log n)$ 次合并）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 20005;\nconst int MAXN_LOG = 20;\nconst int MAXL = 63;\nstruct LinearBasic {\n    long long a[MAXL + 1];\n    LinearBasic() {\n        std::fill(a, a + MAXL + 1, 0);\n    }\n    void insert(long long t) {\n        for (int i = MAXL; ~i; i--) {\n            if (!t) return;\n            if (!(t & (1ll << i))) continue;\n            if (a[i]) t ^= a[i];\n            else {\n                for (int j = 0; j < i; j++) if (t & (1ll << j)) t ^= a[j];\n                for (int j = i + 1; j <= MAXL; j++) if (a[j] & (1ll << i)) a[j] ^= t;\n                a[i] = t;\n                return;\n            }\n        }\n    }\n    long long queryMax() {\n        long long res = 0;\n        for (int i = 0; i <= MAXL; i++) res ^= a[i];\n        return res;\n    }\n    void merge(const LinearBasic &another) {\n        for (int i = 0; i <= MAXL; i++) insert(another.a[i]);\n    }\n    friend LinearBasic merge(const LinearBasic &a, const LinearBasic &b) {\n        LinearBasic res = a;\n        for (int i = 0; i <= MAXL; i++) res.insert(b.a[i]);\n        return res;\n    }\n};\nstruct Edge;\nstruct Node {\n    Edge *e;\n    Node *f[MAXN_LOG];\n    LinearBasic lb[MAXN_LOG];\n    int dep;\n    long long val;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool[MAXN << 1], *_curr = _pool;\nvoid addEdge(int u, int v) {\n    N[u].e = new (_curr++) Edge(&N[u], &N[v]);\n    N[v].e = new (_curr++) Edge(&N[v], &N[u]);\n}\nvoid dfs(Node *u, bool init = false) {\n    if (init) {\n        u->f[0] = u;\n        u->dep = 1;\n        u->lb[0].insert(u->val);\n    }\n    for (int i = 1; i < MAXN_LOG; i++) {\n        u->f[i] = u->f[i - 1]->f[i - 1];\n        u->lb[i] = merge(u->lb[i - 1], u->f[i - 1]->lb[i - 1]);\n    }\n    for (Edge *e = u->e; e; e = e->next) if (e->v != u->f[0]) {\n        e->v->f[0] = u;\n        e->v->lb[0].insert(u->val);\n        e->v->dep = u->dep + 1;\n        dfs(e->v);\n    }\n}\nLinearBasic lca(Node *u, Node *v) {\n    if (u->dep < v->dep) std::swap(u, v);\n    LinearBasic res;\n    res.insert(u->val), res.insert(v->val);\n    for (int i = MAXN_LOG - 1; ~i; i--) {\n        if (u->f[i]->dep >= v->dep) {\n            res.merge(u->lb[i]);\n            u = u->f[i];\n        }\n    }\n    if (u == v) return res;\n    for (int i = MAXN_LOG - 1; ~i; i--) {\n        if (u->f[i] != v->f[i]) {\n            res.merge(merge(u->lb[i], v->lb[i]));\n            u = u->f[i];\n            v = v->f[i];\n        }\n    }\n    res.insert(u->f[0]->val);\n    return res;\n}\nint main() {\n    int n, q;\n    scanf(\"%d %d\", &n, &q);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &N[i].val);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    dfs(&N[1], true);\n    while (q--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        printf(\"%lld\\n\", lca(&N[u], &N[v]).queryMax());\n    }\n    return 0;\n}\n```","tags":["树上倍增","线性基","LCA"],"categories":["题解（OI/XCPC）"]},{"title":"[Codeforces 821E] Okabe and El Psy Kongroo","url":"/Codeforces-821E-Okabe-and-El-Psy-Kongroo/","content":"\n## 题目大意\n\n在平面直角坐标系中，从 $(0, 0)$ 走到 $(k, 0)$ 。要求：\n\n* 每时每刻满足 $x, y \\geqslant 0$。\n* 每次只能从 $(x, y)$ 走到 $(x + 1, y + 1)$、$(x + 1, y)$、$(x + 1, y - 1)$。\n* 有 $n$ 条水平线段，用 $(a_i, b_i, c_i)$ 表示线段 $y = c_i, (a_i \\leqslant x \\leqslant b_i)$ ，满足 $b_{i} = a_{i + 1}$、$a_1 = 0$。要求，对于任意 $a_i \\leqslant x \\leqslant b_i$ 有 $y \\leqslant c_i$。\n\n求方案数，答案对 $1,000,000,007$ 取模。\n\n$1 \\leqslant n \\leqslant 100$\n\n$1 \\leqslant k \\leqslant 1 \\times 10^{18}$\n\n$0 \\leqslant a_i < b_i \\leqslant 1 \\times 10^{18} \\quad 0 \\leqslant c_i \\leqslant 15$\n\n## 题目链接\n\n[Codeforces 821E](http://codeforces.com/problemset/problem/821/E)\n\n<!-- more -->\n\n## 题解\n\n我本来一直没有写 CF 的题解，但这道题，犯了一个小错误导致 $-9$ 。。。\n\nDP + 矩乘。\n\n记 $f(x, y)$ 表示走到 $(x, y)$ 的答案，转移为：\n$$\nf(x, y) = f(x - 1, y - 1) + f(x - 1, y) + f(x - 1, y + 1)\n$$\n注意到 $c$ 很小、横坐标们很大，考虑矩乘优化（这个矩乘还是很好想的，相比某 KMP + 矩乘的题），完毕。\n\n然后，当时我干了个什么呢？把矩阵快速幂的指数设成了 `int`  ，一直没发现，于是就一直 TLE。。。 233333\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\ntemplate <typename T>\nvoid read(T &x) {\n    char ch;\n    while ((ch = getchar()) > '9' || ch < '0');\n    x = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') x = (x << 1) + (x << 3) + ch - '0';\n}\nconst int MAXC = 16;\nconst int MAXN = 100;\nconst int MOD = 1000000007;\nstruct Matrix {\n    long long a[MAXC][MAXC];\n    Matrix(bool init = false) {\n        memset(a, 0, sizeof (a));\n        if (init) for (int i = 0; i < MAXC; i++) a[i][i] = 1;\n    }\n    friend Matrix operator*(const Matrix &a, const Matrix &b) {\n        Matrix res(false);\n        for (int i = 0; i < MAXC; i++) for (int k = 0; k < MAXC; k++) for (int j = 0; j < MAXC; j++)\n            (res(i, j) += a(i, k) * b(k, j) % MOD) %= MOD;\n        return res;\n    }\n    long long &operator()(int i, int j) {\n        return a[i][j];\n    }\n    long long operator()(int i, int j) const {\n        return a[i][j];\n    }\n};\nMatrix pow(Matrix a, long long n) {\n    Matrix res(true);\n    for (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n    return res;\n}\nint main() {\n    int n;\n    long long k;\n    scanf(\"%d %lld\", &n, &k);\n    Matrix init(false);\n    init(0, 0) = 1;\n    for (int i = 0; i < n; i++) {\n        long long a, b;\n        int c;\n        scanf(\"%lld %lld %d\", &a, &b, &c);\n        if (a >= k) break;\n        for (int j = c + 1; j < MAXC; j++) init(j, 0) = 0;\n        if (c == 0) continue;\n        Matrix trans(false);\n        for (int j = 0; j <= c; j++) {\n            trans(j, j) = 1;\n            if (j) trans(j, j - 1) = 1;\n            if (j < c) trans(j, j + 1) = 1;\n        }\n        Matrix temp = pow(trans, std::min(b, k) - a);\n        init = temp * init;\n    }\n    printf(\"%lld\\n\", init(0, 0));\n    return 0;\n}\n```","tags":["DP","矩阵乘法"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2017] 新生舞会","url":"/BZOJ-4819-SDOI-2017-新生舞会/","content":"\n## 题目大意\n\n给定一个二分图，每个点集各有 $n$ 个节点；再给定两个矩阵 $\\{a_{i, j}\\}$、$\\{b_{i, j}\\}$。求二分图的一个完美匹配，使得\n$$\nC = \\frac{a'_1 + a'_2 + \\cdots + a'_n}{b'_1 + b'_2 + \\cdots + b'_n}\n$$\n最大。\n\n当二分图的点集 $X$ 中的点 $i$ 与点集 $Y$ 中的点 $j$ 匹配时，$a'_i = a_{i, j}, b'_i = b_{i, j}$。\n\n$1 \\leqslant n \\leqslant 100$\n\n$1 \\leqslant a_{i, j}, b_{i, j} \\leqslant 10,000$\n\n## 题目链接\n\n[【SDOI 2017】新生舞会 - LibreOJ 2003](https://loj.ac/problem/2003)\n\n<!-- more -->\n\n## 题解\n\n把那个式子写成 $C \\times (b'_1 + b'_2 + \\cdots + b'_n) - (a'_1 + a'_2 + \\cdots + a'_n) = 0$，二分答案。\n\n具体地说，以 $C \\times b_{i, j} - a_{i, j}$ 为边 $X_i - Y_j$ 的权值求最大匹配，若小于等于 $0$，则说明更大。\n\n注意是实数二分。据说固定次数比差小于等于 `EPS` 要好一点（在控制时间上）。\n\n## 代码\n\n不要自己搞一个 STL 容器元素的指针！\n\n对于 `std::vector` ，当容量不够用时，会重新开二倍数组，不一定在原来的位置上，之后指向其内部元素的指针就飞了。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cfloat>\n#include <vector>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 105;\nstruct Edge;\nstruct Node {\n    std::vector<Edge> e;\n    Edge *pre;\n    int flow;\n    double dist;\n    bool inq;\n} N[MAXN << 1];\nstruct Edge {\n    Node *u, *v;\n    int cap, flow, rev;\n    double cost;\n    Edge() {}\n    Edge(Node *u, Node *v, int cap, double cost, int rev) : u(u), v(v), cap(cap), flow(0), cost(cost), rev(rev) {}\n};\nvoid addEdge(int u, int v, int cap, int cost) {\n    N[u].e.push_back(Edge(&N[u], &N[v], cap, cost, N[v].e.size()));\n    N[v].e.push_back(Edge(&N[v], &N[u], 0, -cost, N[u].e.size() - 1));\n}\nnamespace EdmondsKarp {\n    void solve(int s, int t, int n, int &flow, double &cost) {\n        flow = 0;\n        cost = 0;\n        while (true) {\n            for (int i = 0; i < n; i++) {\n                N[i].dist = DBL_MAX;\n                N[i].flow = 0;\n                N[i].inq = false;\n                N[i].pre = NULL;\n            }\n            std::queue<Node *> q;\n            q.push(&N[s]);\n            N[s].dist = 0;\n            N[s].flow = INT_MAX;\n            while (!q.empty()) {\n                Node *u = q.front();\n                q.pop();\n                u->inq = false;\n                for (Edge *e = &u->e.front(); e && e <= &u->e.back(); e++) {\n                    if (e->cap > e->flow && e->v->dist > u->dist + e->cost) {\n                        e->v->dist = u->dist + e->cost;\n                        e->v->flow = std::min(u->flow, e->cap - e->flow);\n                        e->v->pre = e;\n                        if (!e->v->inq) {\n                            e->v->inq = true;\n                            q.push(e->v);\n                        }\n                    }\n                }\n            }\n            if (N[t].dist == DBL_MAX) break;\n            for (Edge *e = N[t].pre; e; e = e->u->pre) {\n                e->flow += N[t].flow;\n                e->v->e[e->rev].flow -= N[t].flow;\n            }\n            flow += N[t].flow;\n            cost += N[t].dist * N[t].flow;\n        }\n    }\n}\nint a[MAXN][MAXN], b[MAXN][MAXN], n;\nvoid build() {\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) addEdge(i, j + n, 1, 0);\n    const int s = 0, t = 2 * n + 1;\n    for (int i = 1; i <= n; i++) addEdge(s, i, 1, 0), addEdge(n + i, t, 1, 0);\n}\nbool check(double c) {\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n        double temp = c * b[i][j] - a[i][j];\n        N[i].e[j - 1].cost = temp;\n        N[j + n].e[N[i].e[j - 1].rev].cost = -temp;\n    }\n    const int s = 0, t = 2 * n + 1;\n    for (int i = s; i < t; i++) for (int j = 0; j < N[i].e.size(); j++)\n        N[i].e[j].flow = 0;\n    int flow;\n    double cost;\n    EdmondsKarp::solve(s, t, t + 1, flow, cost);\n    return cost <= 0;\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf(\"%d\", &a[i][j]);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) scanf(\"%d\", &b[i][j]);\n    build();\n    double l = 0, r = 1e4;\n    for (int i = 0; i < 40; i++) {\n        double mid = l + (r - l) / 2;\n        if (check(mid)) l = mid;\n        else r = mid;\n    }\n    printf(\"%.6lf\\n\", l);\n    return 0;\n}\n```","tags":["网络流","二分"],"categories":["题解（OI/XCPC）"]},{"title":"[LibreOJ 6059][2017 山东一轮集训 Day1] Sum","url":"/LibreOJ-6059-2017-山东一轮集训-Day1-Sum/","content":"\n## 题目大意\n\n求有多少 $n$ 位十进制数是 $p$ 的倍数且每位之和小于等于 $m_i (m_i = 0, 1, 2, \\ldots, m - 1, m)$，允许前导 $0$，答案对 $998244353$ 取模。\n\n$1 \\leqslant n \\leqslant 1,000,000,000$\n\n$1 \\leqslant q \\leqslant 50$\n\n$1 \\leqslant m \\leqslant 1,000$\n\n## 题目链接\n\n[LibreOJ 6059](https://loj.ac/problem/6059)\n\n<!-- more -->\n\n## 题解\n\n考虑 DP，记 $f(i, j, k)$ 表示已经考虑了 $i$ 位、已经考虑的位数组成的数模 $p$ 的余数为 $j$、已经考虑的位数的数字和为 $k$ 时的答案，则转移：\n$$\nf(i, j, k) \\rightarrow f(i + 1, (j \\times 10 + c) \\bmod p, k + c) \\quad c = 0, 1, 2 \\dots 9\n$$\n这样显然会 TLE。\n\n转移可写为：\n$$\nf(i, (j \\times 10 + c) \\bmod p, k) = \\sum_{t = 0}^{k} f(i - 1, j, t) \\times f(1, c, k - t)\n$$\n发现是卷积的形式。同时发现 DP 可以倍增。于是 FFT／NTT + 倍增 + DP 的解就出来了。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXP = 50;\nconst int MAXM = 1000;\nconst int MAXM_EXTEND = 2048;\nconst int MOD = 998244353;\nconst int G = 3;\nvoid exgcd(long long a, long long b, long long &x, long long &y) {\n    if (!b) x = 1, y = 0;\n    else exgcd(b, a % b, y, x), y -= x * (a / b);\n}\nlong long inv(long long x) {\n    long long res, temp;\n    exgcd(x, MOD, res, temp);\n    return (res + MOD) % MOD;\n}\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nnamespace NumberTheoreticTransform {\n    static const int N = 2048;\n    long long omega[N], omegaInv[N];\n    void init() {\n        long long g = pow(G, (MOD - 1) / N), ig = inv(g);\n        omega[0] = omegaInv[0] = 1;\n        for (int i = 1; i < N; i++) {\n            omega[i] = omega[i - 1] * g % MOD;\n            omegaInv[i] = omegaInv[i - 1] * ig % MOD;\n        }\n    }\n    int extend(int n) {\n        int res = 1;\n        while (res < n) res <<= 1;\n        return res;\n    }\n    void reverse(long long *a, int n) {\n        int k = 0;\n        while ((1 << k) < n) k++;\n        for (int i = 0, j = 0; i < n; i++) {\n            if (i < j) std::swap(a[i], a[j]);\n            for (int l = n >> 1; (j ^= l) < l; l >>= 1);\n        }\n    }\n    void transform(long long *a, int n, long long *omega) {\n        reverse(a, n);\n        for (int l = 2; l <= n; l <<= 1) {\n            int hl = l >> 1;\n            for (long long *x = a; x != a + n; x += l) {\n                for (int i = 0; i < hl; i++) {\n                    long long t = omega[N / l * i] * x[i + hl] % MOD;\n                    x[hl + i] = (x[i] - t + MOD) % MOD;\n                    (x[i] += t) %= MOD;\n                }\n            }\n        }\n    }\n    void dft(long long *a, int n) {\n        transform(a, n, omega);\n    }\n    void idft(long long *a, int n) {\n        transform(a, n, omegaInv);\n        long long t = inv(n);\n        for (int i = 0; i < n; i++) (a[i] *= t) %= MOD;\n    }\n}\nint p, m;\nstruct Data {\n    long long pow, a[MAXP][MAXM_EXTEND];\n    Data() : pow(1), a() {}\n};\nData operator*(Data &a, Data &b) {\n    Data res;\n    res.pow = a.pow * b.pow % p;\n    int s = NumberTheoreticTransform::extend(m + 1) * 2;\n    for (int i = 0; i < p; i++) {\n        NumberTheoreticTransform::dft(a.a[i], s);\n        if (&a != &b) NumberTheoreticTransform::dft(b.a[i], s);\n    }\n    for (int i1 = 0; i1 < p; i1++) for (int i2 = 0; i2 < p; i2++) {\n        static long long temp[MAXM_EXTEND];\n        for (int i = 0; i < s; i++) temp[i] = a.a[i1][i] * b.a[i2][i];\n        NumberTheoreticTransform::idft(temp, s);\n        for (int i = 0; i <= m; i++) (res.a[(i1 * b.pow + i2) % p][i] += temp[i]) %= MOD;\n    }\n    for (int i = 0; i < p; i++) {\n        NumberTheoreticTransform::idft(a.a[i], s);\n        if (&a != &b) NumberTheoreticTransform::idft(b.a[i], s);\n    }\n    return res;\n}\nData pow(Data a, int n) {\n    Data res;\n    res.a[0][0] = 1;\n    for (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n    return res;\n}\nint main() {\n    NumberTheoreticTransform::init();\n    int n;\n    scanf(\"%d %d %d\", &n, &p, &m);\n    Data init;\n    init.pow = 10;\n    for (int i = 0; i <= std::min(9, m); i++) init.a[i % p][i]++;\n    Data res = pow(init, n);\n    long long ans = 0;\n    for (int i = 0; i <= m; i++) {\n        (ans += res.a[0][i]) %= MOD;\n        printf(\"%lld%c\", ans, \" \\n\"[i == m]);\n    }\n    return 0;\n}\n```","tags":["FFT","DP"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4916] 神犇和蒟蒻","url":"/BZOJ-4916-神犇和蒟蒻/","content":"\n## 题目大意\n\n给定 $n$ ，求：\n$$\n\\sum_{i = 1}^{n} \\mu(i^2) \\\\\n\\sum_{i = 1}^{n} \\varphi(i^2)\n$$\n结果对 $1,000,000,007$ 取模。\n\n$1 \\leqslant n \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[BZOJ 4916](http://www.lydsy.com/JudgeOnline/problem.php?id=4916)\n\n<!--more-->\n\n## 题解\n\n第一问，根据莫比乌斯函数的定义，永远是 $1$。\n\n对于第二问，考虑杜教筛。记 $f(i) = \\varphi(i^2)$ ，即找到另一函数 $g$ 使得 $f * g$ 和 $g$ 的前缀和都比较好求（ $*$ 表示狄利克雷卷积）。\n\n首先，显然有：$f(i) = i \\varphi(i)$。\n\n记 $g(i) = i$。\n$$\n\\begin{align}\n(f * g) (n) &= \\sum_{d | n} f(d) \\times h(\\frac{n}{d}) \\\\\n&= \\sum_{d | n} d \\times \\varphi(d) \\times \\frac{n}{d} \\\\\n&= n \\sum_{d | n} \\varphi(d) \\\\\n&= n \\times (\\varphi * 1) \\\\\n&= n^2\n\\end{align}\n$$\n发现这个函数的前缀和很简单，于是我们就找到了 $g$ 。（不看题解哪里知道。。。也算是找到了一个套路）\n\n那么，记 $F(n)$ 为所求，有：\n$$\nF(n) = \\sum_{i = 1}^{n} (f * g)(n) - \\sum_{i = 2}^{n} g(i) F(\\lfloor \\frac{n}{i} \\rfloor)\n$$\n即：\n$$\nF(n) = \\frac{n(n + 1)(2n + 1)}{6} - \\sum_{i = 2}^{n} i F(\\lfloor \\frac{n}{i} \\rfloor)\n$$\n别忘了输出第一问的 $1$。\n\n最后说一说好像是套路或者说是运算法则之类的东西（$\\times$ 表示普通的乘法）：\n$$\n(id \\times f) * (id \\times g) = id \\times (f * g)\n$$\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <map>\n#include <algorithm>\nconst int MAXN = 1000005;\nconst int MOD = 1000000007;\nconst int INV2 = 500000004;\nconst int INV6 = 166666668;\nint prime[MAXN], primeCnt;\nlong long phi[MAXN];\nbool notPrime[MAXN];\nvoid linearShaker() {\n    phi[1] = 1;\n    notPrime[0] = notPrime[1] = true;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[primeCnt++] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 0; j < primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n        }\n    }\n    for (int i = 1; i < MAXN; i++) (phi[i] *= i) %= MOD;\n    for (int i = 2; i < MAXN; i++) (phi[i] += phi[i - 1]) %= MOD;\n}\nlong long pSumID2(long long x) {\n    return x * (x + 1) % MOD * (2 * x + 1) % MOD * INV6 % MOD;\n}\nlong long sumID1(long long l, long long r) {\n    return (l + r) % MOD * (r - l + 1) % MOD * INV2 % MOD;\n}\nlong long calc(int n) {\n    if (n < MAXN) return phi[n];\n    static std::map<int, long long> sum;\n    std::map<int, long long>::iterator it;\n    if ((it = sum.find(n)) != sum.end()) return it->second;\n    long long res = pSumID2(n);\n    for (int i = 2, last; i <= n; i = last + 1) {\n        last = n / (n / i);\n        res = (res + MOD - calc(n / i) * sumID1(i, last) % MOD) % MOD;\n    }\n    return sum[n] = res;\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    linearShaker();\n    puts(\"1\");\n    printf(\"%lld\\n\", calc(n));\n    return 0;\n}\n```","tags":["数论","莫比乌斯反演","杜教筛"],"categories":["题解（OI/XCPC）"]},{"title":"Minkowski sum（闵可夫斯基和）学习笔记","url":"/Minkowski-sum（闵可夫斯基和）学习笔记/","content":"\n## 引入问题\n\n逆时针给出平面上两个凸 $n$ 边形，询问 $q$ 个点是否可以成为一条两个端点分别在两个多边形内的线段的中点。\n\n$n, q \\leqslant 100,000$\n\n## Minkowski sum 介绍\n\n给定向量集合 $A$ 、$B$，定义它们的 Minkowski sum 为：\n$$\nA + B = \\{\\mathbf{a} + \\mathbf{b} | \\mathbf{a} \\in A, \\mathbf{b} \\in B\\}\n$$\n<!-- more -->\n\n举个栗子（$A$ 、$B$ 、$A + B$ 均为多边形）：\n$$\nA = \\{(0, 1), (0, -1), (1, 0)\\} \\\\ \nB = \\{(1, 1), (1, -1), (0, 0)\\} \\\\\nA + B = \\{(1, 0), (2, 1), (2, −1), (0, 1), (1, 2), (1, 0), (0, −1), (1, 0), (1, −2)\\}\n$$\n\n## 凸多边形的 Minkowski sum 的求法\n\n对于两个 $n$ 边形，暴力复杂度 $O(n^2)$ 。\n\n用 $n$ 个逆时针的向量表示每个凸多边形，把这些向量按极角排序，顺次相接，再平移一下，即得到它们的 Minkowski sum，复杂度 $O(n \\log n)$ 。\n\n我们可以先找到一个起点，然后对向量做以上操作，这样就不用平移了。一般 $y$ 值最大的点（有多个则为它们中 $x$ 值最小的点）为起点，至于为什么取它为起点，看一看 `atan2()` 的取值就知道了。\n\n对于多个凸多边形，可以一起做。\n\n## 回到问题\n\n记两个凸多边形为 $A$、$B$，发现合法中点的集合为 $\\frac{A + B}{2}$，让询问点都 $\\times 2$ ，判断是否在 Minkowski sum 内即可。\n\n两个凸 $n$ 边形的 Minkowski sum 也是凸多边形，点数在 $[n, 2n]$ 内。复杂度 $O(n \\log n + nq)$ 。（但似乎实际比较快？）\n\n## 问题代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 100005;\nconst double EPS = 1e-9;\nint dcmp(double x) {\n    if (fabs(x) <= EPS) return 0;\n    return x > EPS ? 1 : -1;\n}\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    bool operator<(const Point &another) const {\n        return atan2(y, x) < atan2(another.y, another.x);\n    }\n    friend Point operator+(const Point &a, const Point &b) {\n        return Point(a.x + b.x, a.y + b.y);\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    friend double dot(const Point &a, const Point &b) {\n        return a.x * b.x + a.y * b.y;\n    }\n};\nbool isPointOnSegment(const Point &p, const Point &s, const Point &t) {\n    return dcmp(cross(s - p, t - p)) == 0 && dcmp(dot(s - p, t - p)) <= 0;\n}\nstruct Poly {\n    std::vector<Point> P;\n    int size() const {\n        return P.size();\n    }\n    Point operator[](int i) const {\n        return P[i];\n    }\n\tbool doseContain(const Point &p) {\n        int windingNum = 0;\n        for (int i = 0; i < size(); i++) {\n            if (isPointOnSegment(p, P[i], P[(i + 1) % size()])) return true;\n            int k = dcmp(cross(P[(i + 1) % size()] - P[i], p - P[i]));\n            int d1 = dcmp(P[i].y - p.y);\n            int d2 = dcmp(P[(i + 1) % size()].y - p.y);\n            if (k > 0 && d1 <= 0 && d2 > 0) windingNum++;\n            if (k < 0 && d2 <= 0 && d1 > 0) windingNum--;\n        }\n        return windingNum;\n    }\n};\nint main() {\n    Point top[2];\n    static std::vector<Point> vec;\n    for (int i = 0; i < 2; i++) {\n        int n;\n        scanf(\"%d\", &n);\n        Point first, last, curr;\n        scanf(\"%lf %lf\", &last.x, &last.y);\n        top[i] = first = last;\n        for (int j = 1; j < n; j++) {\n            scanf(\"%lf %lf\", &curr.x, &curr.y);\n            vec.push_back(curr - last);\n            last = curr;\n            if (dcmp(curr.y - top[i].y) > 0 || (dcmp(curr.y - top[i].y) == 0 && dcmp(curr.x - top[i].x) < 0))\n                top[i] = curr;\n        }\n        vec.push_back(first - last);\n    }\n    std::sort(vec.begin(), vec.end());\n    Point start = top[0] + top[1];\n    Poly poly;\n    for (int i = 0; i < vec.size(); i++) {\n        poly.P.push_back(temp + vec[i]);\n        temp = temp + vec[i];\n    }\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        puts(poly.doseContain(Point(x << 1, y << 1)) ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n```\n\n## 说点别的（应该 OI 无关）\n\n与 Minkowski sum 对应的，有一个 Minkowski difference（闵可夫斯基差）：\n$$\nA - B = \\{\\mathbf{v} | \\mathbf{v} + B \\subseteq A\\}\n$$\n并不存在 $A - B = A + (-B)$。\n\n考虑给出一个房间和一个类似于扫地机器人之类的东西的形状，求机器人能走到的位置集合，用机器人上一点 $P$ 的范围表示，答案就是它们的 Minkowski difference ，其中要以 $P$ 作为坐标原点。","tags":["学习笔记","计算几何","模版"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[国家集训队] 排队","url":"/BZOJ-2141-排队/","content":"\n## 题目大意\n\n给定长为 $n$ 的正整数序列 $\\{a_i\\}$ 以及 $m$ 次交换操作，求一开始以及每次操作后的逆序对数。\n\n$1 \\leqslant n \\leqslant 20,000$\n\n$1 \\leqslant m \\leqslant 2,000$\n\n$1 \\leqslant a_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【国家集训队】排队 - Luogu 1975](https://www.luogu.com.cn/problem/P1975)\n\n<!-- more -->\n\n## 题解\n\nCDQ 分治／三维偏序 + 离散化。\n\n每次交换转化为两个删除和两个插入，求动态逆序对。\n\n先让 $a_i = cnt - a_i + 1$ （ $cnt$ 为不同的数据数），求一次三维偏序（位置、操作时间、值），求出在某位置前面、之前的操作中、值比它大的个数。\n\n再恢复 $a_i$ ，同时让 $pos_i = n - pos_i + 1$ ，再求一次三维偏序，求出在某位置后面、之前的操作中、值比它小的个数。\n\n这样，我们求出来的其实是「某次操作新产生的逆序对数」，求一遍前缀和，依次输出即可。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 20005;\nconst int MAXM = 2005;\nstruct BinaryIndexedTree {\n    int c[MAXN], n;\n    BinaryIndexedTree(int n = 0) : n(n) {}\n    static int lowbit(int x) {\n        return x & -x;\n    }\n    void update(int pos, int d) {\n#ifdef DBG\n        printf(\"update(%d), %d\\n\", pos, d);\n#endif\n        for (int i = pos; i <= n; i += lowbit(i)) c[i] += d;\n    }\n    int query(int pos) {\n        int res = 0;\n        for (int i = pos; i; i -= lowbit(i)) res += c[i];\n#ifdef DBG\n        printf(\"query(%d) = %d\\n\", pos, res);\n#endif\n        return res;\n    }\n    void clear(int pos) {\n        for (int i = pos; i <= n; i += lowbit(i)) {\n            if (c[i]) c[i] = 0;\n            else break;\n        }\n    }\n};\nstruct Data {\n    int time, val, pos, *ans, sign;\n    Data() {}\n    Data(int time, int val, int pos, int *ans, int sign) : time(time), val(val), pos(pos), ans(ans), sign(sign) {}\n    bool operator<(const Data &another) const {\n        return pos < another.pos || (pos == another.pos && time < another.time)\n            || (pos == another.pos && time == another.time && val < another.val);\n    }\n#ifdef DBG\n    void print() const {\n        printf(\"Data: [time: %d, val: %d, pos: %d, sign: %d]\\n\", time, val, pos, sign);\n    }\n#endif\n} D[MAXN + (MAXM << 2)];\nint h[MAXN];\nint discretization(int n) {\n    static int set[MAXN];\n    std::copy(h, h + n, set);\n    std::sort(set, set + n);\n    int *end = std::unique(set, set + n);\n    for (int i = 0; i < n; i++) h[i] = std::lower_bound(set, end, h[i]) - set + 1;\n    return end - set;\n}\nint m;\nvoid divide(Data *l, Data *r) {\n#ifdef DBG\n    printf(\"divide in [%ld, %ld]\\n\", l - D + 1, r - D + 1);\n#endif\n    if (l >= r) return;\n    static BinaryIndexedTree bit(m);\n    Data *mid = l + (r - l) / 2;\n    divide(l, mid), divide(mid + 1, r);\n    static Data temp[MAXN + (MAXM << 2)];\n    for (Data *p = temp, *pl = l, *pr = mid + 1; p <= temp + (r - l); p++) {\n        if (pr > r || (pl <= mid && pl->time <= pr->time)) {\n            *p = *pl++;\n            bit.update(p->val, p->sign);\n        } else {\n            *p = *pr++;\n            *p->ans += p->sign * bit.query(p->val - 1);\n        }\n    }\n    for (Data *p = temp, *q = l; q <= r; p++, q++) {\n        *q = *p;\n        bit.clear(p->val);\n    }\n#ifdef DBG\n    printf(\"end divide in [%ld, %ld]\\n\", l - D + 1, r - D + 1);\n#endif\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &h[i]);\n    m = discretization(n);\n    static int ans[MAXM];\n    int cnt = 0;\n    for (int i = 0; i < n; i++) D[cnt++] = Data(i + 1, h[i], i + 1, &ans[0], 1);\n    int q;\n    scanf(\"%d\", &q);\n    for (int i = 1; i <= q; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        D[cnt] = Data(cnt + 1, h[a - 1], a, &ans[i], -1);\n        cnt++;\n        D[cnt] = Data(cnt + 1, h[b - 1], b, &ans[i], -1);\n        cnt++;\n        D[cnt] = Data(cnt + 1, h[b - 1], a, &ans[i], 1);\n        cnt++;\n        D[cnt] = Data(cnt + 1, h[a - 1], b, &ans[i], 1);\n        cnt++;\n        std::swap(h[a - 1], h[b - 1]);\n    }\n    for (int i = 0; i < cnt; i++) D[i].val = m - D[i].val + 1;\n    std::sort(D, D + cnt);\n#ifdef DBG\n    for (int i = 0; i < cnt; i++) D[i].print();\n#endif\n    divide(D, D + cnt - 1);\n    for (int i = 0; i < cnt; i++) D[i].val = m - D[i].val + 1, D[i].pos = n - D[i].pos + 1;\n    std::sort(D, D + cnt);\n#ifdef DBG\n    for (int i = 0; i < cnt; i++) D[i].print();\n#endif\n    divide(D, D + cnt - 1);\n    for (int i = 1; i <= q; i++) ans[i] += ans[i - 1];\n    for (int i = 0; i <= q; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```","tags":["CDQ分治","三维偏序"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2010] 捉迷藏","url":"/BZOJ-1941-SDOI-2010-Hide-and-Seek/","content":"\n## 题目大意\n\n给定平面上 $n$ 个点，求一个点使得它到其余点的曼哈顿距离的最大最小值之差最小，输出这个差。数据保证没有重点。\n\n$2 \\leqslant n \\leqslant 500,000$\n\n$0 \\leqslant x, y \\leqslant 100,000,000$\n\n## 题目链接\n\n[【SDOI 2010】捉迷藏 - Luogu 2479](https://www.luogu.com.cn/problem/P2479)\n\n<!-- more -->\n\n## 题解\n\nk-d 树 + 枚举。\n\n建树后枚举每个点计算即可。\n\n之前的模版上少了一点剪枝。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\nconst int MAXN = 500005;\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n    bool operator!=(const Point &another) const {\n        return x != another.x || y != another.y;\n    }\n};\nint dist(const Point &a, const Point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\nstruct KDTree {\n    static bool cmp1(const Point &a, const Point &b) {\n        return a.y < b.y || (a.y == b.y && a.x < b.x);\n    }\n    static bool cmp2(const Point &a, const Point &b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    }\n    struct Node {\n        Node *c[2];\n        Point p, r1, r2;\n        Node() {}\n        Node(const Point &p) : p(p), r1(p), r2(p) {}\n        void maintain() {\n            if (c[0]) {\n                r1.x = std::min(r1.x, c[0]->r1.x);\n                r1.y = std::min(r1.y, c[0]->r1.y);\n                r2.x = std::max(r2.x, c[0]->r2.x);\n                r2.y = std::max(r2.y, c[0]->r2.y);\n            }\n            if (c[1]) {\n                r1.x = std::min(r1.x, c[1]->r1.x);\n                r1.y = std::min(r1.y, c[1]->r1.y);\n                r2.x = std::max(r2.x, c[1]->r2.x);\n                r2.y = std::max(r2.y, c[1]->r2.y);\n            }\n        }\n        int distMax(const Point &p) {\n            int res = 0;\n            res += std::max(p.x - r1.x, r2.x - p.x);\n            res += std::max(p.y - r1.y, r2.y - p.y);\n            return res;\n        }\n        void queryMax(const Point &p, int &res) {\n            res = std::max(res, dist(p, this->p));\n            if (!c[0] && !c[1]) return;\n            int k = c[0] && c[1] ? c[0]->distMax(p) < c[1]->distMax(p) : (c[0] ? 0 : 1);\n            if (c[k]->distMax(p) > res) c[k]->queryMax(p, res);\n            if (c[k ^ 1] && c[k ^ 1]->distMax(p) > res) c[k ^ 1]->queryMax(p, res);\n        }\n        int distMin(const Point &p) {\n            int res = 0;\n            if (p.x < r1.x || p.x > r2.x) res += p.x < r1.x ? r1.x - p.x : p.x - r2.x;\n            if (p.y < r1.y || p.y > r2.y) res += p.y < r1.y ? r1.y - p.y : p.y - r2.y;\n            return res;\n        }\n        void queryMin(const Point &p, int &res) {\n            if (p != this->p) res = std::min(res, dist(p, this->p));\n            if (!c[0] && !c[1]) return;\n            int k = c[0] && c[1] ? c[0]->distMin(p) > c[1]->distMin(p) : (c[0] ? 0 : 1);\n            if (c[k]->distMin(p) < res) c[k]->queryMin(p, res);\n            if (c[k ^ 1] && c[k ^ 1]->distMin(p) < res) c[k ^ 1]->queryMin(p, res);\n        }\n    } *root, _pool[MAXN], *_curr;\n    KDTree() : root(NULL), _curr(_pool) {}\n    Node *build(Point *l, Point *r, int d = 0) {\n        if (l > r) return NULL;\n        if (l == r) return new (_curr++) Node(*l);\n        Point *mid = l + (r - l) / 2;\n        std::nth_element(l, mid, r + 1, d ? cmp1 : cmp2);\n        Node *u = new (_curr++) Node(*mid);\n        u->c[0] = build(l, mid - 1, d ^ 1);\n        u->c[1] = build(mid + 1, r, d ^ 1);\n        u->maintain();\n        return u;\n    }\n    int queryMax(const Point &p) {\n        int res = 0;\n        root->queryMax(p, res);\n        return res;\n    }\n    int queryMin(const Point &p) {\n        int res = INT_MAX;\n        root->queryMin(p, res);\n        return res;\n    }\n} kdT;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    static Point P[MAXN];\n    for (int i = 0; i < n; i++) scanf(\"%d %d\", &P[i].x, &P[i].y);\n    kdT.root = kdT.build(P, P + n - 1);\n    int ans = INT_MAX;\n    for (int i = 0; i < n; i++) ans = std::min(ans, kdT.queryMax(P[i]) - kdT.queryMin(P[i]));\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["k-d树"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] 拉拉队排练","url":"/BZOJ-2160-拉拉队排练/","content":"\n## 题目大意\n\n给定一个长为 $n$ 的字符串（仅由 $26$ 个小写字母组成），找出其所有长度为奇数的回文子串，按长度降序排列，求前 $k$ 个串的长度之积，不足 $k$ 个时输出 $-1$ 。\n\n$1 \\leqslant n \\leqslant 1,000,000$\n\n$1 \\leqslant k \\leqslant 1,000,000,000,000$\n\n## 题目链接\n\n[【国家集训队】啦啦队排练](https://www.luogu.com.cn/problem/P1659)\n\n<!-- more -->\n\n## 题解\n\n回文树裸题。\n\n对串建完回文树后，取出所有的奇数长节点，排序后直接快速幂计算即可。\n\n一开始没看见「奇数」，WA 了 $6$ 遍。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <new>\nconst int MAXN = 1000005;\nconst int CHAR_SET = 'z' - 'a' + 1;\nconst char BASE_CHAR = 'a';\nconst int MOD = 19930726;\nstruct PalinT {\n    int str[MAXN], size;\n    struct Node {\n        int len;\n        long long cnt;\n        Node *c[CHAR_SET], *fail;\n        Node(int len = 0) : len(len), cnt(0), fail(NULL) {\n            for (int i = 0; i < CHAR_SET; i++) c[i] = NULL;\n        }\n    } *root[2], *last, _pool[MAXN], *_curr;\n    PalinT() {\n        _curr = _pool;\n        root[0] = last = new (_curr++) Node(0);\n        root[0]->fail = root[1] = new (_curr++) Node(-1);\n        root[1]->fail = root[1];\n        str[size = 0] = -1;\n    }\n    Node *getFail(Node *u) {\n        while (str[size - u->len - 1] != str[size]) u = u->fail;\n        return u;\n    }\n    void insert(int c) {\n        str[++size] = c;\n        Node *o = getFail(last);\n        if (!o->c[c]) {\n            Node *u = (o->c[c] = new (_curr++) Node(o->len + 2));\n            u->fail = o == root[1] ? root[0] : getFail(o->fail)->c[c];\n        }\n        last = o->c[c];\n        last->cnt++;\n    }\n    void count() {\n        Node *p = _curr - 1;\n        for (; p != _pool; p--) p->fail->cnt += p->cnt;\n        p->fail->cnt += p->cnt;\n    }\n} palinT;\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nint main() {\n    int n;\n    long long k;\n    scanf(\"%d %lld\\n\", &n, &k);\n    for (int i = 0; i < n; i++) palinT.insert(getchar() - BASE_CHAR);\n    palinT.count();\n    static std::vector<std::pair<int, long long> > vec;\n    long long sumCnt = 0;\n    for (PalinT::Node *p = palinT._pool; p != palinT._curr; p++) {\n        if (p->len == 0 || p->len == -1) continue;\n        if (p->len % 2 == 0) continue;\n        vec.push_back(std::make_pair(p->len, p->cnt));\n        sumCnt += p->cnt;\n    }\n    if (k > sumCnt) return puts(\"-1\"), 0;\n    std::sort(vec.begin(), vec.end());\n    long long ans = 1;\n    for (int i = vec.size() - 1; ~i; i--) {\n        if (k > vec[i].second) {\n            (ans *= pow(vec[i].first, vec[i].second)) %= MOD;\n            k -= vec[i].second;\n        } else {\n            (ans *= pow(vec[i].first, k)) %= MOD;\n            k = 0;\n            break;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["字符串","回文自动机"],"categories":["题解（OI/XCPC）"]},{"title":"回文树／回文自动机学习笔记","url":"/回文树／回文自动机学习笔记/","content":"\n我学习的博客：[Palindromic Tree——回文树【处理一类回文串问题的强力工具】| poursoul 的博客 ](http://blog.csdn.net/u013368721/article/details/42100363)\n\n其他参考：[【普及向】回文树 | VictorWonder的博客](http://victorwonder.blog.uoj.ac/blog/146)\n\n## 回文树／回文自动机简介\n\n回文树就是回文自动机，以下皆以「回文树」称呼。\n\n假设我们有一个字符串 $S$ ，$S$ 下标从 $0$ 开始，则回文树能做到如下几点：\n\n* 求 $S$ 前缀 $0 \\sim i$ 内本质不同的回文串的个数\n* 求 $S$ 内每一个本质不同回文串出现的次数\n* 求 $S$ 内回文串的个数\n* 求以下标 $i$ 结尾的回文串的个数\n\n<!-- more-->\n\n## 数据结构的介绍与实现\n\n### 节点\n\n回文树有两个根节点，除这两个根节点以外的节点均表示一个本质不同于其他的回文子串。\n\n每个节点有字符集大小多的子节点，表示在当前回文子串的两端加上某一字符形成的回文子串。\n\n两个根节点的子节点为长度分别是偶数、奇数的回文子串，为方便计算，定义偶树根节点所代表的回文串的长度为 $0$ ，奇数根节点所代表的回文串的长度为 $-1$ （这样，根节点也算是表示了回文子串了。。。）。\n\n每个节点保存其表示的回文子串的长度 $len$ 、出现次数 $cnt$ （在调用 `count()` 方法之后才是，至于 `count()` 方法，一会儿再说）、回文后缀数 $num$ ，同时有一个 $fail$ 指针指向其最大的回文后缀。\n\n偶数根节点的 $fail$ 指针指向奇数根节点，奇数根节点的 $fail$ 指针就是自己（或说没有，因为用不上。。。）。\n\n```c++\nstruct Node {\n    Node *ch[CHAR_SET], *fail;\n    int len, cnt, num;\n    Node(int len = 0) : len(len), cnt(0), num(0) {\n        for (int i = 0; i < CHAR_SET; i++) ch[i] = NULL;\n    }\n};\n```\n\n### 特殊节点\n\n两个根节点在刚刚说了。。。\n\n$last$ 节点：表示目前回文树已插入的所有字符组成的字符串的最大回文后缀（其实就是新插入的节点）。\n\n### 插入与建树\n\n依次插入每个字符就可完成建树。\n\n插入时，先看当前的 $last$ 节点，若它代表的回文子串的左边的字符与插入字符相同，则插入节点为 $last$ 节点的字节点；否则一路沿 $fail$ 指针走下去，直至满足条件。记要插入节点的父节点（也就是找到的节点）为 $o$ 。\n\n实现时，用 `str[size - u->len - 1]` 表示正在插入第 $size$ 个节点、节点 $u$ 所代表的回文子串的左边的字符。由于奇数根节点的长度为 $-1$ ，所以一定会走到一个节点使其满足条件。\n\n如果发现节点 $o$ 已有该字符对应的子节点，则说明已经存在与其本质相同的回文子串，只需为其的 $cnt$ 变量加一即可。否则，建立新节点，其长度为父节点加 $2$ （再一次表明了奇数根节点的长度设为 $-1$ 的方便），同时从 $o.fail$ 开始沿 $fail$ 指针走下去，找到新节点的 $fail$ 指针指向的节点。\n\n```c++\nNode *extend(int c) {\n    s[++size] = c;\n    for (; s[size - last->len - 1] != s[size]; last = last->fail) {}\n\n    Node *v = last;\n    Node *u = v->c[c];\n    if (!u) {\n        u = new (_curr++) Node(last->len + 2);\n        for (last = last->fail; s[size - last->len - 1] != s[size]; last = last->fail) {}\n        u->fail = last == odd && !odd->c[c] ? even : last->c[c];\n        v->c[c] = u;\n    }\n    u->cnt++;\n\n    return last = u;\n}\n\nvoid build(char *s) {\n    int n = strlen(s);\n    for (int i = 0; i < n; i++) insert(s[i] - BASE_CHAR);\n}\n```\n\n### `count()` 方法\n\n来说说之前提过的 `count()` 方法，在外部使用回文树中节点的 $cnt$ 元素之前，必须先调用它。\n\n当然，方法内容很简单，就是把所有节点的 $cnt$ 变量加给其 $fail$ 指针指向的节点。\n\n注意要倒序，也就是从底向上进行。\n\n```c++\nvoid count() {\n    for (Node *p = _curr - 1; p >= _pool; p--) p->fail->cnt += p->cnt;\n}\n```\n\n## 模版题\n\n求最大的 $u.len \\times u.cnt$ ：[【APIO 2014】Palindromes - UOJ 103](http://uoj.ac/problem/103) （[题解](http://pepcy.cf/BZOJ-3676-APIO-2014-回文串)）","tags":["学习笔记","字符串","模版","回文自动机"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[APIO 2014] 回文串","url":"/BZOJ-3676-APIO-2014-回文串/","content":"\n## 题目大意\n\n考虑一个只包含小写拉丁字母的字符串 $s$。我们定义 $s$ 的一个子串 $t$ 的「出现值」为 $t$ 在 $s$ 中的出现次数乘以 $t$ 的长度。请你求出 $s$ 的所有回文子串中的最 大出现值。\n\n$1 \\leqslant |s| \\leqslant 300,000$\n\n## 题目链接\n\n[【APIO 2014】Palindromes - UOJ 103](http://uoj.ac/problem/103)\n\n<!-- more -->\n\n## 题解\n\n回文树模版。（人傻自带大常数系列。。。）\n\n## 代码\n\n调用 `strlen()` 时一定要记得 `#include <cstring>` 。。。（本机是给过的。。。）\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <new>\nconst int MAXN = 300005;\nconst int CHAR_SET = 'z' - 'a' + 1;\nconst char BASE_CHAR = 'a';\nstruct PalinT {\n    int str[MAXN];\n    int size;\n    struct Node {\n        int len, cnt;\n        Node *ch[CHAR_SET], *fail;\n        Node(int len = 0) : len(len), cnt(0) {\n            for (int i = 0; i < CHAR_SET; i++) ch[i] = NULL;\n        }\n    } *root[2], *last, nodes[MAXN], *curr;\n    PalinT() {\n        curr = nodes;\n        root[0] = last = new (curr++) Node(0);\n        root[1] = last->fail = new (curr++) Node(-1);\n        root[1]->fail = root[1];\n        str[size = 0] = -1;\n    }\n    Node *getFail(Node *u) {\n        while (str[size - u->len - 1] != str[size]) u = u->fail;\n        return u;\n    }\n    void insert(int c) {\n        str[++size] = c;\n        Node *o = getFail(last);\n        if (!o->ch[c]) {\n            Node *u = (o->ch[c] = new (curr++) Node(o->len + 2));\n            u->fail = o == root[1] ? root[0] : getFail(o->fail)->ch[c];\n        }\n        last = o->ch[c];\n        last->cnt++;\n    }\n    void build(char *s) {\n        int n = strlen(s);\n        for (int i = 0; i < n; i++) insert(s[i] - BASE_CHAR);\n    }\n    void count() {\n        Node *p = curr - 1;\n        for (; p != nodes; p--) p->fail->cnt += p->cnt;\n        p->fail->cnt += p->cnt;\n    }\n} palinT;\nint main() {\n    static char s[MAXN];\n    scanf(\"%s\", s);\n    palinT.build(s);\n    palinT.count();\n    long long ans = 0;\n    for (PalinT::Node *p = palinT.nodes; p != palinT.curr; p++)\n        ans = std::max(ans, (long long) p->len * p->cnt);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["字符串","模版","回文自动机"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2007] 梦幻岛宝珠","url":"/BZOJ-1190-HNOI-2007-梦幻岛宝珠/","content":"\n## 题目大意\n\n给你 $n$ 颗宝石，每颗宝石都有重量和价值。从这些宝石中选取一些宝石，保证总重量不超过 $W$，求最大的总价值。每颗宝石的重量可表示为 $a \\times 2^b$。多组数据。\n\n$1 \\leqslant T \\leqslant 20$\n\n$1 \\leqslant n \\leqslant 100$\n\n$1 \\leqslant W \\leqslant 2^{30}$\n\n$1 \\leqslant a \\leqslant 10, \\; 1 \\leqslant b \\leqslant 30$\n\n## 题目链接\n\n[【HNOI 2007】梦幻岛宝珠 - Luogu 3188](https://www.luogu.com.cn/problem/P3188)\n\n<!-- more -->\n\n## 题解\n\n数据范围很大但又有特殊性质（只是 $a$ 比较小而已）的 01 背包。\n\n按 $b$ 分类求解多组 01 背包问题。最后再像 01 背包一样合并答案。\n\n由于是按 $b$ 分类的，所以第 $i$ 组的重量 $1$ 是第 $i - 1$ 组的重量 $2$ 。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXB = 35;\nconst int MAXA = 15;\nconst int MAXN = 105;\nint main() {\n    int n, m;\n    while (~scanf(\"%d %d\", &n, &m) && n != -1 && m != -1) {\n        static int wei[MAXB][MAXA], val[MAXB][MAXA], W[MAXB], cnt[MAXB];\n        memset(W, 0, sizeof (W));\n        memset(cnt, 0, sizeof (cnt));\n        int pow = 0;\n        for (int i = 0; i < n; i++) {\n            int x;\n            scanf(\"%d\", &x);\n            int cpow = 0;\n            while (x % 2 == 0) x >>= 1, cpow++;\n            wei[cpow][++cnt[cpow]] = x;\n            W[cpow] += x;\n            scanf(\"%d\", &val[cpow][cnt[cpow]]);\n            pow = std::max(pow, cpow);\n        }\n        static int f[MAXB][MAXA * MAXN];\n        memset(f, 0, sizeof (f));\n        for (int i = 0; i <= pow; i++) {\n            for (int j = 1; j <= cnt[i]; j++) for (int k = W[i]; k >= wei[i][j]; k--)\n                f[i][k] = std::max(f[i][k], f[i][k - wei[i][j]] + val[i][j]);\n        }\n        while (m >> pow) pow++;\n        pow--;\n        for (int i = 1; i <= pow; i++) {\n            W[i] += (W[i - 1] + 1) / 2;\n            for (int j = W[i]; ~j; j--) for (int k = 0; k <= j; k++)\n                f[i][j] = std::max(f[i][j], f[i][j - k] + f[i - 1][std::min(W[i - 1], (k << 1) | ((m >> (i - 1)) & 1))]);\n        }\n        printf(\"%d\\n\", f[pow][1]);\n    }\n    return 0;\n}\n```","tags":["DP","背包DP"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2006] 马步距离","url":"/BZOJ-1193-HNOI-2006-马步距离/","content":"\n## 题目大意\n\n给定起点坐标 $(x_p, \\; y_p)$ 和终点坐标 $(x_s, \\; y_s)$ ，求至少经过多少次马步移动。\n\n$|x|, \\; |y| \\leqslant 10,000,000$\n\n## 题目链接\n\n[【HNOI 2006】马步距离 - Luogu 2060](https://www.luogu.com.cn/problem/P2060)\n\n<!-- more -->\n\n## 题解\n\n大数据贪心，小数据暴力。。。\n\n贪心为：用 $(+2, +1) \\rightarrow (+2, +1)$ 和 $(+2, +1) \\rightarrow (+2, -1)$ 两种移动（中间可以调换 $x$ 坐标与 $y$ 坐标，这里把 $x$ 坐标始终调换为大的那个）把距离缩减到暴力范围内。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <queue>\n#include <algorithm>\nconst int FORCE_LIMIT = 50;\nstruct Point {\n    int x, y, dist;\n    bool vis;\n} P[FORCE_LIMIT * 2 + 1][FORCE_LIMIT * 2 + 1];\nbool valid(int x, int y) {\n    return (x >= 0) && (y >= 0) && (x <= FORCE_LIMIT << 1) && (y <= FORCE_LIMIT << 1);\n}\nint bfs(int x, int y) {\n    for (int i = 0; i <= FORCE_LIMIT << 1; i++) for (int j = 0; j <= FORCE_LIMIT << 1; j++) {\n        P[i][j].x = i;\n        P[i][j].y = j;\n        P[i][j].vis = false;\n    }\n    static int d[8][2] = {\n        {-1, 2}, {1, 2},\n        {-1, -2}, {1, -2},\n        {2, -1}, {2, 1},\n        {-2, -1}, {-2, 1}\n    };\n    std::queue<Point *> q;\n    q.push(&P[x][y]);\n    P[x][y].dist = 0;\n    while (!q.empty()) {\n        Point *u = q.front();\n        q.pop();\n        if (u->vis) continue;\n        u->vis = true;\n        for (int i = 0; i < 8; i++) {\n            int vx = u->x + d[i][0], vy = u->y + d[i][1];\n            if (valid(vx, vy)) {\n                P[vx][vy].dist = u->dist + 1;\n                if (vx == FORCE_LIMIT && vy == FORCE_LIMIT) return P[vx][vy].dist;\n                q.push(&P[vx][vy]);\n            }\n        }\n    }\n    return -1;\n}\nint main() {\n    int sx, sy, tx, ty;\n    scanf(\"%d %d %d %d\", &sx, &sy, &tx, &ty);\n    int dx = abs(tx - sx), dy = abs(ty - sy);\n    int ans = 0;\n    while (dx + dy >= FORCE_LIMIT) {\n        if (dx < dy) std::swap(dx, dy);\n        if (dx - 4 >= dy * 2) dx -= 4;\n        else dx -= 4, dy -= 2;\n        ans += 2;\n    }\n    dx += FORCE_LIMIT, dy += FORCE_LIMIT;\n    printf(\"%d\\n\", bfs(dx, dy) + ans);\n    return 0;\n}\n```","tags":["贪心","搜索"],"categories":["题解（OI/XCPC）"]},{"title":"[CTSC 2007] 数据备份","url":"/BZOJ-1150-CTSC-2007-数据备份/","content":"\n## 题目大意\n\n在一个线段上，顺序给出 $n$ 个点到线段一端的距离。要求用 $k$ 条边连接一共 $2 k$ 个不同的点，边权即为距离。求最小边权和。\n\n$2 \\leqslant n \\leqslant 100,000, \\; 1 \\leqslant k \\leqslant \\frac{n}{2}$\n\n## 题目链接\n\n[【APIO/CTSC 2007】数据备份 - Luogu 3620](https://www.luogu.com.cn/problem/P3620)\n\n<!-- more -->\n\n## 题解\n\n优先队列 + 双向链表 + 乱搞（说「乱搞」是因为确实没有什么可说成是算法的东西。。。不过，那个时候，优先队列的实现没记错应该是手写的，也就是说，这道题本应该是像 Splay 题之类的差不多的数据结构题。。。应该。。。）\n\n首先，显然答案中连接的边不会交叉，所以原题可描述为：给定长为 $n - 1$ 的正整数数列，不连续地选出 $k$ 个数的最小值。\n\n把数列建成双向链表，两头是空指针，同时把所有节点放入优先队列／小根队。\n\n每次取出一个节点，删除它以及前后两个节点（实际给节点打标记，取出来后发现被删除了就继续循环），并在原来的位置上插入一个权值为 $prev.key + next.key - key$ 、代表个数为 $prev.cnt + next.cnt - cnt$ 的节点，当选到时，表示「反悔」选择当前节点并改选两侧节点。一直循环下去，每次减去选出节点的代表个数，直至 $k$ 个数被取完。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 100005;\nstruct Node {\n    long long key;\n    int cnt;\n    bool del;\n    Node *prev, *next;\n    Node() {}\n    Node(long long key, int cnt, Node *prev, Node *next) : key(key), cnt(cnt),\n        prev(prev), next(next), del(false) {}\n    long long getCombineKey() {\n        long long res = -key;\n        if (prev) res += prev->key;\n        else res += INT_MAX;\n        if (next) res += next->key;\n        else res += INT_MAX;\n        return res;\n    }\n    long long getCombineCnt() {\n        long long res = -cnt;\n        if (prev) res += prev->cnt;\n        else res += INT_MAX;\n        if (next) res += next->cnt;\n        else res += INT_MAX;\n        return res;\n    }\n} d[MAXN];\nstruct cmp {\n    bool operator()(Node *a, Node *b) {\n        return a->key > b->key;\n    }\n};\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    std::priority_queue<Node *, std::vector<Node *>, cmp> q;\n    for (int i = 0, last, curr; i < n; i++, last = curr) {\n        scanf(\"%d\", &curr);\n        if (!i) continue;\n        d[i] = Node(curr - last, 1, i != 1 ? &d[i - 1] : NULL, i != n - 1 ? &d[i + 1] : NULL);\n        q.push(&d[i]);\n    }\n    long long ans = 0;\n    while (k > 0) {\n        Node *u = q.top();\n        q.pop();\n        if (u->del) continue;\n        u->del = true;\n        if (u->prev) u->prev->del = true;\n        if (u->next) u->next->del = true;\n        ans += u->key;\n        k -= u->cnt;\n        u = new Node(u->getCombineKey(), u->getCombineCnt(),\n                     u->prev ? u->prev->prev : NULL, u->next ? u->next->next : NULL);\n        if (u->prev) u->prev->next = u;\n        if (u->next) u->next->prev = u;\n        q.push(u);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["乱搞","优先队列","链表"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2008] 下落的圆盘","url":"/BZOJ-1043-HAOI-2008-下落的圆盘/","content":"\n## 题目大意\n\n有 $n$ 个圆盘从天而降，后面落下的可以盖住前面的。求最后所有圆的可见弧长和。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n## 题目链接\n\n[【HAOI 2008】下落的圆盘 - Luogu 2510](https://www.luogu.com.cn/problem/P2510)\n\n<!-- more -->\n\n## 题解\n\n对于每个圆，考虑在之后落下的圆，如果覆盖了当前圆，则当前圆无可见弧（废话）；如果与后面的圆有交点，用余弦定理计算出弧对应的起止角度（用角度保存弧），最后求出未覆盖的弧的角度，求出弧长加入答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nconst int MAXN = 1005;\nconst double PI = acos(-1);\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    double angle() const {\n        return atan2(y, x);\n    }\n    friend double dist(const Point &a, const Point &b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n};\nstruct Arc {\n    double l, r;\n    Arc(double l = 0, double r = 0) : l(l), r(r) {}\n    bool operator<(const Arc &another) const {\n        return l < another.l;\n    }\n};\nstruct Circle {\n    double r;\n    Point o;\n    Circle() {}\n    Circle(const Point &o, double r) : o(o), r(r) {}\n    friend bool contain(const Circle &a, const Circle &b) {\n        return a.r - b.r >= dist(a.o, b.o);\n    }\n    friend Arc getCircleIntersection(const Circle &a, const Circle &b) {\n        double dis = dist(a.o, b.o);\n        double th = acos((a.r * a.r - b.r * b.r + dis * dis) / (2 * a.r * dis));\n        double ath = (b.o - a.o).angle();\n        return Arc(ath - th, ath + th);\n    }\n} C[MAXN];\nint n;\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%lf %lf %lf\", &C[i].r, &C[i].o.x, &C[i].o.y);\n    double ans = 0;\n    for (int i = 0; i < n; i++) {\n        int cnt = 0;\n        static Arc a[MAXN];\n        bool flag = false;\n        for (int j = i + 1; j < n; j++) {\n            if (contain(C[j], C[i])) {\n                flag = true;\n                break;\n            }\n            if (!contain(C[i], C[j]) && C[i].r + C[j].r > dist(C[i].o, C[j].o))\n                a[cnt++] = getCircleIntersection(C[i], C[j]);\n        }\n        if (flag) continue;\n        for (int i = 0; i < cnt; i++) {\n            if (a[i].l < 0) a[i].l += 2 * PI;\n            if (a[i].r < 0) a[i].r += 2 * PI;\n            if (a[i].l > a[i].r) {\n                a[cnt++] = Arc(0, a[i].r);\n                a[i].r = 2 * PI;\n            }\n        }\n        std::sort(a, a + cnt);\n        double temp = 0, curr = 0;\n        for (int i = 0; i < cnt; i++) {\n            if (curr < a[i].l) {\n                temp += a[i].l - curr;\n                curr = a[i].r;\n            } else curr = std::max(curr, a[i].r);\n        }\n        ans += (temp + 2 * PI - curr) * C[i].r;\n    }\n    printf(\"%.3lf\\n\", ans);\n    return 0;\n}\n```","tags":["计算几何"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2007] 降雨量","url":"/BZOJ-1067-SCOI-2007-降雨量/","content":"\n## 题目大意\n\n给出 $n$ 条数据表示 $y_i$ 年的降雨量为 $n_i$ ，保证有 $y_i$ 单调递增。\n\n我们能说「$x$ 是自 $y$ 年以来降雨量最多的一年」当且仅当：\n\n* $n_x \\leqslant n_y$\n* $n_i < n_x \\; (y < i < x)$\n\n给出 $m$ 组询问，询问 $x$ 是否能称作「自 $y$ 年以来降雨量最多的一年」。输出 `true` 表示一定能、`false` 表示一定不能、`maybe` 表示可能能。\n\n$1 \\leqslant n \\leqslant 50,000$\n\n$1 \\leqslant m \\leqslant 10,000$\n\n$1 \\leqslant n_i \\leqslant 1,000,000,000$\n\n$-1,000,000,000 \\leqslant y_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【SCOI 2007】降雨量 - Luogu 2471](https://www.luogu.com.cn/problem/P2471)\n\n<!-- more -->\n\n## 题解\n\nBZOJ 的评论区好像有经典的一楼啊。。。\n\n线段树 + 各种分类。\n\n如果询问的年份及之间的年份的数据都已知，那么可以通过之间的最大值判断是「一定能」还是「一定不能」。\n\n如果两头都未知，那么「可能」。\n\n如果一端已知，通过中间的最大值判断是「可能」还是「一定不能」。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int ly, ry, max;\n        bool known;\n        Node(Node *lc, Node *rc) : lc(lc), rc(rc), known(true) {}\n        int query(int l, int r, int num) {\n            if (l <= ly && ry <= r) {\n                if (max >= num) return 0;\n                return known ? 1 : 2;\n            }\n            if (r <= lc->ry) return lc->query(l, r, num);\n            if (l >= rc->ly) return rc->query(l, r, num);\n            if (lc->ry < l && r < rc->ly) return 2;\n            int ql = lc->query(l, r, num), qr = rc->query(l, r, num);\n            if (!ql || !qr) return 0;\n            if (lc->ry + 1 < rc->ly) return 2;\n            else return 1;\n        }\n        int query(int y) {\n            if (ly == ry) return y == ly ? max : 0;\n            if (y <= lc->ry) return lc->query(y);\n            if (y >= rc->ly) return rc->query(y);\n            return 0;\n        }\n        int queryNext(int y) {\n            if (ly == ry) return ly;\n            if (y < lc->ry) return lc->queryNext(y);\n            else return rc->queryNext(y);\n        }\n        int queryLast(int y) {\n            if (ly == ry) return ly;\n            if (y > rc->ly) return rc->queryLast(y);\n            else return lc->queryLast(y);\n        }\n    } *root;\n    SegT() : root(NULL) {}\n    Node *build(int l, int r) {\n        if (l == r) {\n            Node *u = new Node(NULL, NULL);\n            scanf(\"%d %d\", &u->ly, &u->max);\n            u->ry = u->ly;\n            return u;\n        }\n        int mid = l + (r - l) / 2;\n        Node *u = new Node(build(l, mid), build(mid + 1, r));\n        u->max = std::max(u->lc->max, u->rc->max);\n        u->known = u->lc->known && u->rc->known;\n        if (u->lc->ry + 1 < u->rc->ly) u->known = false;\n        u->ly = u->lc->ly;\n        u->ry = u->rc->ry;\n        return u;\n    }\n    int query(int l, int r, int num) {\n        return root->query(l, r, num);\n    }\n    int query(int y) {\n        return root->query(y);\n    }\n    int queryNext(int y) {\n        return root->queryNext(y);\n    }\n    int queryLast(int y) {\n        return root->queryLast(y);\n    }\n} segT;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    segT.root = segT.build(1, n);\n    int m;\n    scanf(\"%d\", &m);\n    while (m--) {\n        int l, r;\n        scanf(\"%d %d\", &l, &r);\n        if (l > r) {\n            puts(\"false\");\n            continue;\n        }\n        if (l == r) {\n            puts(\"true\");\n            continue;\n        }\n        int lNum = segT.query(l), rNum = segT.query(r);\n        if (!lNum && !rNum) {\n            puts(\"maybe\");\n            continue;\n        }\n        int s = segT.queryNext(l), t = segT.queryLast(r);\n        if (!lNum) {\n            if (s > t || t == r) {\n                puts(\"maybe\");\n                continue;\n            }\n            puts(segT.query(s, t, rNum) ? \"maybe\" : \"false\");\n            continue;\n        }\n        if (!rNum) {\n            if (s > t || s == l) {\n                puts(\"maybe\");\n                continue;\n            }\n            puts(segT.query(s, t, lNum) ? \"maybe\" : \"false\");\n            continue;\n        }\n        if (rNum > lNum) {\n            puts(\"false\");\n            continue;\n        }\n        if (s > t) {\n            puts(l + 1 == r ? \"true\" : \"maybe\");\n            continue;\n        }\n        int temp = segT.query(s, t, rNum);\n        if (!temp) puts(\"false\");\n        else if (temp == 1) puts(l + 1 == s && t + 1 == r ? \"true\" : \"maybe\");\n        else puts(\"maybe\");\n    }\n    return 0;\n}\n```","tags":["线段树"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2006] 数字序列","url":"/BZOJ-1049-HAOI-2006-数字序列/","content":"\n## 题目大意\n\n给定一个长为 $n$ 的序列 $\\{a_i\\}$ ，改变一些数使其成为严格单调递增序列，求需改变数的最少值，以及在这种情况下，每个数改变的绝对值之和的最小值。\n\n$1 \\leqslant n \\leqslant 35,000$\n\n## 题目链接\n\n[【HAOI 2006】数字序列 - Luogu 2501](https://www.luogu.com.cn/problem/P2501)\n\n<!-- more -->\n\n## 题解\n\nDP。\n\n用 $a_i - i$ 得到一个新序列 $\\{b_i\\}$ ，原题变为使其成为不下降序列。\n\n第一问，记 $f(i)$ 表示 $[1, i]$ 的最长不下降子序列\n$$\nf(i) = max(f(j) + 1, \\; b_j \\leqslant b_i) \\quad 0 < j < i\n$$\n答案为 $n - f(n)$。\n\n第二问，在序列两头分别补上序列中的最小值、最大值，记 $g(i)$ 表示区间 $[1, i]$ 在 $b_i$ 不变时的答案\n$$\ng(i) = max(g(j) + cost(i, j), \\; f(i) = f(j) + 1) \\quad 0 \\leqslant j < i\n$$\n其中 $cost(i, j)$ 表示区间 $[i, j]$ 在 $b_i$ 、$b_j$ 不变时的答案。由于有 $f(i) = f(j) + 1$ ，则不存在 $k \\in (i, j)$ 使得 $b_j \\leqslant b_k \\leqslant b_i$ 。对于该区间的最优解，一定是把前一部分改为 $b_j$ ，后一部分改为 $b_i$ ，枚举中间的分割线更新答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\nconst int MAXN = 35005;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    static int a[MAXN];\n    a[0] = INT_MAX;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        a[i] -= i;\n        a[0] = std::min(a[0], a[i]);\n        a[n + 1] = std::max(a[n + 1], a[i]);\n    }\n    static int f[MAXN];\n    for (int i = 1; i <= n; i++) for (int j = 0; j < i; j++) {\n        if (a[j] <= a[i] && f[j] + 1 > f[i]) f[i] = f[j] + 1;\n    }\n    printf(\"%d\\n\", n - f[n]);\n    static int g[MAXN];\n    for (int i = 1; i <= n + 1; i++) {\n        g[i] = INT_MAX;\n        for (int j = 0; j < i; j++) {\n            if (a[j] <= a[i] && f[j] + 1 == f[i]) {\n                int w = 0;\n                for (int k = j + 1; k < i; k++) w += abs(a[k] - a[j]);\n                g[i] = std::min(g[i], g[j] + w);\n                for (int k = i - 1; k > j; k--) {\n                    w -= abs(a[k] - a[j]);\n                    w += abs(a[k] - a[i]);\n                    g[i] = std::min(g[i], g[j] + w);\n                }\n            }\n        }\n    }\n    printf(\"%d\\n\", g[n + 1]);\n    return 0;\n}\n```","tags":["DP"],"categories":["题解（OI/XCPC）"]},{"title":"[SHOI 2008] 安全的航线","url":"/BZOJ-1020-SHOI-2008-安全的航线/","content":"\n## 题目大意\n\n航线用一段有 $n$ 个点的折线表示，$c$  块陆地用不相交的多边形表示，定义「孤地点」为距离最近的陆地最远的地方，求孤地距离。\n\n$2 \\leqslant n \\leqslant 20$\n\n$1 \\leqslant c \\leqslant 20$\n\n$|x|, \\; |y| \\leqslant 10,000$\n\n## 题目链接\n\n[【SHOI 2008】安全的航线 - Luogu 4286](https://www.luogu.com.cn/problem/P4286)\n\n<!-- more -->\n\n## 题解\n\n%%%%% 莫涛神犇：[莫涛《迭代思想的应用》](https://pan.baidu.com/s/1i3rbGqx)\n\n%%%%% ydc 神犇：[BZOJ 1020 | ydc的博客](http://ydcydcy1.blog.163.com/blog/static/21608904020131492229367/)\n\n把折线的每个线段放入队列，用 $n$ 个点更新一波答案。\n\n每取出一条线段，记其两个端点到陆地的最近点为 $p_1$ 、$p_2$，二分找到线段上的点 $p$ 使得 $dist(p, p _1) = dist(p, p_2)$ ，记为 $r$ ，这是当前线段能更新出的最大答案（而且可能去取不到），若有 $r \\leqslant ans$ 则直接删除该线段，否则从 $p$ 处切断线段并放入队列。反复以上操作直至队列为空。\n\n一些细节需要注意，比如要写成 `r <= ans + 0.05` 就不会无法结束算法。\n\n自己的方法名好长。。。（ Java 的既视感？）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <cfloat>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 20;\nconst int MAXC = 20;\nconst int MAXM = 30;\nconst double EPS = 1e-5;\nint dcmp(double x) {\n    if (fabs(x) <= EPS) return 0;\n    if (x > EPS) return 1;\n    return -1;\n}\nint c, n;\ndouble ans;\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    double length() {\n        return sqrt(dot(*this, *this));\n    }\n    Point getPerpendicular() {\n        return Point(-y, x);\n    }\n    friend bool operator==(const Point &a, const Point &b) {\n        return !dcmp(a.x - b.x) && !dcmp(a.y - b.y);\n    }\n    friend Point operator+(const Point &a, const Point &b) {\n        return Point(a.x + b.x, a.y + b.y);\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend Point operator*(const Point &p, const double a) {\n        return Point(p.x * a, p.y * a);\n    }\n    friend Point operator/(const Point &p, const double a) {\n        return Point(p.x / a, p.y / a);\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    friend double dot(const Point &a, const Point &b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    friend double dist(const Point &a, const Point &b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n} flight[MAXN];\nstruct Node {\n    Point p;\n    double dist;\n    Node() {}\n    Node(const Point &p, double dist) : p(p), dist(dist) {}\n};\nstruct Line {\n    Point p, v;\n    Line(const Point &p, const Point &v) : p(p), v(v) {}\n    friend Point getLineIntersection(const Line &a, const Line &b) {\n        Point u = a.p - b.p;\n        double t = cross(b.v, u) / cross(a.v, b.v);\n        return a.p + a.v * t;\n    }\n};\nstruct Segment {\n    Point s, t;\n    Segment(const Point &s, const Point &t) : s(s), t(t) {}\n    friend Node getDistanceToSegment(const Point &p, const Segment &seg) {\n        if (seg.s == seg.t) return Node(seg.s, dist(p, seg.s));\n        Point vSeg = seg.t - seg.s, vs = p - seg.s, vt = p - seg.t;\n        if (dcmp(dot(vSeg, vs)) <= 0) return Node(seg.s, vs.length());\n        if (dcmp(dot(vSeg, vt)) >= 0) return Node(seg.t, vt.length());\n        Point v = vSeg.getPerpendicular();\n        Point inter = getLineIntersection(Line(p, v), Line(seg.s, vSeg));\n        return Node(inter, dist(p, inter));\n    }\n    friend bool isPointOnSegment(const Point &p, const Segment &seg) {\n        return dcmp(cross(seg.s - p, seg.t - p)) == 0 && dcmp(dot(seg.s - p, seg.t - p)) <= 0; \n    }\n};\nstruct Polygen {\n    int size;\n    Point P[MAXM];\n    bool hasCovered(const Point &p) {\n        int windingNum = 0;\n        for (int i = 0; i < size; i++) {\n            if (isPointOnSegment(p, Segment(P[i], P[(i + 1) % size]))) return true;\n            int k = dcmp(cross(P[(i + 1) % size] - P[i], p - P[i]));\n            int d1 = dcmp(P[i].y - p.y);\n            int d2 = dcmp(P[(i + 1) % size].y - p.y);\n            if (k > 0 && d1 <= 0 && d2 > 0) windingNum++;\n            if (k < 0 && d2 <= 0 && d1 > 0) windingNum--;\n        }\n        return windingNum;\n    }\n    Point &operator[](int i) {\n        return P[i];\n    }\n    const Point operator[](int i) const {\n        return P[i];\n    }\n} Poly[MAXC];\nbool isPointInPolygens(const Point &p) {\n    for (int i = 0; i < c; i++) if (Poly[i].hasCovered(p)) return true;\n    return false;\n}\nNode getNode(const Point &p) {\n    if (isPointInPolygens(p)) return Node(p, 0);\n    Node res;\n    res.dist = DBL_MAX;\n    for (int i = 0; i < c; i++) for (int j = 0; j < Poly[i].size; j++) {\n        Node temp = getDistanceToSegment(p, Segment(Poly[i][j], Poly[i][(j + 1) % Poly[i].size]));\n        if (dcmp(res.dist - temp.dist) > 0) res = temp;\n    }\n    ans = std::max(ans, res.dist);\n    return res;\n}\nvoid search() {\n    std::queue<Segment> q;\n    getNode(flight[0]);\n    for (int i = 1; i < n; i++)\n        q.push(Segment(flight[i - 1], flight[i])), getNode(flight[i]);\n    while (!q.empty()) {\n        Segment u = q.front();\n        q.pop();\n        Point p1 = getNode(u.s).p, p2 = getNode(u.t).p;\n        Point l = u.s, r = u.t;\n        while (dcmp(dist(l, r)) > 0) {\n            Point mid = l + (r - l) / 2;\n            if (dist(p1, mid) < dist(p2, mid)) l = mid;\n            else r = mid;\n        }\n        double currLim = std::max(dist(p1, l), dist(p2, l));\n        getNode(l);\n        if (currLim > ans + 0.002) q.push(Segment(u.s, l)), q.push(Segment(l, u.t));\n    }\n}\nint main() {\n    scanf(\"%d %d\", &c, &n);\n    for (int i = 0; i < n; i++) scanf(\"%lf %lf\", &flight[i].x, &flight[i].y);\n    for (int i = 0; i < c; i++) {\n        scanf(\"%d\", &Poly[i].size);\n        for (int j = 0; j < Poly[i].size; j++) scanf(\"%lf %lf\", &Poly[i][j].x, &Poly[i][j].y);\n    }\n    search();\n    printf(\"%.2lf\\n\", ans);\n    return 0;\n}\n```","tags":["计算几何"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2008] 瞭望塔","url":"/BZOJ-1038-ZJOI-2008-瞭望塔/","content":"\n## 题目大意\n\n村子可由一条山的上方轮廓折线 $(x_1, y_1), \\; (x2, y2), \\; \\dots \\; (x_n, y_n)$ 来描述（$x_1 < x_2 < \\dots < x_n$）。瞭望塔可以建造在 $[x_1, x_n]$ 间的任意位置，但必须满足从瞭望塔的顶端可以看到村子的任意位置。求塔的最小高度。\n\n$1 \\leqslant n \\leqslant 300$\n\n$|x|, \\; |y| \\leqslant 1,000,000$\n\n## 题目链接\n\n[【ZJOI 2008】瞭望塔 - Luogu 2600](https://www.luogu.com.cn/problem/P2600)\n\n<!-- more -->\n\n## 题解\n\n半平面交。\n\n对于描述村子的折线中的每一段，都必须满足塔顶在线段所在直线以上。在两侧加两个竖直的辅助直线，求半平面交，塔顶一定在其上；要使塔最低，塔顶就在半平面交得到的下边界上。\n\n由于边界与村子都是分段一次函数，易知答案一定在分段的位置上，枚举分段点更新答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <cmath>\n#include <algorithm>\nconst int MAXN = 305;\nconst double EPS = 1e-14;\nint dcmp(double x) {\n    if (fabs(x) <= EPS) return 0;\n    if (x > EPS) return 1;\n    return -1;\n}\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    friend Point operator+(const Point &a, const Point &b) {\n        return Point(a.x + b.x, a.y + b.y);\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend Point operator*(const Point &p, const double a) {\n        return Point(p.x * a, p.y * a);\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n} P[MAXN], hpi[MAXN];\nstruct Line {\n    Point p, v;\n    double slop;\n    Line() {}\n    Line(const Point &p, const Point &v) : p(p), v(v) {\n        slop = atan2(v.y, v.x);\n    }\n    Point getVal(double t) const {\n        return p + v * t;\n    }\n    bool operator<(const Line &another) const {\n        return slop < another.slop || (slop == another.slop && v.x\n            && getVal(-p.x / v.x).y > getVal(-another.p.x / another.v.x).y);\n    }\n    friend Point getIntersection(const Line &a, const Line &b) {\n        double t = cross(b.v, a.p - b.p) / cross(a.v, b.v);\n        return a.getVal(t);\n    }\n} L[MAXN];\nint n;\nint halfplaneIntersection() {\n    int cnt = 0;\n    L[cnt++] = L[0];\n    for (int i = 1; i <= n; i++) {\n        if (dcmp(L[i].slop - L[i - 1].slop)) L[cnt++] = L[i];\n    }\n    std::sort(L, L + cnt);\n    static Line q[MAXN];\n    static Point p[MAXN];\n    int l = 0, r = 0;\n    q[l] = L[0];\n    for (int i = 1; i < cnt; i++) {\n        while (l < r && dcmp(cross(L[i].v, p[r - 1] - L[i].p)) < 0) r--;\n        while (l < r && dcmp(cross(L[i].v, p[l] - L[i].p)) < 0) l++;\n        q[++r] = L[i];\n        if (l < r) p[r - 1] = getIntersection(q[r - 1], q[r]);\n    }\n    while (l < r && dcmp(cross(q[l].v, p[r - 1] - q[l].p)) < 0) r--;\n    while (l < r && dcmp(cross(q[r].v, p[l] - q[r].p)) < 0) l++;\n    if (r - l <= 1) return 0;\n    cnt = 0;\n    for (int i = l; i < r; i++) hpi[++cnt] = p[i];\n    return cnt;\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lf\", &P[i].x);\n    for (int i = 1; i <= n; i++) scanf(\"%lf\", &P[i].y);\n    P[0] = Point(P[1].x, P[1].y + 1);\n    P[n + 1] = Point(P[n].x, P[n].y + 1);\n    for (int i = 0; i <= n; i++) L[i] = Line(P[i], P[i + 1] - P[i]);\n    int m = halfplaneIntersection();\n    double ans = DBL_MAX;\n    for (int i = 1; i <= m; i++) for (int j = 1; j < n; j++) {\n        Point t(hpi[i].x, -1);\n        if (P[j].x <= hpi[i].x && hpi[i].x <= P[j + 1].x)\n            ans = std::min(ans, hpi[i].y - getIntersection(Line(P[j], P[j + 1] - P[j]), Line(t, hpi[i] - t)).y);\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j < m; j++) {\n        Point t(P[i].x, -1);\n        if (hpi[j].x <= P[i].x && P[i].x <= hpi[j + 1].x)\n            ans = std::min(ans, getIntersection(Line(hpi[j], hpi[j + 1] - hpi[j]), Line(t, P[i] - t)).y - P[i].y);\n    }\n    printf(\"%.3lf\\n\", ans);\n    return 0;\n}\n```","tags":["计算几何","半平面交"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2007] 最大土地面积","url":"/BZOJ-1069-SCOI-2007-最大土地面积/","content":"\n## 题目大意\n\n平面上有 $n$ 个点，可以选择其中的任意四个点将这片土地围起来，求这四个点围成的多边形的最大面积。\n\n$4 \\leqslant n \\leqslant 2,000$\n\n$|x|, \\; |y| \\leqslant 100,000$\n\n## 题目链接\n\n[【SCOI 2007】最大土地面积 - Luogu 4166](https://www.luogu.com.cn/problem/P4166)\n\n<!-- more -->\n\n## 题解\n\n凸包 + 旋转卡壳。\n\n枚举凸包上的一条对角线作为四边形的对角线，在对角线两侧各找到一个点使得两侧的三角形面积最大，可以用旋转卡壳的方法在上一次的基础上快速求得。\n\n如果凸包是三角形，需要特殊处理一下，但数据中好像没有这样的情况。。。（但我还是写了。。。）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\nconst int MAXN = 2005;\nconst double EPS = 1e-9;\nint dcmp(double x) {\n    if (fabs(x) <= EPS) return 0;\n    if (x > EPS) return 1;\n    else return -1;\n}\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    bool operator<(const Point &another) const {\n        return x < another.x || (x == another.x && y < another.y);\n    }\n    bool operator==(const Point &another) const {\n        return !dcmp(x - another.x) && !dcmp(y - another.y);\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n} P[MAXN], ch[MAXN];\nint getConvexHell(int n) {\n    std::sort(P, P + n);\n    int m = 0;\n    for (int i = 0; i < n; i++) {\n        while (m > 1 && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n    int k = m;\n    for (int i = n - 1; ~i; i--) {\n        while (m > k && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n    m > 1 ? m-- : 0;\n    return m;\n}\ndouble rotatingCalipers(int n) {\n    double ans = 0;\n    for (int curr = 0; curr < n; curr++) {\n        int left = (curr + 2) % n, right = (curr + 1) % n;\n        for (int up = (curr + 1) % n; up < n; up++) {\n            Point currV = ch[up] - ch[curr];\n            while ((right + 1) % n != up && cross(ch[right + 1] - ch[curr], currV) > cross(ch[right] - ch[curr], currV))\n                right = (right + 1) % n;\n            while ((left + 1) % n != curr && cross(currV, ch[left + 1] - ch[curr]) > cross(currV, ch[left] - ch[curr]))\n                left = (left + 1) % n;\n            ans = std::max(ans, cross(ch[right] - ch[curr], currV) + cross(currV, ch[left] - ch[curr]));\n        }\n    }\n    return ans;\n}\nvoid calcTriangle(int n) {\n    static bool onConvexHell[MAXN];\n    for (int i = 0; i < n; i++)\n        onConvexHell[i] = (P[i] == ch[0] || P[i] == ch[1] || P[i] == ch[2]);\n    double trianArea = cross(ch[1] - ch[0], ch[2] - ch[0]), ans = 0;\n    for (int i = 0; i < n; i++) if (!onConvexHell[i]) {\n        double temp = std::min(std::min(cross(ch[0] - P[i], ch[1] - P[i]), cross(ch[1] - P[i], ch[2] - P[i])),\n                cross(ch[2] - P[i], ch[0] - P[i]));\n        ans = std::max(ans, trianArea - temp);\n    }\n    printf(\"%.3lf\\n\", ans / 2);\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n    int m = getConvexHell(n);\n    if (m == 3) calcTriangle(n);\n    else printf(\"%.3lf\\n\", rotatingCalipers(m) / 2);\n    return 0;\n}\n```","tags":["计算几何","凸包","旋转卡壳"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2007] 棋盘制作","url":"/BZOJ-1057-ZJOI-2007-棋盘制作/","content":"\n## 题目大意\n\n给定一个 $n \\times m$ 的黑白网格，在其上找一个面积最大的正方形、矩形的黑白相间的网格，输出最大面积。\n\n$1 \\leqslant n, \\; m \\leqslant 2,000$\n\n## 题目链接\n\n[【ZJOI 2007】棋盘制作 - Luogu 1169](https://www.luogu.com.cn/problem/P1169)\n\n<!-- more -->\n\n## 题解\n\n悬线法。\n\n对每个格子 $(i, j)$ ，求出 $up(i, j)$ 、$left(i, j)$ 、$right(i, j)$ 分别表示从该格子向上最远能取多远、以及在取这么远的情况下能向左／右拓展到的最远位置。\n$$\nup(i, j) = \n\\begin{cases}\n1 \\qquad i = 1 \\; or \\; (i, j) = (i - 1, j) \\\\\nup(i - 1, j) + 1 \\qquad (i, j) \\neq (i - 1, j) \\\\\n\\end{cases} \\\\\nleft(i , j)  = \n\\begin{cases}\nlo \\qquad i= 1 \\; or \\;(i, j) = (i - 1, j) \\\\\nmax(left(i - 1, j), \\; lo) \\qquad (i, j) \\neq (i - 1, j) \\\\\n\\end{cases} \\\\\nright(i , j)  = \n\\begin{cases}\nro \\qquad i = 1 \\; or \\; (i, j) = (i - 1, j) \\\\\nmax(right(i - 1, j), \\; ro) \\qquad (i, j) \\neq (i - 1, j) \\\\\n\\end{cases} \\\\\n$$\n其中，$lo$ 每行从左开始计算，表示当前格向左最远能到的位置，$ro$ 与之相反。\n\n扫一遍网格即可求出以上三个数组。此时，对于每个格子 $(i, j)$ ，$up(i, j) \\times (right(i, j) - left(i, j) + 1)$ 表示该点能扩展出的最大的黑白相间的矩形。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 2005;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static int mat[MAXN][MAXN], up[MAXN][MAXN], left[MAXN][MAXN], right[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        scanf(\"%d\", &mat[i][j]);\n        if (i == 1 || mat[i][j] == mat[i - 1][j]) up[i][j] = 1;\n        else up[i][j] = up[i - 1][j] + 1;\n    }\n    for (int i = 1; i <= n; i++) {\n        int lo = 1; \n        for (int j = 1; j <= m; j++) {\n            if (j == 1) {\n                left[i][j] = 1;\n                continue;\n            }\n            if (mat[i][j] == mat[i][j - 1]) lo = j;\n            left[i][j] = lo;\n            if (up[i][j] > 1) left[i][j] = std::max(left[i - 1][j], lo);\n        }\n    }\n    for (int i = 1; i <= n; i++) {\n        int ro = m;\n        for (int j = m; j; j--) {\n            if (j == m) {\n                right[i][j] = m;\n                continue;\n            }\n            if (mat[i][j] == mat[i][j + 1]) ro = j;\n            right[i][j] = ro;\n            if (up[i][j] > 1) right[i][j] = std::min(right[i - 1][j], ro);\n        }\n    }\n    int ansSqr = 0, ansRect = 0;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int bottom = right[i][j] - left[i][j] + 1;\n        int height = up[i][j];\n        ansRect = std::max(ansRect, bottom * height);\n        ansSqr = std::max(ansSqr, std::min(bottom, height) * std::min(bottom, height));\n    }\n    printf(\"%d\\n%d\\n\", ansSqr, ansRect);\n    return 0;\n}\n```","tags":["DP","悬线法"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2007] 合金","url":"/BZOJ-1027-JSOI-2007-合金/","content":"\n## 题目大意\n\n有一种铁、铝、锡的合金，给定 $m$ 种原料合金三元素的百分比，以及 $n$ 种需求合金三元素的百分比，求要能制作出所有的需求合金所需原料合金的最少种数。\n\n$1 \\leqslant n, \\; m \\leqslant 500$\n\n## 题目链接\n\n[【JSOI 2007】合金 - Luogu 4049](https://www.luogu.com.cn/problem/P4049)\n\n<!-- more -->\n\n## 题解\n\n由于三元素百分比之和一定是 $1$ ，所以一种原料或需求可以转化为平面上的点（好神啊）。\n\n发现两种原料能合成对应两点线段上的所有点，多点能合成其围成的多边形内的所有点。\n\n所以问题转化为，有两个点集，从一个点集中选出最少的点围住另一个点集内的所有点。\n\n枚举原料点集内的两点 $i$ 、$j$ ，若需求点集内的所有点都在其向量左前方，则令 $dist(i, j) = 1$ ，否则为无穷，最后用 floyd 求一个最小环，$min\\{dist(i, i)\\}$ 就是答案。\n\n注意特判所有点都重合的情况。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <algorithm>\nconst int MAXN = 505;\nconst double EPS = 1e-10;\nint dcmp(double x) {\n    if (fabs(x) <= EPS) return 0;\n    if (x > EPS) return 1;\n    return -1;\n}\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    friend double dot(const Point &a, const Point &b) {\n        return a.x * b.x + a.y * b.y;\n    }\n} a[MAXN], b[MAXN];\nint m, n;\nint dist[MAXN][MAXN];\nvoid calcDist() {\n    for (int i = 1; i <= m; i++) for (int j = 1; j <= m; j++) dist[i][j] = INT_MAX;\n    for (int i = 1; i <= m; i++) for (int j = 1; j <= m; j++) if (i != j) {\n        bool flag = true;\n        for (int k = 1; k <= n; k++) {\n            int t = dcmp(cross(a[j] - a[i], b[k] - a[i]));\n            if (t < 0 || (t == 0 && dcmp(dot(a[j] - a[i], b[k] - a[i])) < 0)) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) dist[i][j] = 1;\n    }\n}\nvoid floyd() {\n    for (int k = 1; k <= m; k++) for (int i = 1; i <= m; i++) if (dist[i][k] < INT_MAX) {\n        for (int j = 1; j <= m; j++) if (dist[k][j] < INT_MAX)\n            dist[i][j] = std::min(dist[i][j], dist[i][k] + dist[k][j]);\n    }\n}\nbool isSame() {\n    for (int i = 2; i <= m; i++)\n        if (dcmp(a[i].x - a[1].x) || dcmp(a[i].y - a[1].y)) return false;\n    for (int i = 1; i <= n; i++)\n        if (dcmp(b[i].x - a[1].x) || dcmp(b[i].y - a[1].y)) return false;\n    return true;\n}\nint main() {\n    scanf(\"%d %d\", &m, &n);\n    for (int i = 1; i <= m; i++) scanf(\"%lf %lf %*lf\", &a[i].x, &a[i].y);\n    for (int i = 1; i <= n; i++) scanf(\"%lf %lf %*lf\", &b[i].x, &b[i].y);\n    if (isSame()) return puts(\"1\"), 0;\n    calcDist();\n    floyd();\n    int ans = INT_MAX;\n    for (int i = 1; i <= m; i++) ans = std::min(ans, dist[i][i]);\n    if (ans == INT_MAX) puts(\"-1\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["计算几何","Floyd"],"categories":["题解（OI/XCPC）"]},{"title":"[SHOI 2008] 循环的债务","url":"/BZOJ-1021-SHOI-2008-循环的债务/","content":"\n## 题目大意\n\n给定 $A$ 欠 $B$ 、$B$ 欠 $C$ 、$C$ 欠 $A$ 的钱，以及每个人有的 $1$ 、$5$ 、$10$ 、$20$ 、$50$ 、$100$ 的钞票数量，求参与还清债务的最小钞票数，或输出 `impossible` 表示不能还清。\n\n$|x_1|,\\;|x_2|,\\;|x_3| \\leqslant 1,000$\n\n总金额 $\\leqslant 1,000$\n\n## 题目链接\n\n[【SHOI 2008】循环的债务 - Luogu 4026](https://www.luogu.com.cn/problem/P4026)\n\n<!-- more -->\n\n## 题解\n\nDP + 剪枝。\n\n记 $f(i, \\; a, \\; b)$ 表示正在考虑第 $i$ 种面值的钞票（从小到大）、$A$ 有 $a$ 元、$B$ 有 $b$ 元（由于金额不变，所以 $C$ 的钱数可以计算出来）时的答案。\n\n枚举 $i$ ，枚举有意义的 $aLast$ 、$bLast$ ，我们要从 $f(i - 1, \\; aLast, bLast)$ 更新一些 $f(i, xxx, xxx)$ 的答案。\n\n只有六种转移：$A \\rightarrow B,C$、$B \\rightarrow C, A$、$C \\rightarrow A, B$、$A, B \\rightarrow C$、$B, C \\rightarrow A$、$C, A \\rightarrow B$ ，枚举给出去的钞票数并更新。\n\n考虑剪枝，如果用剩下未考虑的钞票无论怎么凑都无法凑出当前金额，则直接跳过，判断是看金额是否是 $d = gdc(100, \\; 50 \\dots 当前面额)$ 的倍数，枚举金额时也每次增加 $d$ 。\n\n## 代码\n\n这题让我突然觉得两格缩进挺好的。。。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\nconst int MAXS = 1005;\nconst int COIN = 6;\nconst int money[6] = {1, 5, 10, 20, 50, 100};\nconst int gcd[6] = {1, 5, 10, 10, 50, 100};\nint f[2][MAXS][MAXS];\nint coin[3][COIN], sm[3], tm[3], sum;\nint dp() {\n    int curr = 0, last = curr ^ 1;\n    for (int i = 0; i < MAXS; i++) for (int j = 0; j < MAXS; j++) f[curr][i][j] = INT_MAX;\n    f[curr][sm[0]][sm[1]] = 0;\n    for (int i = 0; i < COIN; i++) {\n        curr ^= 1, last ^= 1;\n        for (int j = 0; j < MAXS; j++) for (int k = 0; k < MAXS; k++)\n            f[curr][j][k] = f[last][j][k];\n        int d = gcd[i], ca, cb;\n        for (ca = 0; (tm[0] - ca) % d; ca++);\n        for (cb = 0; (tm[1] - cb) % d; cb++);\n        if ((tm[2] - (sum - ca - cb)) % d) continue;\n        for (int aLast = ca; aLast < MAXS && sum - aLast - cb >= 0; aLast += d) {\n            for (int bLast = cb; bLast < MAXS && sum - aLast - bLast >= 0; bLast += d) {\n                int cLast = sum - aLast - bLast;\n                if (f[last][aLast][bLast] == INT_MAX) continue;\n                for (int a = 0; a <= coin[0][i] && a * money[i] <= aLast; a++) {\n                    for (int b = 0; b <= a && bLast + b * money[i] < MAXS; b++) {\n                        if (cLast + (a - b) * money[i] < MAXS)\n                            f[curr][aLast - a * money[i]][bLast + b * money[i]] \n                                = std::min(f[curr][aLast - a * money[i]][bLast + b * money[i]], f[last][aLast][bLast] + a);\n                    }\n                }\n                for (int b = 0; b <= coin[1][i] && b * money[i] <= bLast; b++) {\n                    for (int c = 0; c <= b && cLast + c * money[i] < MAXS; c++) {\n                        if (aLast + (b - c) * money[i] < MAXS)\n                            f[curr][aLast + (b - c) * money[i]][bLast - b * money[i]] \n                                = std::min(f[curr][aLast + (b - c) * money[i]][bLast - b * money[i]], f[last][aLast][bLast] + b);\n                    }\n                }\n                for (int c = 0; c <= coin[2][i] && c * money[i] <= cLast; c++) {\n                    for (int a = 0; a <= c && aLast + a * money[i] < MAXS; a++) {\n                        if (bLast + (c - a) * money[i] < MAXS)\n                            f[curr][aLast + a * money[i]][bLast + (c - a) * money[i]] \n                                = std::min(f[curr][aLast + a * money[i]][bLast + (c - a) * money[i]], f[last][aLast][bLast] + c);\n                    }\n                }\n                for (int a = 0; a <= coin[0][i] && a * money[i] <= aLast; a++) {\n                    for (int b = 0; b <= coin[1][i] && b * money[i] <= bLast; b++) {\n                        if (cLast + (a + b) * money[i] < MAXS)\n                            f[curr][aLast - a * money[i]][bLast - b * money[i]] \n                                = std::min(f[curr][aLast - a * money[i]][bLast - b * money[i]], f[last][aLast][bLast] + a + b);\n                    }\n                }\n                for (int b = 0; b <= coin[1][i] && b * money[i] <= bLast; b++) {\n                    for (int c = 0; c <= coin[2][i] && c * money[i] <= cLast; c++) {\n                        if (aLast + (b + c) * money[i] < MAXS)\n                            f[curr][aLast + (b + c) * money[i]][bLast - b * money[i]] \n                                = std::min(f[curr][aLast + (b + c) * money[i]][bLast - b * money[i]], f[last][aLast][bLast] + b + c);\n                    }\n                }\n                for (int c = 0; c <= coin[2][i] && c * money[i] <= cLast; c++) {\n                    for (int a = 0; a <= coin[0][i] && a * money[i] <= aLast; a++) {\n                        if (bLast + (c + a) * money[i] < MAXS)\n                            f[curr][aLast - a * money[i]][bLast + (c + a) * money[i]] \n                                = std::min(f[curr][aLast - a * money[i]][bLast + (c + a) * money[i]], f[last][aLast][bLast] + c + a);\n                    }\n                }\n            }\n        }\n    }\n    return f[curr][tm[0]][tm[1]];\n}\nint main() {\n    int owe[3];\n    for (int i = 0; i < 3; i++) scanf(\"%d\", &owe[i]);\n    for (int i = 0; i < 3; i++) for (int j = COIN - 1; ~j; j--)\n        scanf(\"%d\", &coin[i][j]), sm[i] += coin[i][j] * money[j];\n    sum = sm[0] + sm[1] + sm[2];\n    tm[0] = sm[0] - owe[0] + owe[2];\n    tm[1] = sm[1] - owe[1] + owe[0];\n    tm[2] = sm[2] - owe[2] + owe[1];\n    if (tm[0] < 0 || tm[1] < 0 || tm[2] < 0) return puts(\"impossible\"), 0;\n    int ans = dp();\n    if (ans == INT_MAX) puts(\"impossible\");\n    else printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["DP"],"categories":["题解（OI/XCPC）"]},{"title":"[SHOI 2008] 汉诺塔","url":"/BZOJ-1019-SHOI-2008-汉诺塔/","content":"\n## 题目大意\n\n给定一组移动盘子的优先顺序，在移动时，要满足一下几点：\n\n* 移动合法\n* 要移动的盘子不是上次移动过的\n* 该移动方案是目前满足以上两条中优先级最高的\n\n求完成 $n$ 层汉诺塔的最小步数。\n\n$1 \\leqslant n \\leqslant 30$\n\n## 题目链接\n\n[【SHOI 2008】汉诺塔 - Luogu 4285](https://www.luogu.com.cn/problem/P4285)\n\n<!-- more -->\n\n## 题解\n\n总想到数学老师喜欢把它叫做「河内塔」。。。感觉莫名喜感。。。\n\n递推。\n\n记 $f(i, \\; j)$ 表示起点柱子为 $i$ 、完成 $j$ 层汉诺塔时的答案，$trans(i, \\; j)$ 为起点柱子为 $i$ 、完成 $j$ 层汉诺塔后盘子被移动到了哪个柱子。\n\n显然，$f(i, \\; 1) = 1$ ，$trans(i, \\; 1)$则可以由读入得到。\n\n考虑计算 $f(i, \\; j)$ ，与正常汉诺塔一样，是把上 $j - 1$ 层移走，移动大盘子，再把那 $j - 1$ 层移过去。\n\n记 $trans(i, \\; j - 1) = a$ ，剩下的一个盘子为 $b = 3 - i - a$ 。那么递推如下：\n$$\nf(i, \\; j) = \n\\begin{cases}\n\\begin{align}\n&f(i, \\; j -1) + 1 + f(a, \\; j - 1) \\qquad trans(a, \\; j - 1) = b \\\\\n&f(i, \\; j - 1) + 1 + f(a, \\; j - 1) + 1 + f(i, \\; j - 1) \\qquad trans(a, \\; j - 1) = i\n\\end{align}\n\\end{cases}\n$$\n\n$$\ntrans(i, \\; j) = \n\\begin{cases}\n\\begin{align}\n&b \\qquad trans(a, \\; j - 1) = b \\\\\n&a \\qquad trans(a, \\; j - 1) = i\n\\end{align}\n\\end{cases}\n$$\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 35;\nlong long f[3][MAXN];\nint trans[3][MAXN];\nvoid dp(int n) {\n    for (int i = 2; i <= n; i++) for (int j = 0; j < 3; j++) {\n        int a = trans[j][i - 1], b = 3 - j - a;\n        if (trans[a][i - 1] == b)\n            trans[j][i] = b, f[j][i] = f[j][i - 1] + 1 + f[a][i - 1];\n        if (trans[a][i - 1] == j)\n            trans[j][i] = a, f[j][i] = f[j][i - 1] + 1 + f[a][i - 1] + 1 + f[j][i - 1];\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < 6; i++) {\n        static bool vis[6];\n        char s[2];\n        scanf(\"%s\", s);\n        int a = s[0] - 'A', b = s[1] - 'A';\n        if (vis[a]) continue;\n        vis[a] = true;\n        f[a][1] = 1;\n        trans[a][1] = b;\n    }\n    dp(n);\n    printf(\"%lld\\n\", f[0][n]);\n    return 0;\n}\n```\n\n","tags":["递推"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2008] 球形空间产生器","url":"/BZOJ-1013-JSOI-2008-球形空间产生器/","content":"\n## 题目大意\n\n给定 $n$ 维空间上一个球面上的 $n + 1$ 个点，求其圆心。数据保证有解。\n\n$1 \\leqslant n \\leqslant 10$\n\n$|坐标| \\leqslant 20,000$\n\n## 题目链接\n\n[【JSOI 2008】球形空间产生器 - Luogu 4035](https://www.luogu.com.cn/problem/P4035)\n\n<!-- more -->\n\n## 题解\n\n考虑两个点 $P$ 、$Q$ ，记圆心为 $O$ ，有\n$$\n\\begin{align}\n\\sum_{i = 1}^{n} (P_i - O_i)^2 &= \\sum_{i = 1}^{n} (Q_i - O_i)^2 \\\\\n\\sum_{i = 1}^{n} P_i^2 - 2 P_i O_i &= \\sum_{i = 1}^{n} Q_i^2 - 2 Q_i O_i \\\\\n\\sum_{i = 1}^{n} 2(P_i - Q_i)O_i &= \\sum_{i = 1}^{n} P_i^2 - Q_i^2\n\\end{align}\n$$\n发现二次项被约掉，于是可以高斯消元解方程。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <algorithm>\n\nconst int MAXN = 10;\nconst double EPS = 1e-7;\n\ndouble a[MAXN][MAXN + 1];\n\nbool GaussJordan(int n) {\n    for (int i = 0; i < n; i++) {\n        int max = i;\n        for (int j = i + 1; j < n; j++) if (fabs(a[j][i]) > fabs(a[max][i])) max = j;\n        if (fabs(a[max][i]) < EPS) return false;\n        if (max != i) for (int j = i; j <= n; j++) std::swap(a[i][j], a[max][j]);\n        for (int j = 0; j < n; j++) if (i != j) {\n            for (int k = n; k >= i; k--) a[j][k] -= a[i][k] / a[i][i] * a[j][i];\n        }\n    }\n    return true;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i <= n; i++) for (int j = 0; j < n; j++) {\n        double x;\n        scanf(\"%lf\", &x);\n        if (i != n) a[i][j] += 2 * x, a[i][n] += x * x;\n        if (i != 0) a[i - 1][j] -= 2 * x, a[i - 1][n] -= x * x;\n    }\n    if (!GaussJordan(n)) return puts(\"-1\"), 0;\n    for (int i = 0; i < n; i++) printf(\"%.3lf%c\", a[i][n] / a[i][i], i == n - 1 ? '\\n' : ' ');\n    return 0;\n}\n```","tags":["高斯消元"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2007] 最小矩形覆盖","url":"/BZOJ-1185-HNOI-2007-最小矩形覆盖/","content":"\n## 题目大意\n\n给定 $n$ 个平面上的点，求覆盖它们的面积最小的矩形。输出矩形面积，**从 $y$ 坐标最小，相同时 $x$ 最小**的点开始逆时针输出矩形的顶点。\n\n$3 \\leqslant n \\leqslant 50,000$\n\n## 题目链接\n\n[【HNOI 2007】最小矩形覆盖 - Luogu 3187](https://www.luogu.com.cn/problem/P3187)\n\n<!-- more -->\n\n## 题解\n\n凸包 + 旋转卡壳。\n\n首先，答案矩形的一条边一定经过凸包的相邻两点，剩下的三条边也各经过一个点（可能重复）。于是，我们可以枚举第一个顶点，也就是经过两个点的那条边，剩下三个点用类似旋转卡壳的方法求出并跟着更新，可以用各种乱搞的方法求出当前的矩形。\n\n不过，**一定要记得点的输出顺序**，我 WA 了好几遍后才看见那句话，还以为是自己求矩形的方法精度炸了。。。（不过最后懒地该回去了。。。是用点在直线上的投影求得矩形的四个顶点）\n\n一共 WA 了八次吧。。。捣鼓了一整天。。。\n\n写完一测样例，以为自己的精度炸了，小数点后第一位就错了，后来发现是自己样例打错了 23333\n\n之后在以为精度继续炸的时候，改用了 `long double` ，可仍然 WA ，甚至在写了正确的输出顺序时也是。后来改回了 `double` 后就 AC 了。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <cmath>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 50005;\nconst double EPS = 1e-9;\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    void print() {\n        if (fabs(x) <= EPS) x = 0;\n        if (fabs(y) <= EPS) y = 0;\n        printf(\"%.5lf %.5lf\\n\", x, y);\n    }\n    Point getPerpendicular() {\n        double X = sqrt(1 / (1 + (x / y) * (x / y)));\n        int sx, sy;\n        if (x > 0 && y > 0) sx = 1, sy = -1;\n        else if (x > 0 && y <= 0) sx = 1, sy = 1;\n        else if (x <= 0 && y > 0) sx = -1, sy = -1;\n        else sx = 1, sy = -1;\n        return Point(sx * X, sy * sqrt(1 - X * X));\n    }\n    bool operator<(const Point &another) const {\n        return x < another.x || (x == another.x && y < another.y);\n    }\n    friend Point operator+(const Point &a, const Point &b) {\n        return Point(a.x + b.x, a.y + b.y);\n    }\n    friend Point operator-(const Point &a, const Point &b) {\n        return Point(a.x - b.x, a.y - b.y);\n    }\n    friend Point operator*(const Point &p, const double a) {\n        return Point(p.x * a, p.y * a);\n    }\n    friend Point operator/(const Point &p, const double a) {\n        return Point(p.x / a, p.y / a);\n    }\n    friend double dot(const Point &a, const Point &b) {\n        return a.x * b.x + a.y * b.y;\n    }\n    friend double cross(const Point &a, const Point &b) {\n        return a.x * b.y - a.y * b.x;\n    }\n    friend double dist(const Point &a, const Point &b) {\n        return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n} P[MAXN], ch[MAXN];\nstruct Rectangle {\n    Point p[4];\n    void print() {\n        int temp = 0;\n        for (int i = 1; i < 4; i++)\n            if (p[i].y < p[temp].y || (p[i].y == p[temp].y && p[i].x < p[temp].x)) temp = i;\n        for (int i = 0; i < 4; i++) p[(i + temp) % 4].print();\n    }\n    Point &operator[](int i) {\n        return p[i];\n    }\n};\nint getConvexHell(int n) {\n    std::sort(P + 1, P + n + 1);\n    int m = 0;\n    for (int i = 1; i <= n; i++) {\n        while (m > 1 && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n    int k = m;\n    for (int i = n; i; i--) {\n        while (m > k && cross(ch[m - 1] - ch[m - 2], P[i] - ch[m - 2]) <= 0) m--;\n        ch[m++] = P[i];\n    }\n    m > 1 ? m-- : 0;\n    return m;\n}\nRectangle ans;\ndouble ansArea = DBL_MAX;\nvoid rotatingCalipers(int n) {\n    for (int curr = 0, right = 1, up = 1, left = 1; curr < n; curr++) {\n        while (dot(ch[curr + 1] - ch[curr], ch[right + 1] - ch[right]) >= 0) right = (right + 1) % n;\n        curr ? 0 : up = right;\n        while (cross(ch[curr + 1] - ch[curr], ch[up + 1] - ch[up]) >= 0) up = (up + 1) % n;\n        curr ? 0 : left = up;\n        while (dot(ch[curr + 1] - ch[curr], ch[left + 1] - ch[left]) <= 0) left = (left + 1) % n;\n        Point currV = ch[curr + 1] - ch[curr];\n        double currLen = dist(ch[curr], ch[curr + 1]);\n        double height = fabs(cross(currV, ch[up] - ch[curr]) / currLen);\n        double bottom = fabs(dot(currV, ch[left] - ch[curr]) / currLen)\n                      + fabs(dot(currV, ch[right] - ch[curr]) / currLen);\n        double currArea = bottom * height;\n        Point currPerpendicular = currV.getPerpendicular();\n        if (currArea < ansArea) {\n            ansArea = currArea;\n            ans[0] = ch[curr] + currV * fabs((dot(currV, ch[right] - ch[curr])) / currLen) / currLen;\n            ans[1] = ans[0] + currPerpendicular * height;\n            ans[2] = ans[1] - currV * bottom / currLen;\n            ans[3] = ans[2] - currPerpendicular * height;\n        }\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lf %lf\", &P[i].x, &P[i].y);\n    int m = getConvexHell(n);\n    rotatingCalipers(m);\n    printf(\"%.5lf\\n\", ansArea);\n    ans.print();\n    return 0;\n}\n```\n\n","tags":["计算几何","凸包","旋转卡壳"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2013] k 大数查询","url":"/BZOJ-3110-ZJOI-2013-k-大数查询/","content":"\n## 题目大意\n\n有 $n$ 个位置，$m$ 个操作。操作有两种：\n\n* `1 a b c` ：在第 $a$ 个位置到第 $b$ 个位置，每个位置加入一个数 $c$。\n* `2 a b c` ：询问从第 $a$ 个位置到第 $b$ 个位置，第 $c$ 大的数是多少。\n\n$1 \\leqslant n, \\; m \\leqslant 50,000$\n\n$1 \\leqslant c \\leqslant n$ （操作一中，并没有负数）\n\n$1 \\leqslant c \\leqslant 2147483647$ \n\n## 题目链接\n\n[【ZJOI 2013】K 大数查询 - Luogu 3332](https://www.luogu.com.cn/problem/P3332)\n\n<!-- more -->\n\n## 题解\n\n整体二分。\n\n二分权值，我们计算右侧对左侧的贡献（当然，可以反过来），用两个容器保存左右两侧要计算哪些操作。\n\n对于插入，如果权值在右侧，我们在线段树／树状数组对应的区间加 $1$ ，放入右侧的容器中；否则直接放入左侧的容器中。（用 `std::vector` 的 `push_down()` 方法可以保证，全程从容器首开始，操作的相对顺序始终就是读入顺序）\n\n对于查询，我们计算出对应区间的个数，如果小于 $c$ ，把 $c$ 减去计算结果放入左侧的容器；否则直接放入右侧的容器。\n\n当权值区间长为 $1$ 时，查询操作的答案就是当前权值。\n\n做这题时，顺便学了一发树状数组区间操作，虽然代码短、快（好像），但没有线段树好写。。。\n\n另外，线段树／树状数组的值会爆 `int`，一些别的地方也会爆。于是光荣的 WA 了五、六次，中间还放了相当长一段时间，代码似乎不够整洁吧。。。\n\n本题亦有权值线段树套区间线段树的做法，感觉除了可能会更慢以外和整体二分其实没什么区别。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n// #define DBG\nconst int MAXN = 50005;\nstruct Operation {\n    int op, l, r, id;\n    long long c;\n    Operation(int id) : id(id) {}\n#ifdef DBG\n    void print() {\n        printf(\"Operation(id = %d)[op = %d, [%d, %d], c = %lld]\\n\", id, op, l, r, c);\n    }\n#endif  \n};\nstruct BinaryIndexedTree {\n    long long c[2][MAXN];\n    int n;\n    static int lowbit(int x) {\n        return x & -x;\n    }\n    void update(long long *c, int pos, long long d) {\n        for (int i = pos; i <= n; i += lowbit(i)) c[i] += d;\n    }\n    void update(int l, int r, long long d) {\n        update(c[0], l, d);\n        update(c[0], r + 1, -d);\n        update(c[1], l, -(l - 1) * d);\n        update(c[1], r + 1, r * d);\n    }\n    long long query(long long *c, int pos) {\n        long long res = 0;\n        for (int i = pos; i; i -= lowbit(i)) res += c[i];\n        return res;\n    }\n    long long query(int l, int r) {\n        return query(c[0], r) * r + query(c[1], r) - query(c[0], l - 1) * (l - 1) - query(c[1], l - 1);\n    }\n    void init(int n) {\n        this->n = n;\n    }\n#ifdef DBG\n    void print() {\n        puts(\"BIT :\");\n        for (int i = 1; i <= n; i++) printf(\"%d%c\", query(i, i), i == n ? '\\n' : ' ');\n    }\n#endif  \n} bit;\nint ans[MAXN];\nvoid divide(int l, int r, std::vector<Operation> &vec) {\n#ifdef DBG\n    printf(\"Divide[%d, %d]\\n\", l, r);\n    for (int i = 0; i < vec.size(); i++) vec[i].print();\n#endif  \n    if (vec.empty()) return;\n    if (l == r) {\n        for (int i = 0; i < vec.size(); i++) ans[vec[i].id] = l;\n        return;\n    }\n    int mid = l + (r - l) / 2;\n    std::vector<Operation> lv, rv;\n    for (int i = 0; i < vec.size(); i++) {\n        Operation &op = vec[i];\n        if (op.op == 1) {\n            if (op.c > mid) bit.update(op.l, op.r, 1), rv.push_back(op);\n            else lv.push_back(op);\n        } else {\n            long long cnt = bit.query(op.l, op.r);\n            if (cnt < op.c) op.c -= cnt, lv.push_back(op);\n            else rv.push_back(op);\n        }\n#ifdef DBG\n        bit.print();\n#endif      \n    }\n    for (int i = 0; i < vec.size(); i++) if (vec[i].op == 1 && vec[i].c > mid)\n        bit.update(vec[i].l, vec[i].r, -1);\n    divide(l, mid, lv);\n    divide(mid + 1, r, rv);\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static bool isQuery[MAXN];\n    std::vector<Operation> vec;\n    for (int i = 1; i <= m; i++) {\n        Operation op(i);\n        scanf(\"%d %d %d %lld\", &op.op, &op.l, &op.r, &op.c);\n        if (op.op == 2) isQuery[i] = true;\n        vec.push_back(op);\n    }\n    bit.init(n);\n    divide(1, n, vec);\n    for (int i = 1; i <= m; i++) if (isQuery[i]) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```","tags":["线段树","二分","整体二分"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2015] 网络吞吐量","url":"/BZOJ-3931-CQOI-2015-网络吞吐量/","content":"\n## 题目大意\n\n给定一个有向图，起点为 $1$ 号点，终点为 $n$ 号点，保证从起点能到达终点，但不存在边 $1 \\rightarrow n$ 。题目有两问：\n\n* 边权 $d$ 表示距离，求起点到终点的最短路。\n* 点权 $c$ 表示点的容量，起点与终点不计，求最大流。\n\n$1 \\leqslant n \\leqslant 500$\n\n$1 \\leqslant m \\leqslant 100,000$\n\n$1 \\leqslant d,\\; c\\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【CQOI 2015】网络吞吐量 - LibreOJ 2096](https://loj.ac/problem/2096)\n\n<!-- more -->\n\n## 题解\n\n第一问直接最短路。\n\n第二问拆点求最大流，只保留在最短路上的边。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 505;\nconst int MAXM = 100005;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    long long w;\n    bool vis;\n} N[MAXN << 1];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    long long w, flow;\n    Edge(Node *u, Node *v, long long w) : u(u), v(v), w(w), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, long long w, bool di = false) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], di ? w : 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dijkstra {\n    struct HeapNode {\n        Node *u;\n        int dist;\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    void dijkstra(Node *s) {\n        std::priority_queue<HeapNode> q;\n        q.push((HeapNode) {s, 0});\n        s->w = 0;\n        while (!q.empty()) {\n            Node *u = q.top().u;\n            q.pop();\n            if (u->vis) continue;\n            u->vis = true;\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->v->w > u->w + e->w) {\n                    e->v->w = u->w + e->w;\n                    q.push((HeapNode) {e->v, e->v->w});\n                }\n            }\n        }\n    }\n    void solve(int s, int n) {\n        for (int i = 1; i <= n; i++) N[i].w = LLONG_MAX;\n        dijkstra(&N[s]);\n    }\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 1; i <= n; i++) N[i].w = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->w = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->w > e->flow && e->v->w == 0) {\n                    e->v->w = u->w + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    long long findPath(Node *s, Node *t, long long limit = LLONG_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->w > e->flow && e->v->w == s->w + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->w - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    long long solve(int s, int t, int n) {\n        long long res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 1; i <= n; i++) N[i].curr = N[i].e;\n            long long flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nvoid clear(int n) {\n    for (int i = 1; i <= n; i++) for (Edge *&e = N[i].e, *next; e; next = e->next, delete e, e = next);\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static int E[MAXM][3];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &E[i][0], &E[i][1], &E[i][2]);\n        addEdge(E[i][0], E[i][1], E[i][2], true);\n    }\n    Dijkstra::solve(1, n);\n    clear(n << 1);\n    for (int i = 0; i < m; i++) {\n        int u = E[i][0], v = E[i][1];\n        long long w = E[i][2];\n        if (N[u].w + w == N[v].w) addEdge(u + n, v, LLONG_MAX);\n        if (N[v].w + w == N[u].w) addEdge(v + n, u, LLONG_MAX);\n    }\n    for (int i = 1; i <= n; i++) {\n        int c;\n        scanf(\"%d\", &c);\n        addEdge(i, i + n, i != 1 && i != n ? c : LLONG_MAX);\n    }\n    printf(\"%lld\\n\", Dinic::solve(1, n << 1, n << 1));\n    return 0;\n}\n```","tags":["网络流","单源最短路"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2009] 最小圈","url":"/BZOJ-1486-HNOI-2009-最小圈/","content":"\n## 题目大意\n\n给定一个带权有向图，定义圈的平均值为一个有向圈上所有边权的平均值，求最小的平均值。数据保证连通、有圈、存在一个点从它开始能到达所有的点。\n\n$1\\leqslant n \\leqslant 3,000$\n\n$1 \\leqslant m \\leqslant 10,000$\n\n$|w_i| \\leqslant 10,000,000$\n\n## 题目链接\n\n[BZOJ 1486](http://www.lydsy.com/JudgeOnline/problem.php?id=1486)\n\n<!-- more -->\n\n## 题解\n\n二分 + dfs 判断。\n\n对于一个有向圈，如果我们减去其平均值（再略大一点），它会成为一个负环，于是我们二分减去的值。判断时，从每个点开始用 dfs 并记录距离，像最短路一样更新（据说是叫「dfs 版的 spfa」），发现负环时返回。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n#include <new>\nconst int MAXN = 3005;\nconst int MAXM = 10005;\nconst double MAXW = 10000005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    double dist;\n    bool vis;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    double w;\n    Edge() {}\n    Edge(Node *u, Node *v, double w) : u(u), v(v), w(w), next(u->e) {}\n} _pool[MAXM], *_cur = _pool;\nvoid addEdge(int u, int v, double w) {\n    N[u].e = new (_cur++) Edge(&N[u], &N[v], w);\n}\nbool dfs(Node *u) {\n    u->vis = true;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->v->dist > u->dist + e->w) {\n            if (e->v->vis) return true;\n            e->v->dist = u->dist + e->w;\n            if (dfs(e->v)) return true;\n        }\n    }\n    u->vis = false;\n    return false;\n}\nint n;\nbool check(double x) {\n    for (Edge *e = _pool; e != _cur; e++) e->w -= x;\n    for (int i = 1; i <= n; i++) N[i].vis = false, N[i].dist = 0;\n    bool flag = false;\n    for (int i = 1; i <= n; i++) if (!flag && dfs(&N[i])) flag = true;\n    for (Edge *e = _pool; e != _cur; e++) e->w += x;\n    return flag;\n}\ndouble dichotomy() {\n    double l = -MAXW, r = MAXW;\n    int lambda = 60;\n    while (lambda--) {\n        double mid = l + (r - l) / 2;\n        if (check(mid)) r = mid;\n        else l = mid;\n    }\n    return l;\n}\nint main() {\n    int m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        double w;\n        scanf(\"%d %d %lf\", &u, &v, &w);\n        addEdge(u, v, w);\n    }\n    printf(\"%.8lf\\n\", dichotomy());\n    return 0;\n}\n```","tags":["DFS","图","单源最短路","二分"],"categories":["题解（OI/XCPC）"]},{"title":"Miller-Rabin 学习笔记","url":"/Miller-Rabin-学习笔记/","content":"\nMiller-Rabin 算法用于判断一个数是否为质数，所谓「素数测试」是也。\n\n## 算法介绍及过程\n\n> **费马小定理**：若 $p$ 为质数，则有 $x^p \\equiv x \\; (\\bmod p)$。\n\n由费马小定理得：\n\n* 若 $n$ 为质数，则 $x^{n - 1} \\equiv 1 \\; (\\bmod n)$ \n* 若 $x^{n - 1} \\not \\equiv 1 \\; (\\bmod n)$ ，则 $n$ 不是质数\n\n如果我们多次随机 $x$ 进行判断，大概率地会得出正确的结果。\n\n<!-- more -->\n\n但是！有一种东西叫**卡迈克尔（Carmichael）数**。\n\n> **卡迈克尔数**：一个数 $n$ 为卡迈克尔数，当且仅当对于所有与 $n$ 互质的数 $x$ 都有 $x^{n - 1} \\equiv 1 \\; (\\bmod n)$，且 $n$ 为和数。\n>\n> 最小的卡迈克尔数是 $561$。\n>\n> [[wiki]](https://zh.wikipedia.org/wiki/卡邁克爾數) [[OEIS:A002997]](https://oeis.org/A002997)\n\n就是这个 $561$，把随机的方法卡了。。。（于是这篇博文是重写的，感谢 VW 学长）\n\n于是我们需要一个准确的算法。\n\n如果对于一定范围内的 $a$ 都有 $a^{n - 1} \\equiv 1 \\; (\\bmod n)$ 时可以保证 $n$ 是质数，那就很不错了。从 [wiki](https://en.wikipedia.org/wiki/Miller–Rabin_primality_test) 上我们知道，这是对的（证明就不要管了。。。），而且对于 `unsigned long long` 范围内的数，只要让 $a$ 等于前 $12$ 个质数即可（来自 wiki，已验证）。\n\n## 对 $a^{n - 1} \\not\\equiv 1 \\; (\\bmod n)$ 判断的一般写法\n\n一般不是直接计算的。。。\n\n把 $n - 1$ 分解为 $2^s d$ （ $d$ 为奇数），用平方差公式分解为：\n$$\na^{n - 1} \\equiv a^{2^s d} \\equiv (a^d - 1) \\prod_{r = 0}^{s - 1} (a^{2^r d} + 1) \\; (\\bmod n)\n$$\n即 $n$ 是合数 $\\Leftrightarrow$ 存在 $a$ 使得：\n\n* $a^d \\not\\equiv 1\\; (\\bmod n)$\n* $a^{2^r d} \\not\\equiv -1\\; (\\bmod n) \\qquad r \\in [0, s - 1]$\n\n## 算法代码\n\n```c++\nlong long mul(long long a, long long b, long long mod) {\n    long long res = 0;\n    for (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n    return res;\n}\nlong long pow(long long a, long long n, long long mod) {\n    long long res = 1;\n    for (; n; n >>= 1, a = mul(a, a, mod)) if (n & 1) res = mul(res, a, mod);\n    return res;\n}\n\nbool isPrime(long long n) {\n    static int primes[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n    long long s = 0, d = n - 1;\n    while (d % 2 == 0) d /= 2, s++;\n    if (s == 0) return n == 2;\n    for (int i = 0; i < 12 && primes[i] < n; i++) {\n        long long a = primes[i];\n        if (pow(a, d, n) != 1) {\n            bool flag = true;\n            for (int r = 0; r < s; r++) \n                if (flag && pow(a, d * (1 << r), n) == n - 1) flag =  false;\n            if (flag) return false;\n        }\n    }\n    return true;\n}\n```","tags":["学习笔记","数论","模版","Miller-Rabin"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[BZOJ 2654] tree","url":"/BZOJ-2654-tree/","content":"\n## 题目大意\n\n给定一个无向带权连通图，每条边是黑色或白色。求一棵边权和最小的恰好有 $need$ 条白色边的生成树。题目保证有解。\n\n$1 \\leqslant n \\leqslant 50,000$\n\n$1 \\leqslant m \\leqslant 100,000$\n\n$1 \\leqslant w_i \\leqslant 100$\n\n## 题目链接\n\n[BZOJ 2654](http://www.lydsy.com/JudgeOnline/problem.php?id=2654)\n\n<!-- more -->\n\n## 题解\n\n二分答案 + Kruskal 判定。\n\n一开始以为是 [【HNOI 2006】公路修建问题](http://pepcy.cf/BZOJ-1196-HNOI-2006-公路修建问题/) ，后来发现那个是「至少有」，本题是「恰好有」。。。\n\n跑两次 MST ，一次边权相同的让白色在前，一次让黑色在前，两次分别求出白色边数的最大值、最小值，如果 $need$ 在范围内，则输出答案，否则考虑如何改变 MST 中白边的数量。\n\n我们二分出一个值（一开始为 $0$），让白边都加上这个值，如果该值为正，则 MST 中白边数可能会减少，为负则可能增加。以此方法直到 $need$ 在范围内，输出答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 50005;\nconst int MAXM = 100005;\nconst int MAXW = 105;\nstruct Edge {\n    int u, v, w, color;\n} E[MAXM];\nbool cmp1(const Edge &a, const Edge &b) {\n    return a.w < b.w || (a.w == b.w && a.color < b.color);\n}\nbool cmp2(const Edge &a, const Edge &b) {\n    return a.w < b.w || (a.w == b.w && a.color > b.color);\n}\nstruct UnionFindSet {\n    int fa[MAXN];\n    int find(int x) {\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    }\n    void merge(int x, int y) {\n        int p = find(x), q = find(y);\n        fa[q] = p;\n    }\n    void init(int n) {\n        for (int i = 1; i <= n; i++) fa[i] = i;\n    }\n} ufs;\nint n, m, need;\nint check(int x) { // 0: more, -1: less, others: answer\n    for (int i = 0; i < m; i++) if (!E[i].color) E[i].w += x;\n    std::sort(E, E + m, cmp1);\n    int max = 0, res = 0;\n    ufs.init(n);\n    for (int i = 0; i < m; i++) {\n        int p = ufs.find(E[i].u), q = ufs.find(E[i].v);\n        if (p == q) continue;\n        ufs.merge(p, q);\n        if (!E[i].color) max++;\n        res += E[i].w;\n    }\n    std::sort(E, E + m, cmp2);\n    int min = 0;\n    ufs.init(n);\n    for (int i = 0; i < m; i++) {\n        int p = ufs.find(E[i].u), q = ufs.find(E[i].v);\n        if (p == q) continue;\n        ufs.merge(p, q);\n        if (!E[i].color) min++;\n    }\n    for (int i = 0; i < m; i++) if (!E[i].color) E[i].w -= x;\n    if (need > max) return -1;\n    if (need < min) return 0;\n    return res - x * need;\n}\nint dichotomy() {\n    int l = -MAXW, r = MAXW;\n    while (l <= r) {\n        int mid = l + (r - l) / 2;\n        int temp = check(mid);\n        if (temp == 0) l = mid + 1;\n        else if (temp == -1) r = mid - 1;\n        else return temp;\n    }\n    return -1;\n}\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &need);\n    for (int i = 0; i < m; i++)\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].w, &E[i].color);\n    printf(\"%d\\n\", dichotomy());\n    return 0;\n}\n```","tags":["图","最小生成树","二分"],"categories":["题解（OI/XCPC）"]},{"title":"Pollard's Rho 学习笔记","url":"/Pollard-s-Rho-学习笔记/","content":"\nPollard's Rho 算法是用于分解质因数的算法。\n\n## 算法介绍与过程\n\n用 [Miller-Rabin 算法](http://pepcy.cf/Miller-Rabin-学习笔记/)判断当前要分解的数是否为质数，若是，在对应位上指数加一，直接返回。\n\n若不是，找到一个数 $p$ 是它为 $n$ 的约数，然后对 $n / p$ 、$p$ 递归求解。\n\n<!-- more -->\n\n假设我们现在要找 $n$ 的一个约数 $p$，先让 $p = n$ ，之后进行计算。\n\n先随机一个数 $x$ ，并令 $y = x$（[wiki](https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm) 上是令 $x = y = 2$ ），按以下方式进行判断：\n\n让 $x = g(x)$ ，计算 $d = gcd(|x - y|, p)$ ，如果 $d$ 是 $1$ 则让 $y = g(g(y))$ （实现时并没有每次都改变 $y$，而是在计算了 $2$、$4$、$8$、$16$ …… 次后让 $y = x$）并继续重复该算法；若 $d = n$，则判断失败（一般返回 $p$ 让重新寻找）；否则返回 $d$ 作为约数。\n\n其中 $g(x)$ 一般为 $g(x) = (x^2 + c) \\bmod p$ ，$c$ 为常数，一般为 $1$ ，在重新计算时改变常数。\n\n如果在寻找时出现了 $x = y$ ，则意味着出现了环，返回失败并让重新寻找。$x$、$y$ 形成的环一般为 $\\rho$ 型，这就是算法名字的由来。另外，取 $x = g(x), \\; y = g(g(y))$ 也是为了能够判圈（就像 Floyd 判圈法）。\n\n吐槽：一开始完全按 wiki 上写的实现，结果卡住了，一直找不到约数 233333\n\n## 算法代码\n\n```c++\n#include <cstdlib>\n\nlong long mul(long long a, long long b, long long mod) {\n    long long res = 0;\n    for (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n    return res;\n}\nlong long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nnamespace PollardRho {\n    long long g(long long x, long long n, long long c) {\n        return (mul(x, x, n) + c) % n;\n    }\n    long long rho(long long n, long long c) {\n        long long x = rand() % n, y = x, d = 1;\n        for (long long i = 1, k = 2; d == 1; i++) {\n            x = g(x, n, c);\n            d = gcd(x > y ? x - y : y - x, n);\n            if (x == y) return n;\n            if (i == k) k <<= 1, y = x;\n        }\n        return d;\n    }\n    void find(long long n, long long c, std::map<long long, int> &res) {\n        if (n == 1) return;\n        if (isPrime(n)) {\n            res[n]++;\n            return;\n        }\n        long long p = n;\n        while (p == n) p = rho(p, c++);\n        find(p, c, res);\n        find(n / p, c, res);\n    }\n    std::map<long long, int> divide(long long n) {\n        std::map<long long, int> res;\n        find(n, 1, res);\n        return res;\n    }\n}\n```","tags":["学习笔记","数论","模版","Pollard's Rho"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[BZOJ 4802] 欧拉函数","url":"/BZOJ-4802-欧拉函数/","content":"\n## 题目大意\n\n给定 $n$，求 $\\varphi(n)$。\n\n$1 \\leqslant n \\leqslant 1 \\times 10^{18}$\n\n## 题目链接\n\n[BZOJ 4802](http://www.lydsy.com/JudgeOnline/problem.php?id=4802)\n\n<!-- more -->\n\n## 题解\n\n一开始，我以为是一个大水题，直到我看见了数据范围。。。后来我就不得不学了 Pollard's Rho 和 Miller-Rabin。\n\nMiller-Rabin 算法用于判断一个数是否为质数（不一定准确）。\n\nPollard's Rho 算法用于分解质因数。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <map>\nlong long mul(long long a, long long b, long long mod) {\n    long long res = 0;\n    for (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n    return res;\n}\nlong long pow(long long a, long long n, long long mod) {\n    long long res = 1;\n    for (; n; n >>= 1, a = mul(a, a, mod)) if (n & 1) res = mul(res, a, mod);\n    return res;\n}\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a *= a) if (n & 1) res *= a;\n    return res;\n}\nlong long gcd(long long a, long long b) {\n    return b ? gcd(b, a % b) : a;\n}\n\nbool isPrime(long long n) {\n    static int primes[12] = {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37};\n    long long s = 0, d = n - 1;\n    while (d % 2 == 0) d /= 2, s++;\n    if (s == 0) return n == 2;\n    for (int i = 0; i < 12 && primes[i] < n; i++) {\n        long long a = primes[i];\n        if (pow(a, d, n) != 1) {\n            bool flag = true;\n            for (int r = 0; r < s; r++) \n                if (flag && pow(a, d * (1 << r), n) == n - 1) flag =  false;\n            if (flag) return false;\n        }\n    }\n    return true;\n}\n \nnamespace PollardRho {\n    long long g(long long x, long long n, long long c) {\n        return (mul(x, x, n) + c) % n;\n    }\n    long long rho(long long n, long long c) {\n        long long x = rand() % n, y = x, d = 1;\n        for (long long i = 1, k = 2; d == 1; i++) {\n            x = g(x, n, c);\n            d = gcd(x > y ? x - y : y - x, n);\n            if (x == y) return n;\n            if (i == k) k <<= 1, y = x;\n        }\n        return d;\n    }\n    void find(long long n, long long c, std::map<long long, int> &res) {\n        if (n == 1) return;\n        if (isPrime(n)) {\n            res[n]++;\n            return;\n        }\n        long long p = n;\n        while (p == n) p = rho(p, c++);\n        find(p, c, res);\n        find(n / p, c, res);\n    }\n    std::map<long long, int> divide(long long n) {\n        std::map<long long, int> res;\n        find(n, 1, res);\n        return res;\n    }\n}\n \nlong long phi(long long n) {\n    std::map<long long, int> fact = PollardRho::divide(n);\n    long long res = 1;\n    for (std::map<long long, int>::iterator it = fact.begin(); it != fact.end(); it++) {\n        res *= pow(it->first, it->second - 1) * (it->first - 1);\n    }\n    return res;\n}\nint main() {\n    srand(23333);\n    long long n;\n    scanf(\"%lld\\n\", &n);\n    printf(\"%lld\\n\", phi(n));\n    return 0;\n}\n```","tags":["数论","模版","欧拉函数","Miller-Rabin","Pollard's Rho"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2016] 手机号码","url":"/BZOJ-4521-CQOI-2016-手机号码/","content":"\n## 题目大意\n\n求 $[l, \\; r]$ 内满足以下条件的数的个数：\n\n* 有三个及以上连着的相同数字\n* $4$ 和 $8$ 不同时存在\n\n$1 \\times 10^{10} \\leqslant l, \\; r < 1 \\times 10^{11}$\n\n## 题目链接\n\n[【CQOI 2016】手机号码](https://loj.ac/problem/2044)\n\n<!-- more -->\n\n## 题解\n\n数位 DP。\n\n计算小于等于一个数的答案，最终答案相减。\n\nDP 时，记 $f(n, limit, last, equal, last, has4, has8)$ 为还剩 $n$ 位（从高位开始）、当前位最大值为 $limit$ 、上一位为 $last$ 、上一位与再上一位是否相等、是否有 $4$ 、是否有 $8$ 时的答案。转移时，枚举每一位，如果同时有 $4$ 和 $8$ 就跳过，否则去考虑下一位。代码中，$limit = 10$ 表示这一位与接下来的位都没有限制。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int LEN = 11;\nconst long long MIN = 1e10;\nint a[LEN];\nlong long f[LEN][11][10][2][2][2][2];\nbool calced[LEN][11][10][2][2][2][2];\nlong long dp(int n, int limit, int last, bool equal, bool flag, bool has4, bool has8) {\n    long long &curr = f[n][limit][last][equal][flag][has4][has8];\n    if (calced[n][limit][last][equal][flag][has4][has8]) return curr;\n    calced[n][limit][last][equal][flag][has4][has8] = true;\n    curr = 0;\n    if (n == 1) {\n        for (int i = 0; i <= std::min(limit, 9); i++) {\n            if ((has4 && has8) || (i == 4 && has8) || (i == 8 && has4)) continue;\n            if (flag || (equal && i == last)) curr++;\n        }\n    } else {\n        int next = a[LEN - n + 1];\n        for (int i = 0; i <= std::min(limit, 9); i++) {\n            if ((has4 && has8) || (i == 4 && has8) || (i == 8 && has4)) continue;\n            int temp = i < limit || limit == 10 ? 10 : next;\n            curr += dp(n - 1, temp, i, i == last, flag || (equal && i == last), \n                       has4 || (i == 4), has8 || (i == 8));\n        }\n    }\n    return curr;\n}\nlong long calc(long long x) {\n    if (x < MIN) return 0;\n    for (int i = LEN - 1; ~i; i--) a[i] = x % 10, x /= 10;\n    memset(calced, false, sizeof (calced));\n    long long res = 0;\n    for (int i = 1; i <= a[0]; i++) {\n        int limit = i == a[0] ? a[1] : 10;\n        res += dp(LEN - 1, limit, i, false, false, i == 4, i == 8);\n    }\n    return res;\n}\nint main() {\n    long long l, r;\n    scanf(\"%lld %lld\", &l, &r);\n    printf(\"%lld\\n\", calc(r) - calc(l - 1));\n    return 0;\n}\n```","tags":["DP","数位DP"],"categories":["题解（OI/XCPC）"]},{"title":"[AHOI 2014] 支线剧情","url":"/BZOJ-3876-AHOI-2014-支线剧情/","content":"\n## 题目大意\n\n考虑一个 DAG ，每条边有边权，同时从任意一个点可以不花费代价地回到起点，求遍历完整个 DAG 的代价（每条边每跑一次就记一次代价）。\n\n$1 \\leqslant n \\leqslant 300$\n\n$0 \\leqslant k_i \\leqslant 50, \\; 0 \\leqslant \\sum k_i \\leqslant 5,000$ （每个顶点的子节点数）\n\n$1 \\leqslant t_{i, j} \\leqslant 300$ （边权）\n\n## 题目链接\n\n[【AHOI 2014】支线剧情 - LibreOJ 2226](https://loj.ac/problem/2226)\n\n<!-- more -->\n\n## 题解\n\n仙剑系列算是我的童年吧。。。\n\n上下界费用流。\n\n把整个 DAG 建成求费用流的图，对于原来的边 $(u, v, w)$ ，改建为 $(u, v, [1, +\\infty], w)$ 。\n\n对于容量上下界的处理，从源点向边指向的点连容量为下界、费用为 $w$ 的边，保证指向的点收到了下界的流量；从边的起点向汇点连容量为下界、费用为 $0$ 的边，保证起点有下界的流量流出；原来的边的容量改为 上界 $-$ 下界。\n\n需要静态分配内存（费用流好慢。。。）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n#include <new>\nconst int MAXN = 305;\nconst int MAXK = 5005;\nstruct Edge;\nstruct Node {\n    Edge *e, *pre;\n    int dist, flow;\n    bool inq;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow, cost;\n    Edge() {}\n    Edge(Node *u, Node *v, int cap, int cost) : u(u), v(v), next(u->e), cap(cap), flow(0), cost(cost) {}\n} _pool[(MAXK + MAXN) << 2], *_cur = _pool;\nvoid addEdge(int u, int v, int cap, int cost){\n    N[u].e = new (_cur++) Edge(&N[u], &N[v], cap, cost);\n    N[v].e = new (_cur++) Edge(&N[v], &N[u], 0, -cost);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace EdmondsKarp {\n    void solve(int s, int t, int n, int &flow, int &cost) {\n        flow = cost = 0;\n        while (true) {\n            for (int i = 0; i < n; i++) {\n                N[i].inq = false;\n                N[i].pre = NULL;\n                N[i].flow = 0;\n                N[i].dist = INT_MAX;\n            }\n            std::queue<Node *> q;\n            N[s].flow = INT_MAX;\n            N[s].dist = 0;\n            q.push(&N[s]);\n            while (!q.empty()) {\n                Node *u = q.front();\n                q.pop();\n                u->inq = false;\n                for (Edge *e = u->e; e; e = e->next) {\n                    if (e->cap > e->flow && e->v->dist > u->dist + e->cost) {\n                        e->v->dist = u->dist + e->cost;\n                        e->v->pre = e;\n                        e->v->flow = std::min(u->flow, e->cap - e->flow);\n                        if (!e->v->inq) {\n                            e->v->inq = true;\n                            q.push(e->v);\n                        }\n                    }\n                }\n            }\n            if (N[t].dist == INT_MAX) break;\n            for (Edge *e = N[t].pre; e; e = e->u->pre) {\n                e->flow += N[t].flow;\n                e->rev->flow -= N[t].flow;\n            }\n            flow += N[t].flow;\n            cost += N[t].flow * N[t].dist;\n        }\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    const int s = 0, t = n + 1;\n    for (int i = 1; i <= n; i++) {\n        int k;\n        scanf(\"%d\", &k);\n        for (int j = 0; j < k; j++) {\n            int v, w;\n            scanf(\"%d %d\", &v, &w);\n            addEdge(i, v, INT_MAX, w);\n            addEdge(s, v, 1, w);\n        }\n        if (k) addEdge(i, t, k, 0);\n        if (i != 1) addEdge(i, 1, INT_MAX, 0);\n    }\n    int flow, cost;\n    EdmondsKarp::solve(s, t, n + 2, flow, cost);\n    printf(\"%d\\n\", cost);\n    return 0;\n}\n```","tags":["费用流","上下界网络流"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] 圈地计划","url":"/BZOJ-2132-圈地计划/","content":"\n## 题目大意\n\n给定一个 $n \\times m$ 的网格，每个位置可选获得两种权值 $a_{i, j}$ 和 $b_{i, j}$ ；同时，如果位置 $(i, \\; j)$ 的四周有 $k$ 个与它所选权值种类不同，将额外获得 $k \\times c_{i, j}$ 的权值。求可获得的最大权值。\n\n$1 \\leqslant n, \\; m \\leqslant 100$\n\n$1 \\leqslant a_{i, j}, \\; b_{i, j}, \\; c_{i, j} \\leqslant 1,000$\n\n## 题目链接\n\n[【国家集训队】圈地计划 - Luogu 1935](https://www.luogu.com.cn/problem/P1935)\n\n<!-- more -->\n\n## 题解\n\n最小割／最大权闭合图。\n\n说实话，直到这道题，我才明白了为什么最大权闭合图的本质是求最小割。（我好菜啊.jpg）\n\n先让相邻的点取不同的权值，对于 $A$ 类点，从源点向其连容量为 $a_{i, j}$ 的边，向汇点连容量为 $b_{i, j}$ 的边， $B$ 类点相反。同时相邻两点间连双向边，容量为两点 $c$ 值的和。用所有权值的和减去最小割，就是答案。\n\n为什么呢？首先，我们得到的答案就是图中不加割边的权值和。考虑相邻两点，割断有两种情况，即都割开与汇（或源）点的边，或割开一条与汇点的边、一条与源点的边，以及它们中间的边。前者表示两点权值种类不同，还剩下权值 $a_u + b_v + c_u + c_v$ ；后者则是两点权值种类相同，还剩下权值 $a_u + a_u$（或 $b_u + b_v$ ）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 105;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), next(u->e), cap(cap), flow(0) {}\n};\nvoid addEdge(int u, int v, int cap, bool bi = false) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], bi ? cap : 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    else q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nint n, m;\nint getID(int x, int y) {\n    return (x - 1) * m + y;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    const int s = 0, t = n * m + 1;\n    int tot = 0;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int w;\n        scanf(\"%d\", &w);\n        tot += w;\n        if ((i + j) % 2 == 0) addEdge(s, getID(i, j), w);\n        else addEdge(getID(i, j), t, w);\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int w;\n        scanf(\"%d\", &w);\n        tot += w;\n        if ((i + j) % 2 == 1) addEdge(s, getID(i, j), w);\n        else addEdge(getID(i, j), t, w);\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int w;\n        scanf(\"%d\", &w);\n        if (i != 1) addEdge(getID(i, j), getID(i - 1, j), w, true), tot += w;\n        if (i != n) addEdge(getID(i, j), getID(i + 1, j), w, true), tot += w;\n        if (j != 1) addEdge(getID(i, j), getID(i, j - 1), w, true), tot += w;\n        if (j != m) addEdge(getID(i, j), getID(i, j + 1), w, true), tot += w;\n    }\n    int maxFlow = Dinic::solve(s, t, t + 1);\n    printf(\"%d\\n\", tot - maxFlow);\n    return 0;\n}\n```","tags":["网络流","最小割","最大权闭合图"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2011] 工作安排","url":"/BZOJ-2245-SDOI-2011-工作安排/","content":"\n## 题目大意\n\n有 $n$ 类产品和 $m$ 个员工，产品的需求量是 $c_i$ ，用一个 01 矩阵表是每个员工能做哪些产品。同时，每个员工会有一个愤怒值，愤怒值与一个员工制作的产品数有分段一次函数关系，具体地说，有 $s_i + 1$ 段，段的分界值为 $t_{i, j}$ 在制作第 $t_{i, j} \\sim t_{i, j + 1}$ 件物品时，每件物品会使其愤怒值增加 $w_{i, j}$ ，保证 $0 < w_{i, j} < w_{i, j + 1}$ ，规定 $t_{i, 0} = 0, \\; t_{i, s_i + 1} = +\\infty$ 。求最小的愤怒值之和。\n\n$1 \\leqslant m, \\; n \\leqslant 250$\n\n$0 \\leqslant s_i \\leqslant 5$\n\n$0 < w_{i, j}, \\; t_{i, j}, \\; c_i \\leqslant 100,000$\n\n## 题目链接\n\n[【SDOI 2011】工作安排 - Luogu 2488](https://www.luogu.com.cn/problem/P2488)\n\n<!-- more -->\n\n## 题解\n\n费用流。\n\n从源点向每个物品连容量为其需求的边，从每个物品向能制作它的员工连容量无穷的边；对于每个员工，从员工向汇点连容量为 $t_{i, j + 1} - t_{i, j}$ 、费用为 $w_{i, j}$ 的边，由于 $w_{i, j}$ 的单调递增，一定会先走一开始的边，所以是正确的。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 255;\nconst int MAXS = 10;\nstruct Edge;\nstruct Node {\n    Edge *e, *pre;\n    int dist, flow;\n    bool inq;\n} N[MAXN << 1];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow, cost;\n    Edge(Node *u, Node *v, int cap, int cost) : u(u), v(v), cap(cap), flow(0), cost(cost), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap, int cost) {\n    N[u].e = new Edge(&N[u], &N[v], cap, cost);\n    N[v].e = new Edge(&N[v], &N[u], 0, -cost);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace EdmondsKarp {\n    void solve(int s, int t, int n, int &flow, long long &cost) {\n        flow = cost = 0;\n        while (true) {\n            for (int i = 0; i < n; i++) {\n                N[i].dist = INT_MAX;\n                N[i].flow = 0;\n                N[i].inq = false;\n                N[i].pre = NULL;\n            }\n            std::queue<Node *> q;\n            q.push(&N[s]);\n            N[s].dist = 0;\n            N[s].flow = INT_MAX;\n            while (!q.empty()) {\n                Node *u = q.front();\n                q.pop();\n                u->inq = false;\n                for (Edge *e = u->e; e; e = e->next) {\n                    if (e->cap > e->flow && e->v->dist > u->dist + e->cost) {\n                        e->v->dist = u->dist + e->cost;\n                        e->v->flow = std::min(u->flow, e->cap - e->flow);\n                        e->v->pre = e;\n                        if (!e->v->inq) {\n                            e->v->inq = true;\n                            q.push(e->v);\n                        }\n                    }\n                }\n            }\n            if (N[t].dist == INT_MAX) break;\n            for (Edge *e = N[t].pre; e; e = e->u->pre) {\n                e->flow += N[t].flow;\n                e->rev->flow -= N[t].flow;\n            }\n            flow += N[t].flow;\n            cost += (long long) N[t].dist * N[t].flow;\n        }\n    }\n}\nint main() {\n    int m, n;\n    scanf(\"%d %d\", &m, &n);\n    const int s = 0, t = n + m + 1;\n    for (int i = 1; i <= n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(s, i, x, 0);\n    }\n    for (int i = 1; i <= m; i++) for (int j = 1; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        if (x) addEdge(j, i + n, INT_MAX, 0);\n    }\n    for (int i = 1; i <= m; i++) {\n        int s;\n        scanf(\"%d\", &s);\n        static int T[MAXS];\n        T[0] = 0;\n        for (int j = 1; j <= s; j++) scanf(\"%d\", &T[j]);\n        T[s + 1] = INT_MAX;\n        int w;\n        for (int j = 1; j <= s + 1; j++) {\n            scanf(\"%d\", &w);\n            addEdge(i + n, t, T[j] - T[j - 1], w);\n        }\n    }\n    int flow;\n    long long cost;\n    EdmondsKarp::solve(s, t, t + 1, flow, cost);\n    printf(\"%lld\\n\", cost);\n    return 0;\n}\n```","tags":["费用流"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2012] 数列","url":"/BZOJ-2656-ZJOI-2012-数列/","content":"\n## 题目大意\n\n给定这么一个数列：\n$$\n\\begin{align}\na_0 &= 0, \\; a_1 = 1 \\\\\na_{2n} &= a_n \\\\\na_{2n + 1} &= a_n + a_{n + 1}\n\\end{align}\n$$\n给定 $n$，求 $a_n$。多组询问。\n\n$1 \\leqslant T \\leqslant 20$\n\n$0 \\leqslant n \\leqslant 1 \\times 10^{100}$\n\n## 题目链接\n\n[【ZJOI 2012】数列 - Luogu 2609](https://www.luogu.com.cn/problem/P2609)\n\n<!-- more -->\n\n## 题解\n\n记忆化搜索 + 高精度。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <map>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 105;\nstruct BigInt {\n    std::vector<char> v;\n    BigInt(int x = 0) {\n        *this = x;\n    }\n    BigInt &operator=(int x) {\n        v.clear();\n        do v.push_back(x % 10); while (x /= 10);\n        return *this;\n    }\n    BigInt &operator=(const BigInt &x) {\n        v.resize(x.v.size());\n        for (int i = 0; i < v.size(); i++) v[i] = x.v[i];\n        return *this;\n    }\n    bool operator<(const BigInt &another) const {\n        if (v.size() != another.v.size()) return v.size() < another.v.size();\n        for (int i = v.size() - 1; ~i; i--) {\n            if (v[i] != another.v[i]) return v[i] < another.v[i];\n        }\n        return false;\n    }\n    BigInt read() {\n        static char s[MAXN];\n        scanf(\"%s\", s);\n        v.clear();\n        int n = strlen(s);\n        for (int i = n - 1; ~i; i--) v.push_back(s[i] - '0');\n        return *this;\n    }\n    bool isOdd() const {\n        return v[0] & 1;\n    }\n    void print() const {\n        for (int i = v.size() - 1; ~i; i--) putchar(v[i] + '0');\n    }\n};\nBigInt operator+(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    res.v.clear();\n    bool flag = false;\n    for (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n        int temp = 0;\n        if (i < a.v.size()) temp += a.v[i];\n        if (i < b.v.size()) temp += b.v[i];\n        if (flag) temp++, flag = false;\n        if (temp >= 10) temp -= 10, flag = true;\n        res.v.push_back(temp);\n    }\n    if (flag) res.v.push_back(1);\n    return res;\n}\nBigInt operator/(const BigInt &a, int b) {\n    BigInt res;\n    res.v.resize(a.v.size());\n    for (int i = a.v.size() - 1, temp = 0; ~i; i--) {\n        temp = a.v[i] + temp * 10;\n        res.v[i] = temp / b;\n        temp %= b;\n    }\n    int size = res.v.size();\n    while (size > 1 && res.v[size - 1] == 0) size--;\n    res.v.resize(size);\n    return res;\n}\nstatic std::map<BigInt, BigInt> f;\nBigInt calc(const BigInt &x) {\n    if (f.find(x) != f.end()) return f[x];\n    BigInt res;\n    if (x.isOdd()) res = calc(x / 2) + calc(x / 2 + 1);\n    else res = calc(x / 2);\n    return f[x] = res;\n}\nint main() {\n    f[0] = 0;\n    f[1] = 1;\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        BigInt x;\n        x.read();\n        calc(x).print();\n        puts(\"\");\n    }\n    return 0;\n}\n```","tags":["高精度","搜索","记忆化搜索"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2003] 严格n元树","url":"/BZOJ-1089-SCOI-2003-严格n元树/","content":"\n## 题目大意\n\n如果一棵树的所有非叶节点都恰好有 $n$ 个儿子，那么我们称它为严格 $n$ 元树。如果该树中最底层的节点深度为 $d$（根的深度为 $0$），那么我们称它为一棵深度为 $d$ 的严格 $n$ 元树。给定 $n$、$d$，求不同的深度为 $d$ 的严格 $n$ 元树有多少个。\n\n$1 \\leqslant n \\leqslant 32$\n\n$1 \\leqslant d \\leqslant 16$\n\n## 题目链接\n\n[【SCOI 2003】严格 N 元树 - Luogu 4295](https://www.luogu.com.cn/problem/P4295)\n\n<!-- more -->\n\n## 题解\n\nDP + 高精度。\n\n定义 $f(d)$ 为答案，$S(d)$ 为 $f(d)$ 的前缀和，表示深度不大于 $d$ 的严格 $n$ 元树的种数。考虑其 $n$ 个子节点，每个都有 $S(d - 1)$ 种可能，再加上只有一个根节点，那么有：\n$$\n\\begin{align}\nS(d) &= S(d - 1)^n + 1 \\\\\nans = f(d) &= S(d) - S(d - 1)\n\\end{align}\n$$\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int MAXD = 20;\nstruct BigInt {\n    std::vector<char> v;\n    BigInt(int x = 0) {\n        *this = x;\n    }\n    BigInt &operator=(int x) {\n        v.clear();\n        do v.push_back(x % 10); while (x /= 10);\n        return *this;\n    }\n    BigInt &operator=(const BigInt &x) {\n        v.resize(x.v.size());\n        for (int i = 0; i < x.v.size(); i++) v[i] = x.v[i];\n        return *this;\n    }\n    void print() const {\n        for (int i = v.size() - 1; ~i; i--) putchar(v[i] + '0');\n    }\n} S[MAXD];\nBigInt operator+(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    res.v.clear();\n    bool flag = false;\n    for (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n        int temp = 0;\n        if (i < a.v.size()) temp += a.v[i];\n        if (i < b.v.size()) temp += b.v[i];\n        if (flag) temp++, flag = false;\n        if (temp >= 10) flag = true, temp -= 10;\n        res.v.push_back(temp);\n    }\n    if (flag) res.v.push_back(1);\n    return res;\n}\nBigInt &operator+=(BigInt &a, const BigInt &b) {\n    return a = a + b;\n}\nBigInt &operator++(BigInt &a) {\n        return a += 1;\n}\nBigInt operator-(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    res.v.clear();\n    bool flag = false;\n    for (int i = 0; i < std::max(a.v.size(), b.v.size()); i++) {\n        int temp = a.v[i];\n        if (i < b.v.size()) temp -= b.v[i];\n        if (flag) temp--, flag = false;\n        if (temp < 0) flag = true, temp += 10;\n        res.v.push_back(temp);\n    }\n    int size = res.v.size();\n    while (size > 1 && res.v[size - 1] == 0) size--;\n    res.v.resize(size);\n    return res;\n}\nBigInt operator*(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    res.v.resize(a.v.size() + b.v.size());\n    for (int i = 0; i < a.v.size(); i++) for (int j = 0; j < b.v.size(); j++) {\n        res.v[i + j] += a.v[i] * b.v[j];\n        res.v[i + j + 1] += res.v[i + j] / 10;\n        res.v[i + j] %= 10;\n    }\n    int size = res.v.size();\n    while (size > 1 && res.v[size - 1] == 0) size--;\n    res.v.resize(size);\n    return res;\n}\nBigInt &operator*=(BigInt &a, const BigInt &b) {\n    return a = a * b;\n}\nBigInt pow(const BigInt &a, int n) {\n    BigInt res(1);\n    for (BigInt x = a; n; n >>= 1, x *= x) if (n & 1) res *= x;\n    return res;\n}\nint main() {\n    int n, d;\n    scanf(\"%d %d\", &n, &d);\n    if (d == 0) {\n        puts(\"1\");\n        return 0;\n    }\n    S[0] = 1;\n    for (int i = 1; i <= d; i++) {\n        S[i] = pow(S[i - 1], n);\n        ++S[i];\n    }\n    (S[d] - S[d - 1]).print();\n    puts(\"\");\n    return 0;\n}\n```","tags":["DP","高精度"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2006] 整数划分","url":"/BZOJ-1263-SCOI-2006-整数划分/","content":"\n## 题目大意\n\n给定一个正整数 $n$，将其划分为若干正整数的和，求这些数的积的最大值，输出答案位数和其前 $100$ 位数字。\n\n$1 \\leqslant n \\leqslant 31,000$\n\n$1 \\leqslant ans \\leqslant 5,000$ （答案位数）\n\n## 题目链接\n\n[【SCOI 2006】整数划分 - Luogu 4157](https://www.luogu.com.cn/problem/P4157)\n\n<!-- more -->\n\n## 题解\n\n若不考虑「划分为整数」的条件，则答案为 $(\\frac{n}{x})^x$，对 $y = (\\frac{n}{x})^x$ 两侧同时取 $\\ln$，对原单调性不影响，有 $\\ln y = x (\\ln n - \\ln x)$，求导有：\n$$\n(\\ln y)' = \\ln n - \\ln x - 1\n$$\n令右侧等于 $0$，得 $x = \\frac{n}{e}$，即分为若干个 $e$，由于 $e$ 四舍五入为 $3$，则答案为划分为尽量多的 $3$ 和几个 $2$。\n\n要高精度（用 [Menci 的代码](https://oi.men.ci/bigint-template/)更新了一下版子）。\n\n另外，那个式子是隔壁[【HNOI 2012】矿场搭建](http://pepcy.cf/BZOJ-2730-HNOI-2012-矿场搭建/)的理论最大答案。。。（应该）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nstruct BigInt {\n    std::vector<char> v;\n    BigInt(int x = 0) {\n        *this = x;\n    }\n    BigInt &operator=(int x) {\n        v.clear();\n        do v.push_back(x % 10); while (x /= 10);\n        return *this;\n    }\n    BigInt &operator=(const BigInt &x) {\n        v.resize(x.v.size());\n        for (int i = 0; i < v.size(); i++) v[i] = x.v[i];\n        return *this;\n    }\n};\nBigInt operator*(const BigInt &a, const BigInt &b) {\n    BigInt res;\n    res.v.resize(a.v.size() + b.v.size());\n    for (int i = 0; i < a.v.size(); i++) for (int j = 0; j < b.v.size(); j++) {\n        res.v[i + j] += a.v[i] * b.v[j];\n        res.v[i + j + 1] += res.v[i + j] / 10;\n        res.v[i + j] %= 10;\n    }\n    int size = res.v.size();\n    while (size > 1 && res.v[size - 1] == 0) size--;\n    res.v.resize(size);\n    return res;\n}\nBigInt &operator*=(BigInt &a, const BigInt &b) {\n    return a = a * b;\n}\nBigInt pow(int a, int n) {\n    BigInt res(1), x(a);\n    for (; n; n >>= 1, x *= x) if (n & 1) res *= x;\n    return res;\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    BigInt ans;\n    if (n % 3 == 0) ans = pow(3, n / 3);\n    else if (n % 3 == 1) ans = pow(3, (n - 4) / 3) * 4;\n    else ans = pow(3, (n - 2) / 3) * 2;\n    printf(\"%d\\n\", (int) ans.v.size());\n    for (int i = ans.v.size() - 1; i >= std::max(0, (int) ans.v.size() - 100); i--) \n        putchar(ans.v[i] + '0');\n    puts(\"\");\n    return 0;\n}\n```","tags":["模版","高精度"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2008] 玩具取名","url":"/BZOJ-1055-HAOI-2008-玩具取名/","content":"\n## 题目大意\n\n给定一个由 $W$，$I$，$N$，$G$ 组成的字符串，并给出一些形如「$XY$ 可由 $Z$ 替代」的规则，最终将字符串化为一个字符，求可能的字符（题目中涉及到的字符均只有 $W$，$I$，$N$，$G$ 四个），否则输出 `The name is wrong!`。\n\n$1 \\leqslant |S| \\leqslant 200$\n\n$1 \\leqslant W,\\; I,\\; N,\\; G \\leqslant 16$\n\n## 题目链接\n\n[【HAOI 2008】玩具取名 - Luogu 4290](https://www.luogu.com.cn/problem/P4290)\n\n<!-- more -->\n\n## 题解\n\n暴力的区间 DP。\n\n记 $f(l, \\; r, \\; c)$ 表示区间 $[l, \\; r]$ 是否能被字符 $c$ 替代，用六层循环暴力地枚举进行 DP。。。（分别枚举区间长、区间起点、区间划分为两个的划分点、左区间的字符、右区间的字符、合并的字符）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\nconst int MAXN = 205;\nconst int CHAR_SET = 4;\nbool f[MAXN][MAXN][CHAR_SET], trans[CHAR_SET][CHAR_SET][CHAR_SET];\nint getID(char c) {\n    if (c == 'W') return 0;\n    if (c == 'I') return 1;\n    if (c == 'N') return 2;\n    if (c == 'G') return 3;\n}\nstatic char s[MAXN];\nvoid dp(int n) {\n    for (int i = 1; i <= n; i++) f[i][i][getID(s[i])] = true;\n    for (int l = 2; l <= n; l++) for (int s = 1; s + l - 1 <= n; s++) {\n        int t = s + l - 1;\n        for (int k = s; k < t; k++) {\n            for (int cl = 0; cl < 4; cl++) if (f[s][k][cl]) {\n                for (int cr = 0; cr < 4; cr++) if (f[k + 1][t][cr]) {\n                    for (int c = 0; c < 4; c++) if (trans[cl][cr][c]) f[s][t][c] = true;\n                }\n            }\n        }\n    }\n}\nint main() {\n    int W, I, N, G;\n    scanf(\"%d %d %d %d\", &W, &I, &N, &G);\n    for (int i = 0; i < W; i++) {\n        char s[2];\n        scanf(\"%s\", s);\n        trans[getID(s[0])][getID(s[1])][0] = true;\n    }\n    for (int i = 0; i < I; i++) {\n        char s[2];\n        scanf(\"%s\", s);\n        trans[getID(s[0])][getID(s[1])][1] = true;\n    }\n    for (int i = 0; i < N; i++) {\n        char s[2];\n        scanf(\"%s\", s);\n        trans[getID(s[0])][getID(s[1])][2] = true;\n    }\n    for (int i = 0; i < G; i++) {\n        char s[2];\n        scanf(\"%s\", s);\n        trans[getID(s[0])][getID(s[1])][3] = true;\n    }\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    dp(n);\n    bool ok = false;\n    char ch[5] = \"WING\";\n    for (int c = 0; c < 4; c++) if (f[1][n][c]) ok = true, putchar(ch[c]);\n    puts(ok ? \"\" : \"The name is wrong!\");\n    return 0;\n}\n```","tags":["DP","区间DP"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] Crash的数字表格","url":"/BZOJ-2154-Crash的数字表格/","content":"\n## 题目大意\n\n给定 $n$、$m$ ，求\n$$\n\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} lcm(i, \\; j) \\bmod 20,101,009\n$$\n$1 \\leqslant n, \\; m \\leqslant 10,000,000$\n\n## 题目链接\n\n[【国家集训队】Crash 的数字表格/ZJPTAB - Luogu 1829](https://www.luogu.com.cn/problem/P1829)\n\n<!-- more -->\n\n## 题解\n\n$$\n\\begin{align}\n&\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} lcm(i, \\; j) \\\\\n= &\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} \\frac{i j}{gcd(i, \\; j)} \\\\\n= &\\sum_{d = 1}^{n} \\frac{1}{d} \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [gcd(i, \\; j) = d]ij \\\\\n= &\\sum_{d = 1}^{n} d \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\sum_{j = 1}^{\\lfloor \\frac{m}{d} \\rfloor} [gcd(i, \\; j) = d]ij \\\\\n\\end{align}\n$$\n\n记后面的和式为 $f(n, \\; m)$。\n$$\n\\begin{align}\nf(n, \\; m) =&\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [gcd(i, \\; j) = d]ij \\\\\n= &\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} i j \\sum_{d | i, \\; d | j} \\mu(d) \\\\\n= &\\sum_{d = 1}^{n} \\mu(d) \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [d | i, \\; d | j] ij \\\\\n= &\\sum_{d = 1}^{n} \\mu(d) \\sum_{d | i} \\sum_{d | j} ij \\\\\n= &\\sum_{d = 1}^{n} \\mu(d) \\sum_{d | i} i \\frac{d \\lfloor \\frac{m}{d} \\rfloor (\\lfloor \\frac{m}{d} + 1 \\rfloor)}{2} \\\\\n= &\\frac{1}{4} \\sum_{d = 1}^{n} \\mu(d) d^2 \\lfloor \\frac{n}{d} \\rfloor \\lfloor \\frac{m}{d} \\rfloor (\\lfloor \\frac{n}{d} + 1\\rfloor) (\\lfloor \\frac{m}{d} + 1 \\rfloor) \\\\\n\\end{align}\n$$\n带回原式：\n$$\n\\begin{align}\n&\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} lcm(i, \\; j) \\\\\n= &\\frac{1}{4} \\sum_{d = 1}^{n} d \\sum_{d' = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(d') d'^2 \\lfloor \\frac{n}{dd'} \\rfloor \\lfloor \\frac{m}{dd'} \\rfloor (\\lfloor \\frac{n}{dd'} + 1\\rfloor) (\\lfloor \\frac{m}{dd'} + 1 \\rfloor) \\\\\n= &\\frac{1}{4} \\sum_{T = 1}^{n} T \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor (\\lfloor \\frac{n}{T} + 1 \\rfloor) (\\lfloor \\frac{m}{T} + 1\\rfloor) \\sum_{d | T} d \\mu(d)\n\\end{align}\n$$\n记 $g(n) = n \\sum_{d | n} d \\mu(d)$，发现它有积性。考虑在线性筛中从 $i$ 转移到 $i \\times p_j$，若有 $p_j | i$，发现多出来的那些项的 $\\mu(d)$ 一项均为 $0$，最后造成的结果是，只有式子中的 $n$ 被乘上了 $p_j$。\n\n其实以上是多组询问时的做法，单组询问的本题并不需要这么麻烦，但我已经推到这了。。。\n\n多组询问版本：[BZOJ 2693](http://www.lydsy.com/JudgeOnline/problem.php?id=2693)（权限题）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 10000005;\nconst int MOD = 20101009;\nlong long f[MAXN];\nint prime[MAXN], primeCnt;\nbool notPrime[MAXN];\nvoid linearShaker() {\n    notPrime[0] = notPrime[1] = true;\n    f[1] = 1;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            f[i] = (long long) i * (1 - i) % MOD;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                f[i * prime[j]] = f[i] * prime[j] % MOD;\n                break;\n            } else f[i * prime[j]] = f[i] * f[prime[j]] % MOD;\n        }\n    }\n    for (int i = 2; i < MAXN; i++) (f[i] += f[i - 1]) %= MOD;\n}\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nlong long calc(int n, int m) {\n    if (n > m) std::swap(n, m);\n    long long res = 0;\n    for (int i = 1, last; i <= n; i = last + 1) {\n        last = std::min(n / (n / i), m / (m / i));\n        res += ((((long long) n / i) * ((long long) n / i + 1) / 2) % MOD)\n             * ((((long long) m / i) * ((long long) m / i + 1) / 2) % MOD) % MOD\n             * (f[last] - f[i - 1]) % MOD;\n    }\n    return (res % MOD + MOD) % MOD;\n}\nint main() {\n    linearShaker();\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    printf(\"%lld\\n\", calc(n, m));\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演","积性函数"],"categories":["题解（OI/XCPC）"]},{"title":"[SPOJ 5971] LCMSum","url":"/BZOJ-2226-SPOJ-5971-LCMSum/","content":"\n## 题目大意\n\n给定 $n$ ，求\n$$\n\\sum_{i = 1}^{n} lcm(i, \\; n)\n$$\n多组询问。\n\n$1 \\leqslant T \\leqslant 300,000$\n\n$1 \\leqslant n \\leqslant 1,000,000$\n\n## 题目链接\n\n[LCMSUM - Luogu SP5971](https://www.luogu.com.cn/problem/SP5971)\n\n[SPOJ 5971 - LCMSUM](http://www.spoj.com/problems/LCMSUM/)\n\n<!-- more -->\n\n## 题解\n\n$$\n\\begin{align}\n&\\sum_{i = 1}^{n} lcm(i, ;\\ n) \\\\\n= &\\sum_{i = 1}^{n} \\frac{n i}{gcd(i, \\; n)} \\\\\n= &n \\sum_{i = 1}^{n} \\frac{i}{gcd(i, \\; n)} \\\\\n= &n \\sum_{d | n} \\frac{1}{d} \\sum_{i = 1}^{n} [gcd(i, \\; n) = d] i  \\\\\n= &n \\sum_{d | n} \\frac{1}{d} \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} [gcd(i, \\; \\lfloor \\frac{n}{d} \\rfloor) = 1] i d \\\\\n= &n \\sum_{d | n} \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} [gcd(i, \\; \\lfloor \\frac{n}{d} \\rfloor) = 1] i \\\\\n\\end{align}\n$$\n\n记后面的和式为 $f(i)$，由于当 $n > 1$ 时，如果有 $gcd(n, \\; x) = 1$，则有 $gcd(n, \\; n - x) = 1$，所以与 $n$ 互质的数是成对出现的，所以有：\n$$\nf(i) = \n\\begin{cases}\n1 \\qquad n = 1 \\\\\n\\frac{n \\varphi(n)}{2} \\qquad n > 1\n\\end{cases}\n$$\n此时答案为 $n \\sum_{d | n} f(d)$，枚举约数，每次询问复杂度大概是 $O(\\sqrt{n})$，考虑进一步优化。\n\n把 $f(i)$ 放回去，$d = 1$ 时补上一个 $1$，则答案为：\n$$\nn (\\sum_{d | n} \\lfloor \\frac{d \\varphi(d)}{2} \\rfloor + 1) = \\frac{n}{2} (\\sum_{d | n}d\\varphi(d) + 1)\n$$\n发现 $g(n) = \\sum_{d | n} d \\varphi(d)$ 具有积性，但我不会推式子。。。\n\n虽然做不到 $O(n)$ 预处理，但 $O(n \\log n)$ 的预处理也够过了。\n\n明明都是小学开始接触的东西，为什么一到了反演，lcm 就比 gcd 复杂了这么多。。。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 1000005;\nlong long phi[MAXN], f[MAXN];\nint prime[MAXN], primeCnt;\nbool notPrime[MAXN];\nvoid shaker() {\n    notPrime[0] = notPrime[1] = true;\n    phi[1] = 1;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n        }\n    }\n    for (int i = 1; i < MAXN; i++) for (int j = i; j < MAXN; j += i) f[j] += i * phi[i];\n}\nlong long calc(int n) {\n    return n * (f[n] + 1) / 2;\n}\nint main() {\n    shaker();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n;\n        scanf(\"%d\", &n);\n        printf(\"%lld\\n\", calc(n));\n    }\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演","积性函数"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4407] 于神之怒加强版","url":"/BZOJ-4407-于神之怒加强版/","content":"\n## 题目大意\n\n给定 $n$、$m$、$k$，求\n$$\n\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} gcd(i, \\; j)^k \\bmod 1,000,000,007\n$$\n多组询问（$k$都相同）。\n\n$1 \\leqslant T \\leqslant 2,000$\n\n$1 \\leqslant n, \\; m, \\; k \\leqslant 5,000,000$\n\n## 题目链接\n\n[BZOJ 4407](http://www.lydsy.com/JudgeOnline/problem.php?id=4407)\n\n<!-- more -->\n\n## 题解\n\n$$\n\\begin{align}\n&\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} gcd(i, \\; j)^k \\\\\n=& \\sum_{d = 1}^{n} d^k \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [gcd(i, \\; j) = d] \\\\\n= &\\sum_{d = 1}^{n} d^k \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(i) \\lfloor \\frac{n}{di} \\rfloor \\lfloor \\frac{m}{di} \\rfloor \\\\\n\\end{align}\n$$\n\n此时，如果每次枚举 $d$，每次询问复杂度是 $O(n \\log k)$ 的（$O(\\log k)$ 来自快速幂，$O(n)$ 来自 $\\sum_{i = 1}^{n} \\sqrt{\\frac{n}{i}}$，画了个图像发现渐近线是 $y = 2x$），会 TLE。不过，似乎有一些卡着时限 AC 的人是这个做法（猜的）。\n\n改变枚举对象为 $T = di$：\n$$\n\\begin{align}\n&\\sum_{d = 1}^{n} d^k \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} \\mu(i) \\lfloor \\frac{n}{di} \\rfloor \\lfloor \\frac{m}{di} \\rfloor \\\\\n= &\\sum_{T = 1}^{n} \\lfloor \\frac{n}{T} \\rfloor \\lfloor \\frac{m}{T} \\rfloor \\sum_{d | T} d^k \\mu(\\lfloor \\frac{T}{d} \\rfloor)\n\\end{align}\n$$\n记后面的和式为 $f(T)$，发现它有积性（积性函数的狄利克雷卷积为积性函数）。\n\n记 $T = \\prod p_i^{x_i}$，有：\n$$\n\\begin{align}\nf(T) = &\\sum_{d | T} d^k \\mu(\\frac{T}{d}) \\\\\n= &\\prod f(p_i^{x_i}) \\\\\n= &\\prod p_i^{x_I} \\mu(1) + p_i^{k(x_i - 1)} \\mu(p_i) \\\\\n= &\\prod p_i^{k(x_i - 1)} (p_i^k - 1)\n\\end{align}\n$$\n可以得到，当 $T = T' \\times p^2$ 时，有 $f(T) = f(T') \\times (f(p) + 1)$。\n\n于是乎，我们就可以用线性筛求 $f(x)$ 函数了。询问时，分块计算。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 5000005;\nconst int MOD = 1000000007;\nlong long f[MAXN];\nint prime[MAXN], primeCnt;\nbool notPrime[MAXN];\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nint k;\nvoid linearShaker() {\n    notPrime[0] = notPrime[1] = true;\n    f[1] = 1;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            f[i] = (pow(i, k) - 1 + MOD) % MOD;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                f[i * prime[j]] = f[i] * (f[prime[j]] + 1) % MOD;\n                break;\n            } else f[i * prime[j]] = f[i] * f[prime[j]] % MOD;\n        }\n    }\n    for (int i = 2; i < MAXN; i++) f[i] = (f[i] + f[i - 1]) % MOD;\n}\nlong long calc(int n, int m) {\n    if (n > m) std::swap(n, m);\n    long long res = 0;\n    for (int i = 1, last; i <= n; i = last + 1) {\n        last = std::min(n / (n / i), m / (m / i));\n        (res += (f[last] - f[i - 1]) * (n / i) % MOD * (m / i) % MOD) %= MOD;\n    }\n    return (res % MOD + MOD) % MOD;\n}\nint main() {\n    int T;\n    scanf(\"%d %d\", &T, &k);\n    linearShaker();\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        printf(\"%lld\\n\", calc(n, m));\n    }\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演","积性函数"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2015] 约数个数和","url":"/BZOJ-3994-SDOI-2015-约数个数和/","content":"\n## 题目大意\n\n记 $d(x)$ 为 $x$ 的约数个数，求\n$$\n\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} d(ij)\n$$\n多组询问。\n\n$1 \\leqslant n, \\; m, \\; T \\leqslant 500,000$\n\n## 题目链接\n\n[【SDOI 2015】约数个数和 - LibreOJ 2185](https://loj.ac/problem/2185)\n\n<!-- more -->\n\n## 题解\n\n首先有\n$$\nd(nm) = \\sum_{i | n} \\sum_{j | m} [gcd(i, \\; j) = 1]\n$$\n那么就可以开始推式子了（默认 $n$ 为更小的）：\n$$\n\\begin{align}\n&\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} d(ij) \\\\\n= &\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} \\sum_{a | i} \\sum_{b | j} [gcd(a, \\; b) = 1] \\\\\n= &\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} \\sum_{a | i} \\sum_{b | j} \\sum_{d | a, \\; d | b} \\mu(d) \\qquad (\\mu \\times 1 = e) \\\\\n= &\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} \\sum_{d | i, \\; d | j} \\mu(d) d(\\lfloor \\frac{i}{d} \\rfloor) d(\\lfloor \\frac{j}{d} \\rfloor) \\\\\n= &\\sum_{d = 1}^{n} \\mu(d) \\sum_{x | i} d(\\lfloor \\frac{i}{d} \\rfloor) \\sum_{d | j} d(\\lfloor \\frac{j}{d} \\rfloor) \\\\\n= &\\sum_{d = 1}^{n} \\mu(d) \\sum_{i = 1}^{\\lfloor \\frac{n}{d} \\rfloor} d(i) \\sum_{j = 1}^{\\lfloor \\frac{m}{d} \\rfloor} d(j)\n\\end{align}\n$$\n可以用线性筛在 $O(n)$ 求出 $d(x)$ 函数、莫比乌斯函数及其前缀和，每次询问 $O(\\sqrt{n})$ 分块求出答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 50005;\nlong long mu[MAXN], d[MAXN];\nint prime[MAXN], primeCnt;\nbool notPrime[MAXN];\nvoid linearShaker() {\n    static int minPrimeCnt[MAXN];\n    notPrime[0] = notPrime[1] = true;\n    mu[1] = d[1] = 1;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            mu[i] = -1;\n            d[i] = 2;\n            minPrimeCnt[i] = 1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                mu[i * prime[j]] = 0;\n                minPrimeCnt[i * prime[j]] = minPrimeCnt[i] + 1;\n                d[i * prime[j]] = d[i] / (minPrimeCnt[i] + 1) * (minPrimeCnt[i] + 2);\n                break;\n            } else {\n                mu[i * prime[j]] = -mu[i];\n                d[i * prime[j]] = d[i] * 2;\n                minPrimeCnt[i * prime[j]] = 1;\n            }\n        }\n    }\n    for (int i = 2; i < MAXN; i++) {\n        mu[i] += mu[i - 1];\n        d[i] += d[i - 1];\n    }\n}\nlong long calc(int n, int m) {\n    if (n > m) std::swap(n, m);\n    long long res = 0;\n    for (int i = 1, last; i <= n; i = last + 1) {\n        last = std::min(n / (n / i), m / (m / i));\n        res += (mu[last] - mu[i - 1]) * d[n / i] * d[m / i];\n    }\n    return res;\n}\nint main() {\n    linearShaker();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        printf(\"%lld\\n\", calc(n, m));\n    }\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2015] 选数","url":"/BZOJ-3930-CQOI-2015-选数/","content":"\n## 题目大意\n\n求从 $[l, \\; r]$ 中可重复地选出 $n$ 个数，使得其 gcd 恰为 $k$ 的方案数，答案对 $1,000,000,007$ 取模。\n\n$1 \\leqslant n, \\;k ,\\;l, \\;r \\leqslant 1,000,000,000$\n\n$0 \\leqslant r - l \\leqslant 100,000$\n\n## 题目链接\n\n[【CQOI 2015】选数 - LibreOJ 2095](https://loj.ac/problem/2095)\n\n<!-- more -->\n\n## 题解\n\n记答案为 $f(k)$，由于 $k$ 可以除去，故可以写成：\n$$\nans = f(1) = \\sum_{a_1 = \\lfloor \\frac{l}{k} \\rfloor}^{\\lfloor \\frac{r}{k} \\rfloor} \\cdots [gcd(a_1, \\; a_2 \\cdots , \\; a_k) = 1]\n$$\n同时设 $F(x)$ 为：\n$$\nF(x) = \\sum_{a_1 = \\lfloor \\frac{l}{k} \\rfloor}^{\\lfloor \\frac{r}{k} \\rfloor} \\cdots [x | gcd(a_1, \\; a_2 \\cdots , \\; a_k)] = \\lfloor \\frac{r - l + 1}{kx} \\rfloor ^{n}\n$$\n显然有：\n$$\nf(x) = \\sum_{x | d} \\mu(\\frac{d}{x}) F(d)\n$$\n即答案为：\n$$\nans = f(1) = \\sum_{d = 1}^{r} \\mu(d) \\lfloor \\frac{r - l + 1}{kd} \\rfloor ^n\n$$\n注意到后面的那个分数经常会为 $0$，用类似莫比乌斯反演分块的方式跳过去即可。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\nconst int MOD = 1000000007;\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nint mu(int n) {\n    int res = 1;\n    for (int i = 2; i * i <= n; i++) {\n        if (n % i == 0) {\n            res *= -1;\n            n /= i;\n            if (n % i == 0) return 0;\n        }\n    }\n    if (n > 1) res *= -1;\n    return res;\n}\nint main() {\n    long long n, k, l, r;\n    scanf(\"%lld %lld %lld %lld\", &n, &k, &l, &r);\n    l = (l - 1) / k, r /= k;\n    long long ans = 0;\n    for (long long i = 1; i <= r; i++) {\n        long long temp = pow(r / i - l / i, n);\n        if (temp > 0) {\n            ans += mu(i) * temp;\n            ans = (ans + MOD) % MOD;\n        } else i = std::min(r / (r / i), l / i ? l / (l / i) : INT_MAX);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 3944] Sum","url":"/BZOJ-3944-Sum/","content":"\n## 题目大意\n\n给定 $n$ ，求 $\\sum_{i = 1}^{n} \\varphi(i)$ 和 $\\sum_{i = 1}^{n} \\mu(i)$，多组询问。\n\n$1 \\leqslant T \\leqslant 10$\n\n$0 \\leqslant n < 2^{31}$ （为什么会有 $0$。。。）\n\n## 题目链接\n\n[BZOJ 3944](http://www.lydsy.com/JudgeOnline/problem.php?id=3944)\n\n<!-- more -->\n\n## 题解\n\n杜教筛模版题。\n\n狄利克雷卷积有 $\\varphi \\times 1 = id$ 、$mu \\times 1 = e$ ，则有：\n$$\n\\begin{align}\n\\Phi(n) &= \\frac{n (n + 1)}{2} - \\sum_{i = 2}^{n} \\Phi(\\lfloor \\frac{n}{i} \\rfloor) \\\\\nM(n) &= 1 - \\sum_{i = 2}^{n} M(\\lfloor \\frac{n}{i} \\rfloor)\n\\end{align}\n$$\n这道题 RE、WA、TEL 了一共大概 $20$ 次，其中四五次是和 [BZOJ 4805](http://pepcy.cf/BZOJ-4805-欧拉函数求和/) 一样的原因，一些是重写了一遍少些了一句的 TLE，一些是蜜汁 RE，一些是蜜汁运算中过了 `int` （好像）而 WA 。。。因为太惨不忍睹了，所以以上有一半是开了小号交的。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <map>\nconst int MAXNN = 1700000;\nlong long phi[MAXNN], mu[MAXNN];\nint prime[MAXNN], primeCnt;\nbool notPrime[MAXNN];\nvoid linearShaker() {\n    notPrime[0] = notPrime[1] = true;\n    phi[1] = mu[1] = 1;\n    for (int i = 2; i < MAXNN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            phi[i] = i - 1;\n            mu[i] = -1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXNN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                mu[i * prime[j]] = 0;\n                break;\n            } else {\n                phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n                mu[i * prime[j]] = -mu[i];\n            }\n        }\n    }\n    for (int i = 2; i < MAXNN; i++) phi[i] += phi[i - 1], mu[i] += mu[i - 1];\n}\nlong long pSumPhi(long long n) {\n    if (n < MAXNN) return ::phi[n];\n    static std::map<int, long long> phi;\n    std::map<int, long long>::iterator it;\n    if ((it = phi.find(n)) != phi.end()) return it->second;\n    long long res = (long long) n * (n + 1) / 2, last;\n    for (long long i = 2; i <= n; i = last + 1) {\n        last = n / (n / i);\n        res -= (last - i + 1) * pSumPhi(n / i);\n    }\n    return phi[n] = res;\n}\nlong long pSumMu(long long n) {\n    if (n < MAXNN) return ::mu[n];\n    static std::map<int, long long> mu;\n    std::map<int, long long>::iterator it;\n    if ((it = mu.find(n)) != mu.end()) return it->second;\n    long long res = 1, last;\n    for (long long i = 2; i <= n; i = last + 1) {\n        last = n / (n / i);\n        res -= (last - i + 1) * pSumMu(n / i);\n    }\n    return mu[n] = res;\n}\nint main() {\n    linearShaker();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        long long n;\n        scanf(\"%lld\", &n);\n        printf(\"%lld %lld\\n\", pSumPhi(n), pSumMu(n));\n    }\n    return 0;\n}\n```","tags":["数论","模版","线性筛","莫比乌斯反演","杜教筛"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4805] 欧拉函数求和","url":"/BZOJ-4805-欧拉函数求和/","content":"\n## 题目大意\n\n给定 $n$，求\n\n$$\\sum_{i = 1}^{n} \\varphi(i)$$\n\n$1 \\leqslant n \\leqslant 2,000,000,000$\n\n## 题目链接\n\n[BZOJ 4805](http://www.lydsy.com/JudgeOnline/problem.php?id=4805)\n\n<!-- more -->\n\n## 题解\n\n杜教筛模版题。\n\n狄利克雷卷积有 $\\varphi \\times 1 = id$，则有：\n$$\n\\Phi(n) = \\frac{n (n + 1)}{2} - \\sum_{i = 2}^{n} \\Phi(\\lfloor \\frac{n}{i} \\rfloor)\n$$\n预处理出前 $n^{\\frac{2}{3}}$ 项，复杂度为 $O(n^{\\frac{2}{3}})$。\n\n## 代码\n\n把 `< MAXNN`  写成了 `<= MAXNN`，RE了四次。。。\n\n```c++\n#include <cstdio>\n#include <map>\nconst int MAXNN = 1600000;\nlong long phi[MAXNN];\nint prime[MAXNN], primeCnt;\nbool notPrime[MAXNN];\nvoid linearShaker() {\n    phi[1] = 1;\n    notPrime[0] = notPrime[1] = true;\n    for (int i = 2; i < MAXNN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXNN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n        }\n    }\n    for (int i = 2; i < MAXNN; i++) phi[i] += phi[i - 1];\n}\nlong long pSumPhi(int n) {\n    if (n < MAXNN) return ::phi[n];\n    static std::map<int, long long> phi;\n    std::map<int, long long>::iterator it;\n    if ((it = phi.find(n)) != phi.end()) return it->second;\n    long long res = (long long) n * (n + 1) / 2;\n    int last;\n    for (int i = 2; i <= n; i = last + 1) {\n        last = n / (n / i);\n        res -= (last - i + 1) * pSumPhi(n / i);\n    }\n    return phi[n] = res;\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    linearShaker();\n    printf(\"%lld\\n\", pSumPhi(n));\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演","杜教筛"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2010] 海拔","url":"/BZOJ-2007-NOI-2010-海拔/","content":"\n## 题目大意\n\n有一个 $n \\times m$ 的网格，网格顶点是城市，同时有一个海拔（不一定是整数），左上角的海拔为 $0$，右下角为 $1$，海拔各不相等。给定两点间的流量（路的两个方向流量不一定相同），若海拔上升，则消耗体力为 流量 $\\times$ 海拔差。求最小的体力消耗，答案四舍五入为整数。\n\n$1 \\leqslant n ,\\; m \\leqslant 500$\n\n$1 \\leqslant w \\leqslant 1,000,000$ （流量）\n\n## 题目链接\n\n[【NOI 2010】海拔 - Luogu 2046](https://www.luogu.com.cn/problem/P2046)\n\n<!-- more -->\n\n## 题解\n\n虽然要求海拔各不相同，但海拔不一定为整数 + 答案四舍五入，所以这个要求无影响。答案显然是把网格分为左上角的一块 $0$ 和右下角的一块 $1$，显然是最小割，但是会 TLE（据说）。\n\n考虑到图是平面图，可以建对偶图跑最短路，相当于把所有的边顺／逆时针转 $90^{\\circ} $。\n\n一开始搞错了边的读入顺序，WA 了两遍。它的边，**无论是横向边还是纵向边，都是先从左到右，后从上到下给出的**。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 505;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dist;\n    bool vis;\n} N[MAXN * MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n};\nvoid addEdge(int u, int v, int w) {\n#ifdef DBG\n    printf(\"edge : %d --> %d, w = %d\\n\", u, v, w);\n#endif\n    N[u].e = new Edge(&N[u], &N[v], w);\n}\nnamespace Dijkstra {\n    struct HeapNode {\n        Node *u;\n        int dist;\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    void solve(Node *s, int n) {\n        for (int i = 0; i < n; i++) N[i].dist = INT_MAX, N[i].vis = false;\n        s->dist = 0;\n        std::priority_queue<HeapNode> q;\n        q.push((HeapNode) {s, 0});\n        while (!q.empty()) {\n            Node *u = q.top().u;\n            q.pop();\n            if (u->vis) continue;\n            u->vis = true;\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->v->dist > u->dist + e->w) {\n                    e->v->dist = u->dist + e->w;\n                    q.push((HeapNode) {e->v, e->v->dist});\n                }\n            }\n        }\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    const int s = 0, t = n * n + 1;\n    for (int i = 0; i <= n; i++) for (int j = 1; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(i ? (i - 1) * n + j : s, i != n ? i * n + j : t, x);\n    }\n    for (int i = 1; i <= n; i++) for (int j = 0; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(j != n ? (i - 1) * n + j + 1 : s, j ? (i - 1) * n + j : t, x);\n    }\n    for (int i = 0; i <= n; i++) for (int j = 1; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(i != n ? i * n + j : t, i ? (i - 1) * n + j : s, x);\n    }\n    for (int i = 1; i <= n; i++) for (int j = 0; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(j ? (i - 1) * n + j : t, j != n ? (i - 1) * n + j + 1 : s, x);\n    }\n    Dijkstra::solve(&N[s], t + 1);\n    printf(\"%d\\n\", N[t].dist);\n    return 0;\n}\n```","tags":["单源最短路","最小割","对偶图"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2012] 矿场搭建","url":"/BZOJ-2730-HNOI-2012-矿场搭建/","content":"\n## 题目大意\n\n煤矿工地可以看成是由隧道连接挖煤点组成的无向图。为安全起见，希望在工地发生事故时所有挖煤点的工人都能有一条出路逃到救援出口处。于是矿主决定在某些挖煤点设立救援出口，使得无论哪一个挖煤点坍塌之后，其他挖煤点的工人都有一条道路通向救援出口。求至少需要设置几个救援出口，以及不同最少救援出口的设置方案总数，多组询问。\n\n$1 \\leqslant m \\leqslant 500$\n\n## 题目链接\n\n[【HNOI 2012】矿场搭建 - Luogu 3225](https://www.luogu.com.cn/problem/P3225)\n\n<!-- more -->\n\n## 题解\n\n输入是保证图连通的。\n\n若坍塌的不是割点，则逃生点随意，所以只考虑坍塌在割点。若一个块能通往两个及以上的割点，则不用设立逃生点；若只能到达一个割点，则再设一个逃生点；若无割点，则随意设置两个（坍塌在逃生点）。\n\n用 Tarjan 求割点，然后遍历图求出每个块的大小已经能到达的割点数。\n\n数据保证了答案不超过 `long long`。但最大答案，是会把 `long long` 超好几圈的。。。\n\n一开始答案写的 `int`，COGS 上发现最后一个点的答案过了 `int`，于是写完题后想了想理论最大答案。最大的答案应该是一个菊花图（只有一个割点），除了中心的一个点，剩下的 $500$ 个点（$500$ 条边的树是 $501$ 个点）均匀分在每个延出去的链上，若分成了 $x$ 条链，则答案大概是 $(\\frac{500}{x})^x$（没有考虑取整），式子在正整数范围内的最大值是 $x = 184$时，值为 $7.656 \\times 10^{79}$。所以，这题差点成了高精度。。。（如果不取模的话）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <set>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 505;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    Node *fa;\n    int dfn, low;\n    bool vis, ins, isCut;\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\nint n;\nvoid clear() {\n    for (int i = 1; i <= n; i++) {\n        for (Edge *&e = N[i].e, *next; e; next = e->next, delete e, e = next);\n        N[i].vis = N[i].ins = N[i].isCut = false;\n        N[i].fa = NULL;\n        N[i].dfn = N[i].low = 0;\n    }\n}\nnamespace Tarjan {\n    int dfsClock;\n    void dfs(Node *u) {\n        u->dfn = u->low = ++dfsClock;\n#ifdef DBG\n        printf(\"tarjan-dfs(%d)\\n\", u->id);\n#endif\n        int childCnt = 0;\n        for (Edge *e = u->e; e; e = e->next) {\n            if (!e->v->dfn) {\n                childCnt++;\n                e->v->fa = u;\n                dfs(e->v);\n                u->low = std::min(u->low, e->v->low);\n                if (u->fa) {\n                    if (e->v->low >= u->dfn) u->isCut = true;\n                } else if (childCnt == 2) u->isCut = true;\n            } else u->low = std::min(u->low, e->v->dfn);\n        }\n    }\n    void findCut() {\n        dfsClock = 0;\n        dfs(&N[1]);\n    }\n}\nvoid solve(int &min, long long &cnt) {\n    min = 0, cnt = 1;\n    for (int i = 1; i <= n; i++) {\n        if (N[i].vis || N[i].isCut) continue;\n        std::queue<Node *> q;\n        q.push(&N[i]);\n        N[i].vis = true;\n        std::set<Node *> s;\n        int size = 0;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            size++;\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->v->isCut) s.insert(e->v);\n                else if (!e->v->vis) q.push(e->v), e->v->vis = true;\n            }\n        }\n        if (s.size() == 1) min++, cnt *= size;\n    }\n    if (!min) min = 2, cnt = n * (n - 1) / 2;\n}\nint main() {\n    for (int i = 1, m; ~scanf(\"%d\", &m) && m; i++) {\n        n = 0;\n        while (m--) {\n            int u, v;\n            scanf(\"%d %d\", &u, &v);\n            addEdge(u, v);\n            n = std::max(n, std::max(u, v));\n        }\n#ifdef DBG\n        for (int i = 1; i <= n; i++) N[i].id = i;\n#endif\n        Tarjan::findCut();\n#ifdef DBG\n        for (int i = 1; i <= n; i++) if (N[i].isCut) printf(\"cut: %d\\n\", i);\n#endif\n        int min;\n        long long cnt;\n        solve(min, cnt);\n        printf(\"Case %d: %d %lld\\n\", i, min, cnt);\n        clear();\n    }\n    return 0;\n}\n```","tags":["图","Tarjan","割点"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2015] 情报传递","url":"/BZOJ-4448-SCOI-2015-情报传递/","content":"\n## 题目大意\n\n有 $n$ 名特务，每个特务有一个上司（显然，有一个特务头子没有上司），每名特务只能与自己的上司与手下联系。每天有一个操作：\n\n* 搜集情报：从这一天开始，每天该特务的危险值加 $1$，在当天，其危险值仍为 $0$。\n* 传递情报：询问两个特务的联系路线上的所有特务有多少个，以及有多少个的危险值大于 $c$。\n\n$1 \\leqslant n, \\; q \\leqslant 200,000$\n\n## 题目链接\n\n[【SCOI 2015】情报传递](https://loj.ac/problem/2011)\n\n<!-- more -->\n\n## 题解\n\n显然，特务构成一个树形结构。\n\n对于每一个询问，求两点间路径上的点数比较简单。\n\n对于第二问，第 $i$ 天的询问只受在第 $i - c$ 天以前的操作影响。对于每天的操作，定义 $c'$，当是修改（搜集情报）时，为天数；是询问时，为 $天数 - c$。以 $c'$ 对操作排序（相同时，由于修改对当天不产生影响，询问在前），对每一个修改，在 LCT 上为节点加 $1$；对于询问，为路径上节点权值和。\n\n（这题树剖显然也可以做）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 200005;\nconst int MAXQ = 200005;\nstruct LinkCurTree {\n    struct Node {\n        Node *c[2], *fa, *pathFa;\n        int w, sum, size;\n        bool rev;\n        Node() : fa(NULL), pathFa(NULL), w(0), sum(0), size(0), rev(false) {\n            c[0] = c[1] = NULL;\n        }\n        void pushDown() {\n            if (rev) {\n                std::swap(c[0], c[1]);\n                if (c[0]) c[0]->rev ^= 1;\n                if (c[1]) c[1]->rev ^= 1;\n                rev = false;\n            }\n        }\n        void maintain() {\n            sum = (c[0] ? c[0]->sum : 0) + (c[1] ? c[1]->sum : 0) + w;\n            size = (c[0] ? c[0]->size : 0) + (c[1] ? c[1]->size : 0) + 1;\n        }\n        int relation() {\n            return fa->c[1] == this;\n        }\n        void rotate() {\n            std::swap(pathFa, fa->pathFa);\n            int x = relation();\n            Node *o = fa;\n            fa = o->fa;\n            if (fa) fa->c[o->relation()] = this;\n            o->c[x] = c[x ^ 1];\n            if (c[x ^ 1]) c[x ^ 1]->fa = o;\n            c[x ^ 1] = o;\n            o->fa = this;\n            o->maintain(), maintain();\n        }\n        void splay() {\n            while (fa) {\n                if (fa->fa) fa->fa->pushDown();\n                fa->pushDown(), pushDown();\n                if (!fa->fa) rotate();\n                else if (fa->relation() == relation()) fa->rotate(), rotate();\n                else rotate(), rotate();\n            }\n            pushDown();\n        }\n        void expose() {\n            splay();\n            if (c[1]) {\n                std::swap(c[1]->fa, c[1]->pathFa);\n                c[1] = NULL;\n                maintain();\n            }\n        }\n        bool splice() {\n            splay();\n            if (!pathFa) return false;\n            pathFa->expose();\n            pathFa->c[1] = this;\n            pathFa->maintain();\n            std::swap(fa, pathFa);\n            return true;\n        }\n        void access() {\n            expose();\n            while (splice());\n        }\n        void evert() {\n            access();\n            splay();\n            rev ^= 1;\n        }\n    } N[MAXN];\n    void link(int u, int v) {\n        N[v].evert();\n        N[v].pathFa = &N[u];\n    }\n    void update(int u, int w) {\n        N[u].splay();\n        N[u].w = w;\n        N[u].maintain();\n    }\n    void query(int u, int v, int &size, int &sum) {\n        N[u].evert();\n        N[v].access();\n        N[v].splay();\n        size = N[v].size;\n        sum = N[v].sum;\n    }\n} lct;\nstruct Query {\n    int op, u, v, c, *dist, *cnt;\n    bool operator<(const Query &another) const {\n        return c < another.c || (c == another.c && op < another.op);\n    }\n#ifdef DBG\n    void print() const {\n        printf(\"Query[op = %d, u = %d, v = %d, c = %d]\\n\", op, u, v, c);\n    }\n#endif\n} Q[MAXQ];\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        int fa;\n        scanf(\"%d\", &fa);\n        if (fa) lct.link(fa, i);\n    }\n    int q;\n    scanf(\"%d\", &q);\n    static int ans[MAXQ][3];\n    for (int i = 0; i < q; i++) {\n        scanf(\"%d\", &Q[i].op);\n        if (Q[i].op == 2) scanf(\"%d\", &Q[i].u), Q[i].c = i;\n        else {\n            int c;\n            scanf(\"%d %d %d\", &Q[i].u, &Q[i].v, &c);\n            Q[i].c = i - c;\n        }\n        ans[i][0] = Q[i].op;\n        Q[i].dist = &ans[i][1];\n        Q[i].cnt = &ans[i][2];\n    }\n    std::sort(Q, Q + q);\n    for (int i = 0; i < q; i++) {\n#ifdef DBG\n        printf(\"i = %d, \", i);\n        Q[i].print();\n#endif\n        if (Q[i].op == 2) lct.update(Q[i].u, 1);\n        else {\n            int dist, cnt;\n            lct.query(Q[i].u, Q[i].v, dist, cnt);\n            *Q[i].dist = dist;\n            *Q[i].cnt = cnt;\n#ifdef DBG\n            printf(\"dist = %d, cnt = %d\\n\", dist, cnt);\n#endif\n        }\n    }\n    for (int i = 0; i < q; i++) if (ans[i][0] == 1) printf(\"%d %d\\n\", ans[i][1], ans[i][2]);\n    return 0;\n}\n```","tags":["树链剖分","LCT","离线"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] 墨墨的等式","url":"/BZOJ-2118-墨墨的等式/","content":"\n## 题目大意\n\n给定 $n$、$a_i$、$L$、$R$ 求能使等式 $a_1 x_1 + a_2 x_2 + a_3 x_3 + \\cdots + a_n x_n = B, \\; B \\in [L, \\; R]$ 有非负整数解的 $B$ 的个数。\n\n$1 \\leqslant n \\leqslant 12$\n\n$0 \\leqslant a_i \\leqslant 500,000$\n\n$1 \\leqslant L \\leqslant R \\leqslant 1 \\times 10^{12}$\n\n## 题目链接\n\n[【国家集训队】墨墨的等式 - Luogu 2371](https://www.luogu.com.cn/problem/P2371)\n\n<!-- more -->\n\n## 题解\n\n如果 $B = i$ 是一个合法答案，则 $B' = i + k a_j \\leqslant R$ 也是合法答案。考虑求出最小的 $B_i = i \\; (mod \\; a_1)$，其中 $a_1 = min\\{a_n\\}$，就可以计算答案了。\n\n对于 $B_i$ 的求法，可以转化为最短路。对于一个 $i \\in [0, a_1)$ 和一个 $a_j \\; (j \\neq 1)$，建立一条从 $i$ 到 $(i + a_j) \\; mod \\; a_1$、权值为 $a_j$ 的边，以 $0$ 为起点，$i$ 的最短距离就是 $B_i$。（十分巧妙的题）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 15;\nconst int MAXA = 500005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    long long dist;\n    bool vis;\n} N[MAXA];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n};\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n}\nnamespace Dijkstra {\n    struct HeapNode {\n        Node *u;\n        long long dist;\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    void solve(int n) {\n        for (int i = 0; i < n; i++) N[i].dist = LLONG_MAX, N[i].vis = false;\n        N[0].dist = 0;\n        std::priority_queue<HeapNode> q;\n        q.push((HeapNode) {&N[0], 0});\n        while (!q.empty()) {\n            Node *u = q.top().u;\n            q.pop();\n            if (u->vis) continue;\n            u->vis = true;\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->v->dist > u->dist + e->w) {\n                    e->v->dist = u->dist + e->w;\n                    q.push((HeapNode) {e->v, e->v->dist});\n                }\n            }\n        }\n    }\n}\nint main() {\n    int n;\n    long long L, R;\n    scanf(\"%d %lld %lld\", &n, &L, &R);\n    static int a[MAXN];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    std::sort(a + 1, a + n + 1);\n    for (int i = 0; i < a[1]; i++) for (int j = 2; j <= n; j++)\n        addEdge(i, (i + a[j]) % a[1], a[j]);\n    Dijkstra::solve(a[1]);\n    long long ans = 0;\n    for (int i = 0; i < a[1]; i++) {\n        if (N[i].dist > R) continue;\n        long long l = std::max((L - N[i].dist) / a[1], 0ll);\n        if (l * a[1] + N[i].dist < L) l++;\n        long long r = (R - N[i].dist) / a[1];\n        if (r * a[1] + N[i].dist > R) r--;\n        ans += r - l + 1;\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["单源最短路"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2009] 最长距离","url":"/BZOJ-1295-SCOI-2009-最长距离/","content":"\n## 题目大意\n\n有一个 $n \\times m$ 的网格，每个位置是空地或障碍物。从每个空地可以到达其四连通块的空地上，若两个空地可以相互到达，则定义这两点间的距离为两个格子中心的欧几里得距离，否则没有距离。若最多可以移走 $t$ 个障碍物，求最大的两点间距离。\n\n$1 \\leqslant n, \\; m, \\; t \\leqslant 30$\n\n## 题目链接\n\n[【SCOI 2009】最长距离 - Luogu 4162](https://www.luogu.com.cn/problem/P4162)\n\n<!-- more -->\n\n## 题解\n\n以每个点为起点跑最短路，经过障碍物时距离加 $1$，用距离小于等于 $t$ 的终点更新答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cmath>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 35;\nstruct Node {\n    int dist, x, y;\n    bool vis;\n} N[MAXN][MAXN];\nint n, m, t;\nint G[MAXN][MAXN];\nnamespace Dijkstra {\n    struct HeapNode {\n        Node *u;\n        int dist;\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    bool valid(int x, int y) {\n        return x <= n && x > 0 && y <= m && y > 0;\n    }\n    const int d[4][2] = {\n        {0, 1},\n        {0, -1},\n        {1, 0},\n        {-1, 0}\n    };\n    void dijkstra(Node *s) {\n        std::priority_queue<HeapNode> q;\n        s->dist = G[s->x][s->y];\n        q.push((HeapNode) {s, 0});\n        while (!q.empty()) {\n            Node *u = q.top().u;\n            q.pop();\n            if (u->vis) continue;\n            u->vis = true;\n            for (int i = 0; i < 4; i++) {\n                int x = u->x + d[i][0], y = u->y + d[i][1];\n                if (!valid(x, y)) continue;\n                Node *v = &N[x][y];\n                if (v->dist > u->dist + G[x][y] && u->dist + G[x][y] <= t) {\n                    v->dist = u->dist + G[x][y];\n                    q.push((HeapNode) {v, v->dist});\n                }\n            }\n        }\n    }\n    void solve(int x, int y) {\n        for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n            N[i][j].vis = false;\n            N[i][j].dist = INT_MAX;\n        }\n        dijkstra(&N[x][y]);\n    }\n}\nint dist(int x1, int y1, int x2, int y2) {\n    return (x1 - x2) * (x1 - x2) + (y1 - y2) * (y1 - y2);\n}\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &t);\n    for (int i = 1; i <= n; i++) {\n        static char s[MAXN];\n        scanf(\"%s\", s + 1);\n        for (int j = 1; j <= m; j++) {\n            G[i][j] = s[j] - '0';\n            N[i][j].x = i;\n            N[i][j].y = j;\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        Dijkstra::solve(i, j);\n        for (int x = 1; x <= n; x++) for (int y = 1; y <= m; y++)\n            if (N[x][y].dist <= t) ans = std::max(ans, dist(i, j, x, y));\n    }\n    printf(\"%.6lf\\n\", sqrt(ans));\n    return 0;\n}\n```","tags":["单源最短路"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2015] 子集选取","url":"/BZOJ-4475-JSOI-2015-子集选取/","content":"\n## 题目大意\n\n给定包含 $n$ 个元素的集合 $S$ 和一个正整数 $k$ ，选出 $S$ 的若干子集 $A_{i, j} \\; (1 \\leqslant i \\leqslant j \\leqslant k)$ 排为如下的三角形：\n$$\n\\begin{align}\n&A_{1, 1} \\\\\n&A_{2, 1} &A_{2, 2} \\\\\n&A_{3, 1} &A_{3, 2} &A_{3, 3} \\\\\n&\\dots\n\\end{align}\n$$\n满足 $A_{i, j} \\subseteq A_{i, j - 1}$和$A_{i, j} \\subseteq A_{i - 1, j}$。求子集选取的方案数，答案对 $1,000,000,007$ 取模。\n\n$1 \\leqslant n, \\; k \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【JSOI2015】子集选取 - Luogu 6075](https://www.luogu.com.cn/problem/P6075)\n\n<!-- more -->\n\n## 题解\n\n毕姥爷在 WC2017 上讲过的题。\n\n对于每个元素，它只能出现在三角形的左上角。从三角形的左下角开始，要么向上，要么向右，走 $k$ 步形成一条分割线，左上是含该元素的，右下不含该元素。分割线的情况是 $2^k$，每个元素相互独立，答案乘起来，即 $2^{k n}$，用快速幂计算。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MOD = 1000000007;\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    printf(\"%lld\\n\", pow(2, (long long) n * k));\n    return 0;\n}\n```","tags":["快速幂"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2016] K远点对","url":"/BZOJ-4520-CQOI-2016-K远点对/","content":"\n## 题目大意\n\n给定平面内 $n$ 个点的坐标，求欧几里得距离下的第 $k$ 远点对，输出其欧几里得距离的平方。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant k \\leqslant 100$\n\n$0 \\leqslant x,\\; y < 2^{31}$\n\n## 题目链接\n\n[【CQOI 2016】K 远点对](https://loj.ac/problem/2043)\n\n<!-- more -->\n\n## 题解\n\nk-d 树裸题。\n\n枚举每一个点为询问点，求 $2 k$ 远点（每一对点都被算了两次）。\n\nTLE 了四次。。。把某一个 `long long` 写成了 `int`，其实是 WA 的说。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 100005;\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n} P[MAXN];\nlong long dist(const Point &a, const Point &b) {\n    return (long long) (a.x - b.x) * (a.x - b.x) + (long long) (a.y - b.y) * (a.y - b.y);\n}\nstruct KDTree {\n    static bool cmp1(const Point &a, const Point &b) {\n        return a.y < b.y || (a.y == b.y && a.x < b.x);\n    }\n    static bool cmp2(const Point &a, const Point &b) {\n        return a.x < b.x || (a.x == b.x && a.y < b.y);\n    }\n    std::priority_queue<long long, std::vector<long long>, std::greater<long long> > q;\n    struct Node {\n        Node *c[2];\n        Point p, r1, r2;\n        Node() {}\n        Node(Point p) : p(p), r1(p), r2(p) {\n            c[0] = c[1] = NULL;\n        }\n        void maintain() {\n            if (c[0]) {\n                r1.x = std::min(r1.x, c[0]->r1.x);\n                r1.y = std::min(r1.y, c[0]->r1.y);\n                r2.x = std::max(r2.x, c[0]->r2.x);\n                r2.y = std::max(r2.y, c[0]->r2.y);\n            }\n            if (c[1]) {\n                r1.x = std::min(r1.x, c[1]->r1.x);\n                r1.y = std::min(r1.y, c[1]->r1.y);\n                r2.x = std::max(r2.x, c[1]->r2.x);\n                r2.y = std::max(r2.y, c[1]->r2.y);\n            }\n        }\n        long long dist(const Point &p) {\n            return std::max(std::max(::dist(p, r1), ::dist(p, r2)), \n                            std::max(::dist(p, Point(r1.x, r2.y)), ::dist(p, Point(r2.x, r1.y))));\n        }\n        void query(const Point &p, std::priority_queue<long long, std::vector<long long>, std::greater<long long> > &q) {\n            long long d = ::dist(p, this->p);\n            if (d > q.top()) q.pop(), q.push(d);\n            if (!(c[0] || c[1])) return;\n            long long dis[2] = {c[0] ? c[0]->dist(p) : INT_MIN, \n                                c[1] ? c[1]->dist(p) : INT_MIN};\n            int k = dis[0] < dis[1];\n            c[k]->query(p, q);\n            if (c[k ^ 1] && dis[k ^ 1] > q.top()) c[k ^ 1]->query(p, q);\n        }\n    } *root, _pool[MAXN], *_cur;\n    KDTree() : root(NULL) {\n        _cur = _pool;\n    }\n    Node *build(Point *l, Point *r, int d = 0) {\n        if (l > r) return NULL;\n        if (l == r) return new (_cur++) Node(*l);\n        Point *mid = l + (r - l) / 2;\n        std::nth_element(l, mid, r + 1, d ? cmp1 : cmp2);\n        Node *u = new (_cur++) Node(*mid);\n        u->c[0] = build(l, mid - 1, d ^ 1);\n        u->c[1] = build(mid + 1, r, d ^ 1);\n        u->maintain();\n        return u;\n    }\n    long long query(Point P[], int n, int k) {\n        while (!q.empty()) q.pop();\n        for (int i = 0; i < k << 1; i++) q.push(-1);\n        for (int i = 1; i <= n; i++) root->query(P[i], q);\n        return q.top();\n    }\n} kdT;\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    for (int i = 1; i <= n; i++) scanf(\"%d %d\", &P[i].x, &P[i].y);\n    kdT.root = kdT.build(P + 1, P + n);\n    printf(\"%lld\\n\", kdT.query(P, n, k));\n    return 0;\n}\n```","tags":["模版","k-d树"],"categories":["题解（OI/XCPC）"]},{"title":"k-d树学习笔记","url":"/k-d树学习笔记/","content":"\n我学习的博客：[k-d树学习笔记 | Sengxian's Blog](https://blog.sengxian.com/algorithms/k-dimensional-tree)。\n\n## k-d树简介\n\nk-d 树，就是 $k$ 维树，可以看作是数据是多维向量的二叉搜索树。\n\n一维的情况就是一般的二叉搜索树。\n\n一般常用二维情况，求解平面$k$近点对，之后的笔记也以二维为主。\n\n<!-- more -->\n\n## 数据结构的介绍与实现\n\n### 节点\n\n像二叉搜索树一样，每个节点有两个儿子，同时保存自己所存储的数据，一般还保存它和它的子树的数据范围。\n\n```c++\nstruct Node {\n    Node *c[2];\n    Point p, r1, r2; // r1为范围左下角，r2为右上角\n    Node(Point p) : p(p), r1(p), r2(p) {\n        c[0] = c[1] = NULL;\n    }\n};\n```\n\n### 建树\n\n一维时，我们如何比较数据是确定的，然而在多维情况下，比较哪一维是不一定的。一般我们轮流比较每一维，比如二位情况就是先比较 $x$ ，再比较 $y$ ，再比较 $x$ …… 对于每个节点，如果它的儿子是以某一维比较的，那么该节点满足，在这一维上，其左侧的点都比其小，右侧的都比它大。\n\n现在，我们要以一堆点建立 k-d 树还需解决另一个问题，即如何取根节点让两颗子树大小尽量相等。参照二叉搜索树，取中位数为根，可以用 `algorithm` 头文件中的 `std::nth_element(起点指针, 第k位指针, 终点指针, 比较方法)` 方法取得中位数。\n\n关于该方法，它会把范围内第 $k$ 小的数放在「第 $k$ 位指针」上，比它小的乱序置于前面，大的乱序置于后面，复杂度为 $O(n)$。\n\n那么建树方法就可以写出来了。\n\n```c++\nstatic bool cmp1(const Point &a, const Point &b) {\n    return a.y < b.y ? a.y < b.y : (a.y == b.y && a.x < b.x);\n}\nstatic bool cmp2(const Point &a, const Point &b) {\n    return a.x < b.x ? a.x < b.x : (a.x == b.x && a.y < b.y);\n}\n\nNode *build(Point *l, Point *r, int d = 0) {\n    if (l > r) return NULL;\n    if (l == r) return new Node(*l);\n    Point *mid = l + (r - l) / 2;\n    std::nth_element(l, mid, r + 1, d ? cmp1 : cmp2);\n    Node *u = new Node(*mid);\n    u->c[0] = build(l, mid - 1, d ^ 1);\n    u->c[1] = build(mid + 1, r, d ^ 1);\n    u->maintain();\n    return u;\n}\n```\n\n其中 `maintain()` 方法更新点的范围。\n\n```c++\nvoid maintain() {\n    if (c[0]) {\n        r1.x = std::min(r1.x, c[0]->r1.x);\n        r1.y = std::min(r1.y, c[0]->r1.y);\n        r2.x = std::max(r2.x, c[0]->r2.x);\n        r2.y = std::max(r2.y, c[0]->r2.y);\n    }\n    if (c[1]) {\n        r1.x = std::min(r1.x, c[1]->r1.x);\n        r1.y = std::min(r1.y, c[1]->r1.y);\n        r2.x = std::max(r2.x, c[1]->r2.x);\n        r2.y = std::max(r2.y, c[1]->r2.y);\n    }\n}\n```\n\n### 插入\n\n类比二叉搜索树，从根节点一路比较下去就行了。\n\n```c++\nvoid insert(const Point &p) {\n    Node **u = &root;\n    int d = 0;\n    while (*u) {\n        int k = (d ? cmp1(p, (*u)->p) : cmp2(p, (*u)->p)) ^ 1;\n        d ^= 1;\n        (*u)->r1.x = std::min(p.x, (*u)->r1.x);\n        (*u)->r1.y = std::min(p.y, (*u)->r1.y);\n        (*u)->r2.x = std::max(p.x, (*u)->r2.x);\n        (*u)->r2.y = std::max(p.y, (*u)->r2.y);\n        u = &(*u)->c[k];\n    }\n    *u = new Node(p);\n}\n```\n\n### 查询最近点\n\n先设答案为正无穷，从根节点开始，计算询问点到两个儿子节点范围矩形的距离（在内部为 $0$），先去小的一方查询，更新答案后，以询问点为中心画圆（欧几里得距离）／矩形（曼哈顿距离），如果与另一个子节点的范围矩形相交，表明另一个子节点的子树中有可能有答案，在该子点中继续查询。\n\n过程中，把答案放在外面，似乎有利于剪枝（放在内部时，BZOJ 2648 就是 TLE。。。）。\n\n```c++\nint dist(const Point &p) {\n    int res = 0;\n    if (p.x < r1.x || r2.x < p.x) res += p.x < r1.x ? r1.x - p.x : p.x - r2.x;\n    if (p.y < r1.y || r2.y < p.y) res += p.y < r1.y ? r1.y - p.y : p.y - r2.y;\n    return res;\n}\n\nvoid query(const Point &p, int &res) {\n    res = std::min(res, ::dist(this->p, p));\n    if (!(c[0] || c[1])) return;\n    int k = c[0] && c[1] ? c[0]->dist(p) > c[1]->dist(p) : (c[0] ? 0 : 1);\n    if (c[k]->dist(p) < res) c[k]->query(p, res);\n    if (c[k ^ 1] && c[k ^ 1]->dist(p) < res) c[k ^ 1]->query(p, res);\n}\n```\n\n外围的 `dist(Point a, Point b)` 方法根据是哪种距离来写。\n\n### 查询$k$远点\n\n用一个优先队列／小根堆保存答案，先放入 $k$ 个 $-1$（只要肯定比答案小就行），之后进行查询。\n\n在更新答案时，队顶元素就是目前的第$k$远。\n\n从根节点开始，计算询问点到两个儿子节点范围内的点的最远距离（就是到范围矩形四个顶点的最远距离），先去大的一方查询，更新答案后，如果到另一个子节点的最大距离比目前答案大，则在另一个子节点中查询。\n\n```c++\nlong long dist(const Point &p) {\n    return std::max(std::max(::dist(p, r1), ::dist(p, r2)), \n                    std::max(::dist(p, Point(r1.x, r2.y)), ::dist(p, Point(r2.x, r1.y))));\n}\n\nvoid query(const Point &p, std::priority_queue<long long, std::vector<long long>, std::greater<long long> > &q) {\n    long long d = ::dist(p, this->p);\n    if (d > q.top()) q.pop(), q.push(d);\n    if (!(c[0] || c[1])) return;\n    long long dis[2] = {c[0] ? c[0]->dist(p) : INT_MIN, c[1] ? c[1]->dist(p) : INT_MIN};\n    int k = dis[0] < dis[1];\n    if (dis[k] > q.top()) c[k]->query(p, q);\n    if (c[k ^ 1] && dis[k ^ 1] > q.top()) c[k ^ 1]->query(p, q);\n}\n```\n\n## 模版题\n\n曼哈顿距离最近点：[BZOJ 2648](http://www.lydsy.com/JudgeOnline/problem.php?id=2648) （[题解](http://pepcy.cf/BZOJ-2648-SJY摆棋子/)）\n\n欧几里得距离$k$远点对：[BZOJ 4520](http://www.lydsy.com/JudgeOnline/problem.php?id=4520) （[题解](http://pepcy.cf/BZOJ-4520-CQOI-2016-K远点对/)）","tags":["学习笔记","模版","k-d树"],"categories":["学习笔记（OI/XCPC）"]},{"title":"SJY摆棋子","url":"/BZOJ-2648-SJY摆棋子/","content":"\n## 题目大意\n\n棋盘上有 $n$ 个黑色棋子，有 $m$ 次操作，放下一个黑色棋子或白色棋子，在放下白色棋子时，查询曼哈顿距离与其最近的黑色棋子，输出对应的曼哈顿距离。一个点上可能有多个棋子。\n\n$1 \\leqslant n, \\; m \\leqslant 500,000$\n\n## 题目链接\n\n[【Violet】天使玩偶/SJY摆棋子 - Luogu 4169](https://www.luogu.com.cn/problem/P4169)\n\n<!-- more -->\n\n## 题解\n\nk-d 树裸题。\n\nTLE 了四次。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <cctype>\n#include <algorithm>\n#include <new>\n// #define DBG\nconst int MAXN = 500005;\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n#ifdef DBG\n    void print() const {\n        printf(\"Point: [x = %d, y = %d]\\n\", x, y);\n    }\n#endif\n} P[MAXN];\nint dist(const Point &a, const Point &b) {\n    return abs(a.x - b.x) + abs(a.y - b.y);\n}\nstruct KDTree {\n    static bool cmp1(const Point &a, const Point &b) {\n        return a.y < b.y ? a.y < b.y : (a.y == b.y && a.x < b.x);\n    }\n    static bool cmp2(const Point &a, const Point &b) {\n        return a.x < b.x ? a.x < b.x : (a.x == b.x && a.y < b.y);\n    }\n    int res;\n    struct Node {\n        Node *c[2];\n        Point p, r1, r2;\n        Node() {}\n        Node (Point p) : p(p), r1(p), r2(p) {\n            c[0] = c[1] = NULL;\n        }\n        void maintain() {\n            if (c[0]) {\n                r1.x = std::min(r1.x, c[0]->r1.x);\n                r1.y = std::min(r1.y, c[0]->r1.y);\n                r2.x = std::max(r2.x, c[0]->r2.x);\n                r2.y = std::max(r2.y, c[0]->r2.y);\n            }\n            if (c[1]) {\n                r1.x = std::min(r1.x, c[1]->r1.x);\n                r1.y = std::min(r1.y, c[1]->r1.y);\n                r2.x = std::max(r2.x, c[1]->r2.x);\n                r2.y = std::max(r2.y, c[1]->r2.y);\n            }\n        }\n        int dist(const Point &p) {\n            int res = 0;\n            if (p.x < r1.x || r2.x < p.x) res += p.x < r1.x ? r1.x - p.x : p.x - r2.x;\n            if (p.y < r1.y || r2.y < p.y) res += p.y < r1.y ? r1.y - p.y : p.y - r2.y;\n            return res;\n        }\n        void query(const Point &p, int &res) {\n#ifdef DBG\n            printf(\"query():\\n\");\n            this->p.print();\n            printf(\"c[0]: %d, c[1]: %d\\n\", c[0] ? 1 : 0, c[1] ? 1 : 0);\n#endif\n            res = std::min(res, ::dist(this->p, p));\n            if (!(c[0] || c[1])) return;\n            int k = c[0] && c[1] ? c[0]->dist(p) > c[1]->dist(p) : (c[0] ? 0 : 1);\n            c[k]->query(p, res);\n            if (c[k ^ 1] && c[k ^ 1]->dist(p) < res) c[k ^ 1]->query(p, res);\n        }\n    } *root, _pool[MAXN << 1], *_cur;\n    KDTree() : root(NULL), res(0) {\n        _cur = _pool;\n    }\n    Node *build(int l, int r, Point P[], int d = 0) {\n        if (l > r) return NULL;\n        if (l == r) return new (_cur++) Node(P[l]);\n        int mid = l + (r - l) / 2;\n        d ? std::nth_element(P + l, P + mid, P + r + 1, cmp1) : std::nth_element(P + l, P + mid, P + r + 1, cmp2);\n        Node *u = new (_cur++) Node(P[mid]);\n        u->c[0] = build(l, mid - 1, P, d ^ 1);\n        u->c[1] = build(mid + 1, r, P, d ^ 1);\n        u->maintain();\n        return u;\n    }\n    void insert(const Point &p) {\n        Node **u = &root;\n        int d = 0;\n        while (*u) {\n            int k = (d ? cmp1(p, (*u)->p) : cmp2(p, (*u)->p)) ^ 1;\n            d ^= 1;\n            (*u)->r1.x = std::min(p.x, (*u)->r1.x);\n            (*u)->r1.y = std::min(p.y, (*u)->r1.y);\n            (*u)->r2.x = std::max(p.x, (*u)->r2.x);\n            (*u)->r2.y = std::max(p.y, (*u)->r2.y);\n            u = &(*u)->c[k];\n        }\n        *u = new (_cur++) Node(p);\n    }\n    int query(const Point &p) {\n        res = INT_MAX;\n        root->query(p, res);\n        return res;\n    }\n} kdT;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d %d\", &P[i].x, &P[i].y);\n    kdT.root = kdT.build(1, n, P);\n    while (m--) {\n        int op;\n        Point p;\n        scanf(\"%d %d %d\", &op, &p.x, &p.y);\n#ifdef DBG\n        printf(\"op = %d, p: (%d, %d)\\n\", op, p.x, p.y);\n#endif\n        if (op == 1) kdT.insert(p);\n        else printf(\"%d\\n\", kdT.query(p));\n    }\n    return 0;\n}\n```","tags":["模版","k-d树"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2013] 森林","url":"/BZOJ-3123-SDOI-2013-森林/","content":"\n## 题目大意\n\n给定一个森林，每个点有一个权值 $w_i$，给定 $t$ 组操作，操作有两种：\n\n* `Q u v k`：查询 $u$ 与 $v$ 的路径上，第 $k$ 小的点权值。\n* `L u v`：连接 $u$ 与 $v$，保证始终为森林。\n\n强制在线（异或 $lastAns$）。\n\n$1 \\leqslant n \\leqslant 80,000$\n\n$1 \\leqslant w_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【SDOI 2013】森林 - Luogu 3302](https://www.luogu.com.cn/problem/P3302)\n\n<!-- more -->\n\n## 题解\n\n询问就是 [Count on a Tree](http://pepcy.cf/BZOJ-2588-SPOJ-10628-Count-on-a-tree/) 那题，用主席树，两点 lca 用倍增求。\n\n连接两点时，用启发式合并，把小的一边加到大的一边，实现用 bfs 跑一遍小的一边即可。块的大小用并查集维护。\n\n## 代码\n\n居然会有入读测试点这种东西。。。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 80005;\nconst int MAXN_LOG = 20;\nstruct PSegT {\n    int l, r;\n    PSegT *lc, *rc;\n    int cnt;\n    PSegT(int l, int r, PSegT *lc = NULL, PSegT *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n    PSegT(int l, int r, int cnt) : l(l), r(r), cnt(cnt), lc(NULL), rc(NULL) {}\n    void pushDown() {\n        if (lc && rc) return;\n        int mid = l + (r - l) / 2;\n        if (!lc) lc = new PSegT(l, mid);\n        if (!rc) rc = new PSegT(mid + 1, r);\n    }\n    PSegT *insert(int x) {\n        if (x < l || x > r) return this;\n        if (x == l && x == r) return new PSegT(l, r, cnt + 1);\n        int mid = l + (r - l) / 2;\n        pushDown();\n        if (x <= mid) return new PSegT(l, r, lc->insert(x), rc);\n        else return new PSegT(l, r, lc, rc->insert(x));\n    }\n    int rank() {\n        return lc ? lc->cnt : 0;\n    }\n} *root;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    PSegT *seg;\n    Node *f[MAXN_LOG];\n    int w, belong, dep;\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n#ifdef DBG\n    printf(\"edge: %d --- %d\\n\", u, v);\n#endif\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\nint n, ccCnt, logn = 0;\nvoid bfs(Node *s, bool init = true) {\n    ++ccCnt;\n    std::queue<Node *> q;\n    s->belong = ccCnt;\n    if (init) {\n        s->f[0] = s;\n        s->seg = root->insert(s->w);\n        s->dep = 0;\n    }\n    q.push(s);\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n        for (int i = 1; i <= logn; i++) u->f[i] = u->f[i - 1]->f[i - 1];\n        for (Edge *e = u->e; e; e = e->next) if (e->v->belong != ccCnt && (init || e->v != s->f[0])) {\n            e->v->belong = ccCnt;\n            e->v->f[0] = u;\n            e->v->dep = u->dep + 1;\n            e->v->seg = u->seg->insert(e->v->w);\n            q.push(e->v);\n        }\n    }\n}\nvoid bfs() {\n    for (int i = 1; i <= n; i++) if (N[i].belong == 0) bfs(&N[i]);\n}\nstruct UnionFindSet {\n    int fa[MAXN], size[MAXN];\n    void init(int n) {\n        for (int i = 1; i <= n; i++) fa[i] = i, size[i] = 1;\n    }\n    int find(int x) {\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    }\n    void merge(int x, int y) {\n        int p = find(x), q = find(y);\n        if (size[p] > size[q]) std::swap(p, q);\n        fa[p] = q;\n        size[q] += size[p];\n    }\n    int getSize(int x) {\n        return size[find(x)];\n    }\n} ufs;\nvoid link(int u, int v) {\n    int su = ufs.getSize(u), sv = ufs.getSize(v);\n    if (su > sv) std::swap(u, v);\n    addEdge(u, v);\n    N[u].f[0] = &N[v];\n    N[u].seg = N[v].seg->insert(N[u].w);\n    N[u].dep = N[v].dep + 1;\n    bfs(&N[u], false);\n    ufs.merge(u, v);\n}\nNode *lca(Node *u, Node *v) {\n    if (u->dep < v->dep) std::swap(u, v);\n#ifdef DBG\n    printf(\"lca(%d, %d), u.dep = %d, v.dep = %d\\n\", u->id, v->id, u->dep, v->dep);\n#endif\n    if (u->dep != v->dep)\n        for (int i = logn; ~i; i--) if (u->f[i]->dep >= v->dep) u = u->f[i];\n    if (u != v) {\n        for (int i = logn; ~i; i--) if (u->f[i] != v->f[i]) u = u->f[i], v = v->f[i];\n        return u->f[0];\n    }\n    return u;\n}\nint query(Node *u, Node *v, int k) {\n    Node *p = lca(u, v);\n    int l = 1, r = n;\n    PSegT *su = u->seg, *sv = v->seg, *sp = p->seg, *sf = p != p->f[0] ? p->f[0]->seg : root;\n#ifdef DBG\n    printf(\"Q %d %d %d, lca = %d\\n\", u->id, v->id, k, p->id); \n#endif\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        int t = 0;\n        if (su) t += su->rank();\n        if (sv) t += sv->rank();\n        if (sp) t -= sp->rank();\n        if (sf) t -= sf->rank();\n        if (k <= t) {\n            if (su) su = su->lc;\n            if (sv) sv = sv->lc;\n            if (sp) sp = sp->lc;\n            if (sf) sf = sf->lc;\n            r = mid;\n        } else {\n            if (su) su = su->rc;\n            if (sv) sv = sv->rc;\n            if (sp) sp = sp->rc;\n            if (sf) sf = sf->rc;\n            k -= t;\n            l = mid + 1;\n        }\n    }\n    return l;\n}\nint map[MAXN];\nvoid discretization() {\n    std::sort(map + 1, map + n + 1);\n    int *end = std::unique(map + 1, map + n + 1);\n    for (int i = 1; i <= n; i++) N[i].w = std::lower_bound(map + 1, end, N[i].w) - map;\n}\nint main() {\n    scanf(\"%*d\");\n    int m, q;\n    scanf(\"%d %d %d\", &n, &m, &q);\n    ufs.init(n);\n#ifdef DBG\n    for (int i = 1; i <= n; i++) N[i].id = i;\n#endif\n    for (; 1 << (logn + 1) <= n; logn++);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].w), map[i] = N[i].w;\n    discretization();\n    root = new PSegT(1, n);\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n        ufs.merge(u, v);\n    }\n    bfs();\n    int lastAns = 0;\n    while (q--) {\n        char op[2];\n        int u, v;\n        scanf(\"%s %d %d\", op, &u, &v);\n        u ^= lastAns;\n        v ^= lastAns;\n#ifdef DBG\n        printf(\"%s %d %d\\n\", op, u, v);\n#endif\n        if (op[0] == 'Q') {\n            int k;\n            scanf(\"%d\", &k);\n            k ^= lastAns;\n            printf(\"%d\\n\", lastAns = map[query(&N[u], &N[v], k)]);\n        } else link(u, v);\n    }\n    return 0;\n}\n```","tags":["并查集","启发式合并","主席树","LCA"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2014] 危桥","url":"/BZOJ-3504-CQOI-2014-危桥/","content":"\n## 题目大意\n\n有 $n$ 座岛屿（编号从 $0$ 开始），一些岛屿之间有桥相连，其中一些桥是危桥，危桥只能经过两遍，而一般的桥可无数次经过。有两个人，分别从 $a_s$、$b_s$ 出发去 $a_t$、$b_t$ 往返 $a_n$、$b_n$ 次，求是否可行。多组询问。\n\n$4 \\leqslant n \\leqslant 50$\n\n$1 \\leqslant a_n, \\; b_n \\leqslant 50$\n\n## 题目链接\n\n[【CQOI 2014】危桥 - LibreOJ 2239](https://loj.ac/problem/2239)\n\n<!-- more -->\n\n## 题解\n\n可通过次数为流量，从源点向两个起点连接容量为要求次数两倍的边（往返），从两个终点向汇点做类似的事情，如果满流，则可能可行。由于可能会有这么的情况：从源点到某一个起点未流过其对应的终点，而是流到了另一个终点，这样有可能误判（若一开始就没有满流，则一定不可行），那我们交换某一组起点与终点，再跑一遍。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 55;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap, int k = 1) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], k ? cap : 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nint n;\nchar mat[MAXN][MAXN];\nvoid build() {\n    for (int i = 0; i <= n + 1; i++) for (Edge *&e = N[i].e, *next; e; next = e->next, delete e, e = next);\n    for (int i = 1; i <= n; i++) for (int j = i; j <= n; j++) {\n        if (mat[i][j] == 'N') addEdge(i, j, INT_MAX);\n        if (mat[i][j] == 'O') addEdge(i, j, 2);\n    }\n}\nint main() {\n    int as, at, an, bs, bt, bn;\n    while (scanf(\"%d %d %d %d %d %d %d\", &n, &as, &at, &an, &bs, &bt, &bn) != EOF) {\n        as++, at++, bs++, bt++;\n        for (int i = 1; i <= n; i++) scanf(\"%s\", mat[i] + 1);\n        const int s = 0, t = n + 1;\n        build();\n        addEdge(s, as, an << 1, 0);\n        addEdge(s, bs, bn << 1, 0);\n        addEdge(at, t, an << 1, 0);\n        addEdge(bt, t, bn << 1, 0);\n        int maxFlow = Dinic::solve(s, t, t + 1);\n        if (maxFlow < (an << 1) + (bn << 1)) {\n            puts(\"No\");\n            continue;\n        }\n        build();\n        addEdge(s, as, an << 1, 0);\n        addEdge(s, bt, bn << 1, 0);\n        addEdge(at, t, an << 1, 0);\n        addEdge(bs, t, bn << 1, 0);\n        maxFlow = Dinic::solve(s, t, t + 1);\n        if (maxFlow == (an << 1) + (bn << 1)) puts(\"Yes\");\n        else puts(\"No\");\n    }\n    return 0;\n}\n```","tags":["网络流"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2010] 网络扩容","url":"/BZOJ-1834-ZJOI-2010-网络扩容/","content":"\n## 题目大意\n\n给定一张有向图，每条边都有一个容量 $c$ 和一个扩容费用 $w$。这里扩容费用是指将容量扩大 $1$ 所需的费用。求：\n\n* 在不扩容的情况下，$1$ 到 $n$ 的最大流 \n* 将 $1$ 到 $n$ 的最大流增加 $k$ 所需的最小扩容费用。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n$1 \\leqslant m \\leqslant 5,000$\n\n$1 \\leqslant k \\leqslant 10$\n\n## 题目链接\n\n[【ZJOI 2010】网络扩容 - Luogu 2604](https://www.luogu.com.cn/problem/P2604)\n\n<!-- more -->\n\n## 题解\n\n第一问直接跑最大流。\n\n第二问，对于每条边，再连一条费用为 $w$、容量无限的边表示扩容，最后从源点向 $1$ 连一条容量为 $k$ 的边限制容量。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 1005;\nconst int MAXM = 5005;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr, *pre;\n    int level, flow, dist;\n    bool inq;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow, cost;\n    Edge(Node *u, Node *v, int cap, int cost) : u(u), v(v), cap(cap), flow(0), cost(cost), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap, int cost) {\n    N[u].e = new Edge(&N[u], &N[v], cap, cost);\n    N[v].e = new Edge(&N[v], &N[u], 0, -cost);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 1; i <= n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 1; i <= n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nnamespace EdmondsKarp {\n    void solve(int s, int t, int n, int &flow, int &cost) {\n        flow = cost = 0;\n        while (true) {\n            for (int i = 0; i < n; i++) {\n                N[i].dist = INT_MAX;\n                N[i].flow = 0;\n                N[i].pre = NULL;\n                N[i].inq = false;\n            }\n            std::queue<Node *> q;\n            q.push(&N[s]);\n            N[s].dist = 0;\n            N[s].flow = INT_MAX;\n            while (!q.empty()) {\n                Node *u = q.front();\n                q.pop();\n                u->inq = false;\n                for (Edge *e = u->e; e; e = e->next) {\n                    if (e->cap > e->flow && e->v->dist > u->dist + e->cost) {\n                        e->v->dist = u->dist + e->cost;\n                        e->v->flow = std::min(u->flow, e->cap - e->flow);\n                        e->v->pre = e;\n                        if (!e->v->inq) {\n                            e->v->inq = true;\n                            q.push(e->v);\n                        }\n                    }\n                }\n            }\n            if (N[t].dist == INT_MAX) break;\n            for (Edge *e = N[t].pre; e; e = e->u->pre) {\n                e->flow += N[t].flow;\n                e->rev->flow -= N[t].flow;\n            }\n            flow += N[t].flow;\n            cost += N[t].dist * N[t].flow;\n        }\n    }\n}\nstruct Pair {\n    int u, v, cap, cost;\n} E[MAXM];\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d %d\", &E[i].u, &E[i].v, &E[i].cap, &E[i].cost);\n        addEdge(E[i].u, E[i].v, E[i].cap, 0);\n    }\n    int maxFlow = Dinic::solve(1, n, n);\n    for (int i = 0; i < m; i++) addEdge(E[i].u, E[i].v, INT_MAX, E[i].cost);\n    addEdge(0, 1, k, 0);\n    int flow, cost;\n    EdmondsKarp::solve(0, n, n + 1, flow, cost);\n    printf(\"%d %d\\n\", maxFlow, cost);\n    return 0;\n}\n```","tags":["网络流","费用流"],"categories":["题解（OI/XCPC）"]},{"title":"[TJOI 2015] 线性代数","url":"/BZOJ-3996-TJOI-2015-线性代数/","content":"\n## 题目大意\n\n给定 $n \\times n$ 的矩阵 $\\mathbf{B}$、$1 \\times n$ 的矩阵 $\\mathbf{C}$，另有一个未知的 $1 \\times n$ 的 01 矩阵$\\mathbf{A}$。定义：\n\n$$D = (\\mathbf{A} \\mathbf{B} - \\mathbf{C}) \\times \\mathbf{A}^T$$\n\n求 $D$ 的最大值。\n\n$1 \\leqslant n \\leqslant 500$\n\n$0 \\leqslant b_{i,j}, \\; c_i \\leqslant 1,000$\n\n## 题目链接\n\n[【TJOI 2015】线性代数 - LibreOJ 2100](https://loj.ac/problem/2100)\n\n<!-- more -->\n\n## 题解\n\n化一下式子，显然有：\n$$\nD = \\sum_{i = 1}^{n} \\sum_{j = 1}^{n} b_{i, j} a_i a_j - \\sum_{i = 1}^{n} a_i c_i\n$$\n由于 $\\mathbf{A}$ 是 01 矩阵，我们可以这么转化一下问题：有 $n$ 个物品，代价为 $c_i$，同时选择两个的获益为 $b_{i, j}$，求最大获益。这是显然的最大权闭合图。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 505;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nint n;\nint getID(int x, int y) {\n    return x * n + y;\n}\nint main() {\n    scanf(\"%d\", &n);\n    const int s = 0, t = n + n * n + 1;\n    int tot = 0;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(getID(i, j), i, INT_MAX);\n        addEdge(getID(i, j), j, INT_MAX);\n        addEdge(s, getID(i, j), x);\n        tot += x;\n    }\n    for (int i = 1; i <= n; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        addEdge(i, t, x);\n    }\n    printf(\"%d\\n\", tot - Dinic::solve(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割","最大权闭合图"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2013] 切糕","url":"/BZOJ-3144-HNOI-2013-切糕/","content":"\n## 题目大意\n\n切糕是 $p \\times q \\times r$ 的长方体，每个点有一个违和感 $v_{x, y, z}$。先要水平切开切糕（即对于每个纵轴，切面与其有且只有一个交点），要求水平上相邻两点的切面高度差小于等于 $D$，求切面违和感和的最小值。\n\n$1 \\leqslant p, \\; q, \\; r \\leqslant 40$\n\n$0 \\leqslant v \\leqslant 1,000$\n\n## 题目链接\n\n[【HNOI 2013】切糕 - LibreOJ 2384](https://loj.ac/problem/2384)\n\n<!-- more -->\n\n## 题解\n\n最小割。\n\n用边连接相邻两个高度的的点，边 $(x, y, z - 1) \\rightarrow (x, y, z)$ 容量为 $v_{x, y, z}$，由源点发散出边连接第一层的每个点，最后一层的点收缩在汇点，这是没有$D$的限制是的答案。连接所有形如 $(x, y, z) \\rightarrow (x, y, z - D)$ 的边，这样，当水平相邻的两个点切面差大于 $D$ 时，最小割的图会由这样的边连在一起而没有被隔开。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 40;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN * MAXN + 2];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nint p, q, r;\nint getID(int x, int y, int z) {\n    if (z == 0) return 0;\n    return (z - 1) * p * q + (x - 1) * q + y;\n}\nbool valid(int x, int y) {\n    return (x > 0) && (y > 0) && (x <= p) && (y <= q);\n}\nint main() {\n    int D;\n    scanf(\"%d %d %d %d\", &p, &q, &r, &D);\n    static int v[MAXN + 1][MAXN + 1][MAXN + 1];\n    for (int k = 1; k <= r; k++) for (int i = 1; i <= p; i++) for (int j = 1; j <= q; j++) scanf(\"%d\", &v[i][j][k]);\n    const int s = 0, t = p * q * r + 1;\n    const int d[4][2] = {\n        {0, 1},\n        {0, -1},\n        {1, 0},\n        {-1, 0}\n    };\n    for (int i = 1; i <= p; i++) for (int j = 1; j <= q; j++) {\n        for (int k = 1; k <= r; k++) {\n            addEdge(getID(i, j, k - 1), getID(i, j, k), v[i][j][k]);\n            if (k > D) for (int l = 0; l < 4; l++) {\n                int x = i + d[l][0], y = j + d[l][1];\n                if (valid(x, y)) addEdge(getID(i, j, k), getID(x, y, k - D), INT_MAX);\n            }\n        }\n        addEdge(getID(i, j, r), t, INT_MAX);\n    }\n    printf(\"%d\\n\", Dinic::solve(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割"],"categories":["题解（OI/XCPC）"]},{"title":"[AHOI 2006] 上学路线","url":"/BZOJ-1266-AHOI-2006-上学路线/","content":"\n## 题目大意\n\n题目有两问。第一问是求给定的两点间最短路；第二问中，每条边除了权值 $w$ 以外还有一个代价 $c$，求使那两点间最短路变大（不再联通也算）的最小代价。\n\n$2 \\leqslant n \\leqslant 500$\n\n$1 \\leqslant m \\leqslant 124,750$\n\n$1 \\leqslant w, \\; c \\leqslant 10,000$\n\n## 题目链接\n\n[【AHOI 2006】上学路线 - Luogu 4300](https://www.luogu.com.cn/problem/P4300)\n\n<!-- more -->\n\n## 题解\n\n第一问直接跑 Dijkstra 就行了。。。\n\n第二问，对于所有在最短路上的边，以代价为容量建最小割；判断一条边是否在最短路上，以起点、终点为源各跑一遍 Dijkstra，满足 $e.u.dist[s] + e.w + e.v.dist[t] = t.dist[s] = s.dist[t]$ 就是。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n#include <new>\nconst int MAXN = 505;\nconst int MAXM = 124755;\nstruct EdgeD;\nstruct NodeD {\n    EdgeD *e;\n    int dist[2], id;\n    bool vis[2];\n} ND[MAXN];\nstruct EdgeD {\n    NodeD *u, *v;\n    EdgeD *next;\n    int w, c;\n    EdgeD() {}\n    EdgeD(NodeD *u, NodeD *v, int w, int c) : u(u), v(v), w(w), c(c), next(u->e) {}\n} _pool[MAXM << 1], *_cur = _pool;\nvoid addEdgeD(int  u, int v, int w, int c) {\n    ND[u].e = new (_cur++) EdgeD(&ND[u], &ND[v], w, c);\n    ND[v].e = new (_cur++) EdgeD(&ND[v], &ND[u], w, c);\n}\nnamespace Dijkstra {\n    struct HeapNode {\n        NodeD *u;\n        int dist;\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    void solve(NodeD *s, int id, int n) {\n        for (int i = 1; i <= n; i++) {\n            ND[i].dist[id] = INT_MAX;\n            ND[i].vis[id] = false;\n        }\n        std::priority_queue<HeapNode> q;\n        s->dist[id] = 0;\n        q.push((HeapNode) {s, 0});\n        while (!q.empty()) {\n            NodeD *u = q.top().u;\n            q.pop();\n            if (u->vis[id]) continue;\n            u->vis[id] = true;\n            for (EdgeD *e = u->e; e; e = e->next) {\n                if (e->v->dist[id] > u->dist[id] + e->w) {\n                    e->v->dist[id] = u->dist[id] + e->w;\n                    q.push((HeapNode) {e->v, e->v->dist[id]});\n                }\n            }\n        }\n    }\n}\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 1; i <= n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 1; i <= n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nvoid build(int dist) {\n    for (EdgeD *e = _pool; e != _cur; e++) {\n        if (e->u->dist[0] + e->v->dist[1] + e->w == dist) {\n            addEdge(e->u->id, e->v->id, e->c);\n        }\n    }\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) {\n        int u, v, w, c;\n        scanf(\"%d %d %d %d\", &u, &v, &w, &c);\n        addEdgeD(u, v, w, c);\n    }\n    Dijkstra::solve(&ND[1], 0, n);\n    printf(\"%d\\n\", ND[n].dist[0]);\n    Dijkstra::solve(&ND[n], 1, n);\n    for (int i = 1; i <= n; i++) ND[i].id = i;\n    build(ND[n].dist[0]);\n    printf(\"%d\\n\", Dinic::solve(1, n, n));\n    return 0;\n}\n```","tags":["网络流","单源最短路","最小割"],"categories":["题解（OI/XCPC）"]},{"title":"[JLOI 2011] 飞行路线","url":"/BZOJ-2763-JLOI-2011-飞行路线/","content":"\n## 题目大意\n\n求可忽略最多 $k$ 条边的权值的情况下，给定的两点间的最短路。\n\n$2 \\leqslant n \\leqslant 10,000$\n\n$1 \\leqslant m \\leqslant 50,000$\n\n$0 \\leqslant k \\leqslant 10$\n\n## 题目链接\n\n[【JLOI 2011】飞行路线 - Luogu 4568](https://www.luogu.com.cn/problem/P4568)\n\n<!-- more -->\n\n## 题解\n\n分层最短路（是这个叫法吧。。。）。\n\n$u.dist[k]$ 表示从起点到节点 $u$、有 $k$ 条边不计权值的最短距离。对于每条边，除了用 $u.dist[k] + e.w$ 更新$e.v.dist[k]$ 以外，还需要用 $u.dist[k]$ 更新 $e.v.dist[k + 1]$。用 Dijkstra 跑一遍就行了。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 10005;\nconst int MAXK = 15;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dist[MAXK];\n    bool vis[MAXK];\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n    Edge (Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n};\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\nint n, m, k;\nnamespace Dijkstra {\n    struct HeapNode {\n        Node *u;\n        int dist, k;\n        HeapNode(Node *u, int k, int dist) : u(u), k(k), dist(dist) {}\n        bool operator<(const HeapNode &another) const {\n            return dist > another.dist;\n        }\n    };\n    void solve(Node *s) {\n        for (int i = 0; i < n; i++) for (int j = 0; j <= k; j++) {\n            N[i].dist[j] = INT_MAX;\n            N[i].vis[j] = false;\n        }\n        std::priority_queue<HeapNode> q;\n        for (int i = 0; i <= k; i++) {\n            s->dist[i] = 0;\n            q.push(HeapNode(s, i, 0));\n        }\n        while (!q.empty()) {\n            Node *u = q.top().u;\n            int k = q.top().k;\n            q.pop();\n            if (u->vis[k]) continue;\n            u->vis[k] = true;\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->v->dist[k] > u->dist[k] + e->w) {\n                    e->v->dist[k] = u->dist[k] + e->w;\n                    q.push(HeapNode(e->v, k, e->v->dist[k]));\n                }\n                if (e->v->dist[k + 1] > u->dist[k] && k < ::k) {\n                    e->v->dist[k + 1] = u->dist[k];\n                    q.push(HeapNode(e->v, k + 1, e->v->dist[k + 1]));\n                }\n            }\n        }\n    }\n}\nint main() {\n    int s, t;\n    scanf(\"%d %d %d %d %d\", &n, &m, &k, &s, &t);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        addEdge(u, v, w);\n    }\n    Dijkstra::solve(&N[s]);\n    int ans = INT_MAX;\n    for (int i = 0; i <= k; i++) ans = std::min(ans, N[t].dist[i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["单源最短路","分层最短路"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2007] 涂色","url":"/BZOJ-1260-CQOI-2007-涂色/","content":"\n## 题目大意\n\n给定一个长为 $n$ 的字符串表示染色目标，每次只能把连续的一段染成同一颜色，求最少染色次数。\n\n$1 \\leqslant n \\leqslant 50$\n\n## 题目链接\n\n[【CQOI 2007】涂色 - Luogu 4170](https://www.luogu.com.cn/problem/P4170)\n\n<!-- more -->\n\n## 题解\n\n区间 DP。\n\n记 $f[i, \\; j]$ 表示区间 $[i, \\; j]$ 的答案，转移为：\n$$\nf[i, \\; j] = \n\\begin{cases}\n\\begin{align}\nmin(f[i  + 1, \\; j], \\; f[i, \\; j - 1], \\; f[i + 1,\\; j - 1] + 1) &\\quad s[i] = s[j] \\\\\nmin(f[i, \\; k] + f[k + 1, \\; j]) &\\quad s[i] \\neq s[j]\n\\end{align}\n\\end{cases}\n$$\n其中 $s$ 为目标，答案为 $f[1, \\; n]$。\n\n被数据范围吓到了。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 55;\nint f[MAXN][MAXN];\nchar s[MAXN];\nvoid dp(int n) {\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) \n        f[i][j] = i == j ? 1 : INT_MAX;\n    for (int l = 1; l < n; l++) for (int i = 1; i <= n - l; i++) {\n        int j = i + l;\n        if (s[i] == s[j]) {\n            if (l == 1) f[i][j] = 1;\n            else f[i][j] = std::min(std::min(f[i + 1][j], f[i][j - 1]), \n                                    f[i + 1][j - 1] + 1);\n        } else for (int k = i; k < j; k++) \n            f[i][j] = std::min(f[i][j], f[i][k] + f[k + 1][j]);\n    }\n}\nint main() {\n    scanf(\"%s\", s + 1);\n    int n = strlen(s + 1);\n    dp(n);\n    printf(\"%d\\n\", f[1][n]);\n    return 0;\n}\n```","tags":["DP","区间DP"],"categories":["题解（OI/XCPC）"]},{"title":"Manacher 学习笔记","url":"/Manacher-学习笔记/","content":"\n## 算法介绍\n\nManacher 算法是能在 $O(n)$ 求解以每个位置为中心的最长回文子串长度的算法。\n\n## 算法过程\n\n在原字符串 $s$ 的两头分别加入不在字符集内的字符，比如 `@`、`\\0`，同时，在每相邻两个字符间加入不在字符集内的字符，比如 `#`，这样对于偶数长的回文子串也能像奇数长的回文子串一样处理。以此得到新字符串 $s'$ ，之后的操作均在 $s'$ 上。\n\n定义 $right$ 为已经算出来的所有回文子串中，右侧最远的一个的右侧端点，$pos$ 为其回文中心。\n\n假设目前在考虑位置 $i$ ，记 $j = 2 pos - i$ ，即 $i$ 关于 $pos$ 的对称点。分三种情况：\n\n<!-- more -->\n\n* $right < i$\n\n  无特殊性质，$r_i \\geqslant 1$\n\n* $right \\geqslant i, \\; j - r_j \\geqslant 2 pos - right$\n\n  $r_i \\geqslant r_j$\n\n* $right \\geqslant i, \\; j - r_j < 2 pos - right$\n\n  $r_i \\geqslant right - i$\n\n在由以上三种情况对应的最小值的基础上进行比较。\n\n## 模版题\n\n[POJ 3974](http://poj.org/problem?id=3974) （[题解](http://pepcy.cf/POJ-3974-Palindrome/)）","tags":["学习笔记","字符串","Manacher"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[国家集训队] 最长双回文串","url":"/BZOJ-2565-最长双回文串/","content":"\n## 题目大意\n\n给定一个字符串 $s$，求 $s$ 的最长双回文子串 $t$，即可将  $t$ 分为两部分 $x$、$y$（$|x|, \\; |y| \\geqslant 1$）且 $x$ 和 $y$ 都是回文串。\n\n$2 \\leqslant |s| \\leqslant 100,000$\n\n## 题目链接\n\n[【国家集训队】最长双回文串 - Luogu 4555](https://www.luogu.com.cn/problem/P4555)\n\n<!-- more -->\n\n## 题解\n\n求出 $from_i$ 数组表示从 $i$ 开始的最长回文子串长，$last_i$ 表示在 $i$ 结尾的最长回文子串的长，答案即为 $max(last_i + from_{i + 1})$。\n\n考虑这两个数组的求法。用 Manacher 计算出 $r_i$ 数组，扫一遍 $r_i $数组，可以更新每个位置为中心的最长的回文子串的两头的两个数组的值；发现有 $from_i \\geqslant from_{i - 1} - 1$、$last_i \\geqslant last_{i + 1} - 1$，再扫一遍更新这两个数组的值。\n\n最后枚举每一个在 Manacher 中添加的 `#` 字符，答案为 $max(last_i + from_i), s'[i] = \\#$。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nchar s[MAXN];\nnamespace Manacher {\n    int r[MAXN << 1], len;\n    char s[MAXN << 1];\n    void prepare() {\n        len = 0;\n        s[++len] = '@';\n        s[++len] = '#';\n        int n = strlen(::s);\n        for (int i = 0; i < n; i++) s[++len] = ::s[i], s[++len] = '#';\n        s[++len] = '\\0';\n    }\n    void manacher() {\n        int right = 0, pos = 0;\n        for (int i = 1; i <= len; i++) {\n            int x = right < i ? 1 : std::min(r[2 * pos - i], right - i);\n            while (s[i + x] == s[i - x]) x++;\n            if (x + i > right) {\n                right = x + i;\n                pos = i;\n            }\n            r[i] = x;\n        }\n    }\n    void calc() {\n        prepare();\n        manacher();\n    }\n}\nint main() {\n    scanf(\"%s\", s);\n    Manacher::calc();\n    static int from[MAXN << 1], last[MAXN << 1];\n    int *r = Manacher::r, len = Manacher::len;\n#ifdef DBG\n    puts(Manacher::s + 1);\n    for (int i = 1; i <= len; i++) printf(\"pos: %d, r: %d\\n\", i, r[i]);\n#endif\n    for (int i = 1; i <= len; i++) {\n        if (i - r[i] + 1 > 0) from[i - r[i] + 1] = std::max(from[i - r[i] + 1], r[i] - 1); \n        if (i + r[i] - 1 <= len) last[i + r[i] - 1] = std::max(last[i + r[i] - 1], r[i] - 1);\n    }\n#ifdef DBG\n    puts(Manacher::s + 1);\n    for (int i = 1; i <= len; i++) printf(\"pos: %d, from: %d, last: %d\\n\", i, from[i], last[i]);\n#endif\n    for (int i = 2; i <= len; i++) from[i] = std::max(from[i], from[i - 1] - 1);\n    for (int i = len - 1; i; i--) last[i] = std::max(last[i], last[i + 1] - 1);\n#ifdef DBG\n    puts(Manacher::s + 1);\n    for (int i = 1; i <= len; i++) printf(\"pos: %d, from: %d, last: %d\\n\", i, from[i], last[i]);\n#endif\n    int ans = 0;\n    for (int i = 1; i <= len; i++) if (Manacher::s[i] == '#') \n        ans = std::max(ans, last[i] + from[i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["字符串","Manacher"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2010] 生成字符串","url":"/BZOJ-1856-SCOI-2010-字符串/","content":"\n## 题目大意\n\n把 $n$ 个 $1$ 和 $m$ 个 $0$ 组成字符串，要求在组成的字符串中，在任意的前 $k$ 个字符中，$1$ 的个数不能少于 $0$ 的个数。求可能的字符串数，对 $20100403$ 取模。\n\n$1 \\leqslant n, \\; m \\leqslant 1,000,000$\n\n## 题目链接\n\n[【SCOI 2010】生成字符串  - Luogu 1641](https://www.luogu.com.cn/problem/P1641)\n\n<!-- more -->\n\n## 题解\n\n将问题进行转化，对于每一位，若下一位选 $1$，则向相对其 $(1, \\; 1)$ 的位置移动，选 $0$ 则向 $(1, \\; -1)$ 移动，所求即从 $(0, \\; 0)$ 移动到 $(n + m, \\; n - m)$ 且不跨过 $y = 0$（该直线上可以）的方案数。\n\n不考虑限制，答案是 $\\binom{n + m}{n}$。所有跨过 $y = 0$ 的方案都会经过 $y = -1$，对这些方案，相当于从 $(0, \\; -2)$（原起点关于 $y = -1$ 的对称点）到 $(n + m, \\; n - m)$ 的方案数，为 $\\binom{n + m}{n + 1}$。\n\n故，最终答案为：\n$$\n\\binom{n + m}{n} - \\binom{n + m}{n + 1} = \\frac{(n + m)!}{n! \\times m!} \\times \\frac{n - m + 1}{n + 1}\n$$\n当 $m = n$ 时，答案即为对应项的卡特兰数。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MOD = 20100403;\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nlong long inv(long long a) {\n    return pow(a, MOD - 2);\n}\nlong long fact(long long a) {\n    long long res = 1;\n    for (int i = 1; i <= a; i++) res = res * i % MOD;\n    return res;\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    printf(\"%lld\\n\", fact(n + m) * inv(fact(m)) % MOD * inv(fact(n)) % MOD \n           * (n - m + 1) % MOD * inv(n + 1) % MOD);\n    return 0;\n}\n```","tags":["计数","卡特兰数"],"categories":["题解（OI/XCPC）"]},{"title":"[POJ 3974] Palindrome","url":"/POJ-3974-Palindrome/","content":"\n## 题目大意\n\n给定一个字符串，求其最长的回文子串的长度，多组询问。\n\n$1 \\leqslant|s| \\leqslant 1,000,000$\n\n$1 \\leqslant T \\leqslant 30$\n\n## 题目链接\n\n[POJ 3974](http://poj.org/problem?id=3974)\n\n<!-- more -->\n\n## 题解\n\nManacher 模版题，计算出$r_i$数组后找最大值即可。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 1000005;\nchar s[MAXN];\nnamespace Manacher {\n    int len, r[MAXN << 1];\n    char s[MAXN << 1];\n    void prepare() {\n        len = 0;\n        s[++len] = '@';\n        s[++len] = '#';\n        int n = strlen(::s);\n        for (int i = 0; i < n; i++) s[++len] = ::s[i], s[++len] = '#';\n        s[++len] = '\\0';\n    }\n    void manacher() {\n        int right = 0, pos = 0;\n        for (int i = 1; i <= len; i++) {\n            int x = right < i ? 1 : std::min(r[2 * pos - i], right - i);\n            while (s[i + x] == s[i - x]) x++;\n            if (x + i > right) {\n                right = x + i;\n                pos = i;\n            }\n            r[i] = x;\n        }\n    }\n    void calc() {\n        prepare();\n        manacher();\n    }\n}\nint main() {\n    int T = 0;\n    while (scanf(\"%s\", s), s[0] != 'E') {\n        Manacher::calc();\n        int ans = 0;\n        for (int i = 1; i <= Manacher::len; i++) ans = std::max(ans, Manacher::r[i] - 1);\n        printf(\"Case %d: %d\\n\", ++T, ans);\n    }\n    return 0;\n}\n```","tags":["字符串","模版","Manacher"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2011] 打地鼠","url":"/BZOJ-2241-SDOI-2011-打地鼠/","content":"\n## 题目大意\n\n在 $n \\times m$ 的网格上打地鼠，每个格子上有 $a_{i, j}$ 只地鼠。使用一种特殊的锤子，大小为 $r \\times c$，不能旋转，每次砸下去会打掉范围内每个格子恰好一只地鼠，打之前范围内不能有格子没有地鼠，锤子的大小只在游戏开始前设定好，游戏中无法改变。求最少的敲击次数。\n\n$1 \\leqslant n, \\; m \\leqslant 100$\n\n$0 \\leqslant a_{i, \\; j} \\leqslant 100,000$\n\n## 题目链接\n\n[【SDOI 2011】打地鼠 - Luogu 2484](https://www.luogu.com.cn/problem/P2484)\n\n<!-- more -->\n\n## 题解\n\n枚举锤子大小进行判断。\n\n判断时，枚举要砸下去的左上角，整个范围内减去左上角的地鼠数（因为左上角的格子在枚举过程中，最后一次被覆盖到就是成为左上角时），当减出负数时失败。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\nconst int MAXN = 105;\nint n, m, mat[MAXN][MAXN];\nbool check(int r, int c) {\n    static int temp[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) std::copy(mat[i] + 1, mat[i] + m + 1, temp[i] + 1);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        if (!temp[i][j]) continue;\n        if (i + r - 1 > n && j + c - 1 > m) return false;\n        int t = temp[i][j];\n        for (int x = i; x < i + r; x++) for (int y = j; y < j + c; y++) {\n            temp[x][y] -= t;\n            if (temp[x][y] < 0) return false;\n        }\n    }\n    return true;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    int sum = 0;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &mat[i][j]), sum += mat[i][j];\n    int ans = INT_MAX;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        if (sum % (i * j) == 0 && sum / (i * j) < ans && check(i, j)) ans = sum / (i * j);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["枚举"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2009] 植物大战僵尸","url":"/BZOJ-1565-NOI-2009-植物大战僵尸/","content":"\n## 题目大意\n\n游戏棋盘为 $n\\times m$，行从上到下从 $0$ 开始编号，列从左到右从 $0$ 开始编号（僵尸从 $m - 1$ 列进入）。每一个植物有一个攻击范围，会瞬间消灭进入范围内的僵尸（僵尸无法吃到该位置上的植物）；同时，每一个植物有一个分数 $score_i$ ，在僵尸吃了该植物后会获得相应分数。求僵尸可获得的最多分数。\n\n$1 \\leqslant n \\leqslant 20$\n\n$1 \\leqslant m \\leqslant 30$\n\n$-10,000 \\leqslant score_i \\leqslant 10,000$\n\n## 题目链接\n\n[【NOI 2009】植物大战僵尸 - Luogu 2805](https://www.luogu.com.cn/problem/P2805)\n\n<!-- more -->\n\n## 题解\n\n在网格上连单向边 $(u, \\; v)$ 表示，在吃掉 $v$ 之前，必须先吃掉 $u$；程序实现时，从每个植物向其保护的位置连边，从每个格子向左边的格子连边。注意到，当图里出现了环时，环上的点、环延伸出去的点都不能被吃掉；对于剩下的点，即求最大权闭合图。从源点向正权点连容量为权值的边，从负权点向汇点连容量为权值绝对值的边，对于原图中的边，反向连入（如果不想反向，源点连负权，汇点连正权），跑最大流。在找环时，用拓扑排序，没有遍历到的点就是吃不掉的点。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 20;\nconst int MAXM = 30;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXM + 2];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n#ifdef DBG\n    printf(\"edge : %d --> %d, cap = %d\\n\", u, v, cap);\n#endif\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nstruct EdgeT;\nstruct NodeT {\n    EdgeT *e;\n    int deg, id;\n    bool vis;\n} NT[MAXN * MAXM + 1];\nstruct EdgeT {\n    NodeT *u, *v;\n    EdgeT *next;\n    EdgeT(NodeT *u, NodeT *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdgeT(int u, int v) {\n#ifdef DBG\n    printf(\"edgeT : %d --> %d\\n\", u, v);\n#endif\n    NT[u].e = new EdgeT(&NT[u], &NT[v]);\n    NT[v].deg++;\n}\nnamespace TopoSort {\n    void dfs(NodeT *u) {\n        u->vis = false;\n        for (EdgeT *e = u->e; e; e = e->next) if (e->v->vis) dfs(e->v);\n    }\n    void findCircle(int n) {\n        std::stack<NodeT *> s;\n        for (int i = 1; i <= n; i++) {\n            if (NT[i].deg == 0) s.push(&NT[i]);\n            else NT[i].vis = false;\n        }\n        while (!s.empty()) {\n            NodeT *u = s.top();\n            s.pop();\n            u->vis = true;\n            for (EdgeT *e = u->e; e; e = e->next) {\n                e->v->deg--;\n                if (e->v->deg == 0) s.push(e->v);\n            }\n        }\n        // for (int i = 1; i <= n; i++) if (!NT[i].vis) dfs(&NT[i]);\n    }\n}\nint n, m;\nint getID(int x, int y) {\n    return (x - 1) * m + y;\n}\nint score[MAXN * MAXM + 1], tot;\nvoid rebuild() {\n    tot = 0;\n    const int s = 0, t = n * m + 1;\n    for (int i = 1; i <= getID(n, m); i++) {\n        if (!NT[i].vis) continue;\n        if (score[i] > 0) addEdge(s, i, score[i]), tot += score[i];\n        else addEdge(i, t, -score[i]);\n        for (EdgeT *e = NT[i].e; e; e = e->next) if (e->v->vis) \n            addEdge(e->v->id, i, INT_MAX);\n    }\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int k;\n#ifdef DBG\n        printf(\"(%d, %d)\\n\", i, j);\n#endif\n        scanf(\"%d %d\", &score[getID(i, j)], &k);\n        NT[getID(i, j)].id = getID(i, j);\n        while (k--) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            x++, y++;\n            addEdgeT(getID(i, j), getID(x, y));\n        }\n        if (j != 1) addEdgeT(getID(i, j), getID(i, j - 1));\n    }\n    TopoSort::findCircle(getID(n, m));\n    rebuild();\n#ifdef DBG\n    printf(\"tot = %d\\n\", tot);\n#endif\n    const int s = 0, t = n * m + 1;\n    printf(\"%d\\n\", tot - Dinic::solve(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割","最大权闭合图","拓扑排序"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2012] 排队","url":"/BZOJ-2729-HNOI-2012-排队/","content":"\n## 题目大意\n\n有 $n$ 名男同学，$m$ 名女同学和两名老师要排队参加体检。他们排成一条直线，并且任意两名女同学不能相邻，两名老师也不能相邻，求一共有多少种排法（注意：任意两个人都是不同的）。\n\n$1 \\leqslant n, \\; m \\leqslant 2,000$\n\n## 题目链接\n\n[【HNOI 2012】排队 - Luogu 3223](https://www.luogu.com.cn/problem/P3223)\n\n<!-- more -->\n\n## 题解\n\n纯数学题 + 高精度，就做一个高精度的版子吧。。。\n\n考虑先让老师站一起和男生排队，有 $2(n + 1)!$ 种，再选一个女生插到老师之间，剩下的 $m - 1$ 个女生插入到 $n + 2$ 个空之间（两个老师与之间的女生可视作一个男生），答案为 $2m(n + 1)!(n + 2)^{\\underline{m - 1}}$。\n\n再考虑老师由男生插开，即在排好的男生中的 $n + 1$ 个空中插两个，再在这 $n + 3$ 个空中插入女生，答案为 $n!(n + 1)^{\\underline{2}}(n + 3)^{\\underline{m}}$。\n\n最终答案为：\n$$\nn! ( \\; 2m(n + 1)(n + 2)^{\\underline{m - 1}} + (n + 1)^{\\underline{2}}(n + 3)^{\\underline{m}} \\; )\n$$\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 2005;\nstruct BigInteger {\n    int len, a[20000];\n    BigInteger(int num = 0) {\n        memset(a, 0, sizeof (a));\n        len = 1;\n        while (num) {\n            a[len++] = num % 10;\n            num /= 10;\n        }\n        maintain();\n    }\n    void print() const {\n        for (int i = len; i; i--) printf(\"%d\", a[i]);\n        puts(\"\");\n    }\n    void maintain() {\n        while (a[len + 1]) len++;\n        while (!a[len] && len > 1) len--;\n    }\n    static int getLength(int x) {\n        int len = 0;\n        while (x) {\n            x /= 10;\n            len++;\n        }\n        if (len == 0) len = 1;\n        return len;\n    }\n    BigInteger operator+(const BigInteger &another) const {\n        BigInteger res;\n        res.len = std::max(len, another.len);\n        for (int i = 1; i <= res.len; i++) {\n            res.a[i] += a[i] + another.a[i];\n            if (res.a[i] > 10) {\n                res.a[i] -= 10;\n                res.a[i + 1]++;\n            }\n        }\n        res.maintain();\n        return res;\n    }\n    BigInteger operator*(int another) const {\n        BigInteger res;\n        res.len = len + getLength(another);\n        for (int i = 1; i <= res.len; i++) {\n            res.a[i] += a[i] * another;\n            res.a[i + 1] += res.a[i] / 10;\n            res.a[i] %= 10;\n        }\n        res.maintain();\n        return res;\n    }\n};\nvoid mulPermu(BigInteger &a, int n, int m) {\n    if (n < m) a = a * 0;\n    else for (int i = n; i > n - m; i--) a = a * i;\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    BigInteger a(2), b(1);\n    mulPermu(a, n + 2, m - 1);\n    a = a * m;\n    a = a * (n + 1);\n    mulPermu(b, n + 1, 2);\n    mulPermu(b, n + 3, m);\n    a = a + b;\n    mulPermu(a, n, n);\n    a.print();\n    return 0;\n}\n```","tags":["计数","高精度"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2012] 容易题","url":"/BZOJ-2751-HAOI-2012-容易题/","content":"\n## 题目大意\n\n给定一个有 $m$ 个元素的数列 $\\{a_i\\}$，有 $1 \\leqslant a_i \\leqslant n$，并且对于一些 $a_i$ 有些值不能取（一共有 $k$ 个限制）。我们定义一个数列的积为该数列所有元素的乘积，要求你求出所有可能的数列的积h的和模 $1,000,000,007$ 的值。\n\n$1 \\leqslant n, \\; m \\leqslant 1,000,000,000$\n\n$1 \\leqslant k \\leqslant 100,000$\n\n## 题目链接\n\n[【HAOI 2012】容易题 - Luogu 2220](https://www.luogu.com.cn/problem/P2220)\n\n<!-- more -->\n\n## 题解\n\n所求数列积的和即为（意会证明吧。。。）：\n$$\n\\prod_{i = i}^{m} \\sum_{j = 1}^{n} j \\times [j可选]\n$$\n对限制排序，有限制的位从 $\\sum_{i = 1}^{n}i$ 中减去对应的值并乘进答案，剩下的用快速幂计算。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXK = 100005;\nconst int MOD = 1000000007;\nstruct Taboo {\n    int pos, val;\n    bool operator<(const Taboo &another) const {\n        return pos == another.pos ? val < another.val : pos < another.pos;\n    }\n} T[MAXK];\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nint main() {\n    int n, m, k;\n    scanf(\"%d %d %d\", &n, &m, &k);\n    for (int i = 0; i < k; i++) scanf(\"%d %d\", &T[i].pos, &T[i].val);\n    std::sort(T, T + k);\n    long long sum = (long long) n * (n + 1) / 2 % MOD, temp = sum;\n    long long ans = 1;\n    for (int i = 0; i < k; i++) {\n        if (i != 0 && T[i].pos != T[i - 1].pos) {\n            ans = ans * temp % MOD;\n            temp = sum;\n            m--;\n        }\n        if (i == 0 || T[i].pos != T[i - 1].pos || T[i].val != T[i - 1].val)\n            temp = (temp + MOD - T[i].val) % MOD;\n    }\n    m--;\n    ans = ans * temp % MOD;\n    printf(\"%lld\\n\", ans * pow(sum, m) % MOD);\n    return 0;\n}\n```","tags":["快速幂"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2012] 滑雪与时间胶囊","url":"/BZOJ-2753-SCOI-2012-滑雪与时间胶囊/","content":"\n## 题目大意\n\n给定一个 $n$ 个节点、$m$ 条无向带权边的图，每个节点有一个高度 $h_i$，只能从某一个节点走到高度不大于其的点；另外，可以无数次的回到上一个节点。求最多能访问多少节点，以及此时的最短距离。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant m \\leqslant 1,000,000$\n\n$1 \\leqslant w_i, \\; h_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【SCOI 2012】滑雪 - Luogu 2573](https://www.luogu.com.cn/problem/P2573)\n\n<!-- more -->\n\n## 题解\n\n由于有高度的限制，无向边其实是有向边（相同高度就是两条），第一问随便遍历一遍图就行了，而第二问就是要求最小树形图。求最小树形图的朱刘算法，虽然我不会，但它的复杂度为 $O(nm)$，会 TLE。考虑 Kruskal 为什么不能求解：因为边的有向可能会导致中间某条边是反向的，使得由根无法到达更下的节点。但对于同一高度的点，Kruskal 是正确的，故把边以高度为第一关键字、边权为第二关键字排序，做 Kruskal。\n\n算个神题吧。。。（或者我好菜啊。。。）\n\n才发现之前的题解中「Kruskal」好像拼错了，代码也是刚改的（提上去的拼写也是错的）。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nconst int MAXM = 1000005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int height;\n    bool vis;\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n#ifdef DBG\n    printf(\"edge : %d --> %d\\n\", u, v);\n#endif\n    N[u].e = new Edge(&N[u], &N[v]);\n}\nstruct Pair {\n    int u, v, w;\n    bool operator<(const Pair &another) const {\n        return N[v].height == N[another.v].height ? w < another.w : N[v].height > N[another.v].height;\n    }\n} E[MAXM];\nint n, m;\nint bfs() {\n    int res = 1;\n    std::queue<Node *> q;\n    q.push(&N[1]);\n    N[1].vis = true;\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n#ifdef DBG\n        printf(\"bfs(%d)\\n\", u->id);\n#endif\n        for (Edge *e = u->e; e; e = e->next) {\n#ifdef DBG\n            printf(\"bfs(%d), v = %d\\n\", u->id, e->v->id);\n#endif\n            if (!e->v->vis) {\n                e->v->vis = true;\n                res++;\n                q.push(e->v);\n            }\n        }\n    }\n    return res;\n}\nnamespace Kruskal {\n    struct UnionFindSet {\n        int fa[MAXN];\n        int find(int x) {\n            return x == fa[x] ? x : fa[x] = find(fa[x]);\n        }\n        void init(int n) {\n            for (int i = 1; i <= n; i++) fa[i] = i;\n        }\n    } ufs;\n    long long solve() {\n        ufs.init(n);\n        std::sort(E, E + m);\n        long long res = 0;\n        for (int i = 0; i < m; i++) {\n            if (!N[E[i].u].vis || !N[E[i].v].vis) continue;\n            int p = ufs.find(E[i].u), q = ufs.find(E[i].v);\n            if (p == q) continue;\n            ufs.fa[q] = p;\n            res += E[i].w;\n        }\n        return res;\n    }\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n#ifdef DBG\n    for (int i = 1; i <= n; i++) N[i].id = i;\n#endif\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].height);\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w);\n        if (N[E[i].u].height < N[E[i].v].height) std::swap(E[i].u, E[i].v);\n        addEdge(E[i].u, E[i].v);\n        if (N[E[i].u].height == N[E[i].v].height) addEdge(E[i].v, E[i].u);\n    }\n    printf(\"%d \", bfs());\n    printf(\"%lld\\n\", Kruskal::solve());\n    return 0;\n}\n```","tags":["图","最小生成树"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2010] 扑克牌","url":"/BZOJ-1816-CQOI-2010-扑克牌/","content":"\n## 题目大意\n\n有 $n$ 种牌，数目为 $c_i$，另外有一种特殊的牌：joker，它的数目是 $m$。你可以用每种牌各一张来组成一套牌，也可以用一张 joker 和除了某一种牌以外的其他牌各一张组成一套牌。 求每张牌最多只能用在一副套牌里（可以有牌不使用）时套牌组数的最大值。\n\n$1 \\leqslant n \\leqslant 50$\n\n$1 \\leqslant m, \\; c_i \\leqslant 500,000,000$\n\n## 题目链接\n\n[【CQOI 2010】扑克牌](https://www.luogu.com.cn/problem/P5815)\n\n<!-- more -->\n\n## 题解\n\n二分答案。\n\n判定时，如果有一种牌数量不够，用 joker 补，joker 提前用完则不可行，最大答案为 $2 max(m, \\; c_i)$。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 55;\nconst int MAXM = 500000000;\nint c[MAXN], n, m;\nbool check(int x) {\n    int j = std::min(x, m);\n    for (int i = 0; i < n; i++) {\n        if (c[i] < x) {\n            j -= x - c[i];\n            if (j < 0) return false;\n        }\n    }\n    return true;\n}\nint dichotomy() {\n    int l = 0, r = MAXM << 1;\n    while (l < r) {\n        int mid = l + (r - l) / 2 + 1;\n        if (check(mid)) l = mid;\n        else r = mid - 1;\n    }\n    return l;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) scanf(\"%d\", &c[i]);\n    printf(\"%d\\n\", dichotomy());\n    return 0;\n}\n```","tags":["二分"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2008] 奖励关","url":"/BZOJ-1076-SCOI-2008-奖励关/","content":"\n## 题目大意\n\n有 $n$ 个物品，每个物品有一个价值 $w_i$，有些物品在吃之前要先吃过一些其他的物品。给定 $k$ 次，每次可以选择吃一个物品或不吃，若选择吃，每种物品会等概率被吃到。求最优策略下的期望得分。\n\n$1 \\leqslant n \\leqslant 15$\n\n$1 \\leqslant k \\leqslant 100$\n\n$-1,000,000 \\leqslant w_i \\leqslant 1,000,000$\n\n## 题目链接\n\n[【SCOI 2008】奖励关 - Luogu 2473](https://www.luogu.com.cn/problem/P2473)\n\n<!-- more -->\n\n## 题解\n\nDP + 状态压缩。\n\n记 $f[i,\\; s]$ 为考虑到第 $i$ 次，状态为 $s$ 时的答案。由于一般的正序递推可能会推到不合法的状态上，故我们倒序递推，保证一定从合法的状态转移来。\n$$\nf[i, \\; s] \\rightarrow \n\\begin{cases}\n\\begin{align}\nf[i + 1, \\; s] &\\\\\nf[i +1, \\; s \\; | \\; j] + w_j &\\quad j \\ 是可选的物品\n\\end{align}\n\\end{cases}\n$$\n把后面那一堆加起来，再除以 $n$ 就是第 $i$ 天的期望。\n\n再详细说一下正推的问题（本人想了一个小时。。。）：无论是正推还是倒推，我们都只考虑了当前这一步是否合法，但可能原来的状态就是不合法的（比如当前考虑某物品是否可被吃，而它的需求集合里，有的物品仍然有其非空的需求集合）。倒推时，我们把物品逐一减少，最后的答案就是 $f[1, \\; 0]$，而正推时我们一个个地添加物品，答案是 $f[k, \\; s]$，$s$ 还要再枚举一遍。不过，这不是问题所在。正推与倒推只是方向相反的问题，而问题出在只有一个东西时，正推虽然不会让 $f[i, \\; 0]$ 向 $f[i + 1, \\; 0 \\; | \\; j]$（$j$ 有非空需求集合的）转移，但后者的值显然还是 $0$，意思是之后的情况下，它仍会像视一个合法方案一样去更新其他的值；倒推时，$f[1, \\; 0]$ 就是答案，答案只会从合法的只有一个东西的状态转移来，就算那些不合法的值是 $0$，但转移时不会从那里转移，就不会有问题。\n\n可以考虑这样的栗子：东西为 $\\{a, \\; b, \\; c\\}$，其中 $b$ 需要 $a$，$c$ 需要 $b$，手玩一下就可以发现问题所在。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 20;\nconst int MAXSTATUE = 65536;\nconst int MAXK = 105;\ndouble f[MAXK][MAXSTATUE];\nint need[MAXN], w[MAXN], pow[MAXN];\nint k, n;\nvoid dp() {\n    for (int i = k; i; i--) for (int s = 0; s < pow[n + 1]; s++) {\n        for (int j = 1; j <= n; j++) {\n            if (need[j] == (need[j] & s)) f[i][s] += std::max(f[i + 1][s], f[i + 1][s | pow[j]] + w[j]);\n            else f[i][s] += f[i + 1][s];\n        }\n        f[i][s] /= n;\n    }\n}\nint main() {\n    scanf(\"%d %d\", &k, &n);\n    for (int i = 1; i <= n + 1; i++) pow[i] = 1 << (i - 1);\n    for (int i = 1; i <= n; i++) {\n        int t;\n        scanf(\"%d %d\", &w[i], &t);\n        while (t) {\n            need[i] += pow[t];\n            scanf(\"%d\", &t);\n        }\n    }\n    dp();\n    printf(\"%.6lf\\n\", f[1][0]);\n    return 0;\n}\n```","tags":["DP","状压DP"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2007] 麻将","url":"/BZOJ-1028-JSOI-2007-麻将/","content":"\n## 题目大意\n\n考虑一种特殊的麻将：没有字牌，只有一种花色，每种牌没有数量限制，数字的范围是 $[1, \\; n]$。现有 $3 m + 1$ 张牌，求所有可能听的牌（加上后使牌有一对将和 $m$ 个顺子或刻子）。\n\n$9 \\leqslant n \\leqslant 400$\n\n$4 \\leqslant m \\leqslant 1,000$\n\n## 题目链接\n\n[【JSOI 2007】麻将 - Luogu 4050](https://www.luogu.com.cn/problem/P4050)\n\n<!-- more -->\n\n## 题解\n\n枚举每一种牌进行判断，再枚举哪种牌做将，最后扫一遍每种牌，如果出现有一种牌消不到 $0$ 个，则失败，否则成功。\n\n暴力枚举题也要做不出来了吗。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 405;\nconst int MAXM = 1005;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static int cnt[MAXN];\n    for (int i = 0; i < 3 * m + 1; i++) {\n        int x;\n        scanf(\"%d\", &x);\n        cnt[x]++;\n    }\n    std::vector<int> ans;\n    for (int i = 1; i <= n; i++) {\n        cnt[i]++;\n        bool success = true;\n        for (int j = 1; j <= n; j++) {\n            if (cnt[j] >= 2) {\n                static int temp[MAXN];\n                std::copy(cnt + 1, cnt + n + 1, temp + 1);\n                temp[j] -= 2;\n                success = true;\n                for (int k = 1; k <= n; k++) {\n                    if (temp[k] == 0) continue;\n                    temp[k] %= 3;\n                    int t = std::min(std::min(temp[k], temp[k + 1]), temp[k + 2]);\n                    if (t < temp[k]) {\n                        success = false;\n                        break;\n                    }\n                    temp[k] -= t, temp[k + 1] -= t, temp[k + 2] -= t;\n                }\n                if (success) break;\n            }\n        }\n        cnt[i]--;\n        if (success) ans.push_back(i);\n    }\n    if (ans.size() == 0) puts(\"NO\");\n    else for (int i = 0; i < ans.size(); i++)\n        printf(\"%d%c\", ans[i], i == ans.size() - 1 ? '\\n' : ' ');\n    return 0;\n}\n```","tags":["枚举"],"categories":["题解（OI/XCPC）"]},{"title":"[AHOI 2009] 最小割","url":"/BZOJ-1797-AHOI-2009-最小割/","content":"\n## 题目大意\n\n给定一个 $n$ 个节点、$m$ 条有向带权边的图以及起点 $s$ 与终点 $t$，对于每条边，询问它是否有可能 $s$ 与 $t$ 之间的最小割的割边，以及它是否会出现在所有最小割的割边中。\n\n$1 \\leqslant n \\leqslant 4,000$\n\n$1 \\leqslant m \\leqslant 60,000$\n\n## 题目链接\n\n[【AHOI 2009】最小割 - Luogu 4126](https://www.luogu.com.cn/problem/P4126)\n\n<!-- more -->\n\n## 题解\n\n先跑一遍最大流，对残量网络跑 Tarjan。如果一条边没有满流，则它不会是最小割的割边；对于满流的边，两端在不同强连通块的是最小割的割边，若有 $u.scc = s.scc$ 并且 $v.scc = t.scc$，则它出现在所有最小割中。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <stack>\n#include <algorithm>\nconst int MAXN = 4005;\nconst int MAXM = 60005;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n    int dfn, low, belong;\n    bool ins;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *rev, *next;\n    int cap, flow;\n    Edge() {}\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n} _pool[MAXM << 1], *_cur = _pool;\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new (_cur++) Edge(&N[u], &N[v], cap);\n    N[v].e = new (_cur++) Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 1; i <= n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 1; i <= n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nnamespace Tarjan {\n    int dfsClock, sccCnt;\n    void dfs(Node *u) {\n        u->dfn = u->low = ++dfsClock;\n        static std::stack<Node *> s;\n        s.push(u);\n        u->ins = true;\n        for (Edge *e = u->e; e; e = e->next) {\n            if (e->cap > e->flow) {\n                if (e->v->dfn == 0) dfs(e->v), u->low = std::min(u->low, e->v->low);\n                else if (e->v->ins) u->low = std::min(u->low, e->v->dfn);\n            }\n        }\n        if (u->dfn == u->low) {\n            Node *curr;\n            sccCnt++;\n            while (true) {\n                curr = s.top();\n                s.pop();\n                curr->ins = false;\n                curr->belong = sccCnt;\n                if (curr == u) break;\n            }\n        }\n    }\n    void findSCC(int n) {\n        dfsClock = sccCnt = 0;\n        for (int i = 1; i <= n; i++) if (N[i].dfn == 0) dfs(&N[i]);\n    }\n}\nint main() {\n    int n, m, s, t;\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        addEdge(u, v, w);\n    }\n    Dinic::solve(s, t, n);\n    Tarjan::findSCC(n);\n    for (int i = 0; i < m << 1; i += 2) {\n        Edge *e = &_pool[i];\n        if (e->cap > e->flow) {\n            puts(\"0 0\");\n            continue;\n        }\n        printf(\"%d \", e->u->belong != e->v->belong ? 1 : 0);\n        printf(\"%d\\n\", e->u->belong == N[s].belong && e->v->belong == N[t].belong ? 1 : 0);\n    }\n    return 0;\n}\n```","tags":["网络流","最小割","Tarjan"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2009] 梦幻布丁","url":"/BZOJ-1483-HNOI-2009-梦幻布丁/","content":"\n## 题目大意\n\n给定一个颜色序列 $\\{c_i\\}$，有 $m$ 次操作，每次操作要么把一种颜色全部改为另一种颜色，要么询问一共有几段颜色。\n\n$1 \\leqslant n, \\; m \\leqslant 100,000$\n\n$1 \\leqslant c_i \\leqslant 1,000,000$\n\n## 题目链接\n\n[【HNOI 2009】梦幻布丁](https://www.luogu.com.cn/problem/P3201)\n\n<!-- more -->\n\n## 题解\n\n链表 + 启发式合并。\n\n为每个颜色开一个链表，每次修改操作即为合并两个链表并更新答案。更新时暴力沿着颜色对应的链表走一遍，看两侧的颜色是不是被修改成的颜色，若是，则答案减 $1$，可是这样最坏要更新 $n$ 个点。\n\n考虑启发式合并，把小的合并到大的上面，每次链表长度至少变长一倍，最多变长 $O(\\log n)$ 次，总复杂度变为了 $O(m \\log n)$。\n\n当要被修改的颜色为更多的一方时，交换要修改成的颜色和要被修改的颜色，同时用一个数组记录一个颜色目前由哪个链表保存。（比如把 $a$ 修改成 $b$，但 $a$ 比 $b$ 多，那处理后 $a$ 的链表来保存颜色$b$的点）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 100005;\nconst int MAXC = 1000005;\nint next[MAXN], a[MAXM];\nint size[MAXC], first[MAXC], last[MAXC], find[MAXC];\nint ans;\nvoid merge(int x, int y) {\n    if (size[x] == 0) return;\n    for (int i = last[x]; i; i = next[i]) {\n        if (a[i - 1] == y) ans--;\n        if (a[i + 1] == y) ans--;\n    }\n    for (int i = last[x]; i; i = next[i]) a[i] = y;\n    next[first[x]] = last[y];\n    last[y] = last[x];\n    size[y] += size[x];\n    size[x] = first[x] = last[x] = 0;\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &a[i]);\n        find[a[i]] = a[i];\n        if (a[i] != a[i - 1]) ans++;\n        if (!first[a[i]]) first[a[i]] = i;\n        next[i] = last[a[i]];\n        last[a[i]] = i;\n        size[a[i]]++;\n    }\n    while (m--) {\n        int op;\n        scanf(\"%d\", &op);\n        if (op == 1) {\n            int x, y;\n            scanf(\"%d %d\", &x, &y);\n            if (x == y) continue;\n            if (size[find[x]] > size[find[y]]) std::swap(find[x], find[y]);\n            x = find[x], y = find[y];\n            merge(x, y);\n        } else printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```","tags":["链表","启发式合并"],"categories":["题解（OI/XCPC）"]},{"title":"[HEOI 2012] 采花","url":"/BZOJ-2743-HEOI-2012-采花/","content":"\n## 题目大意\n\n给定一个颜色序列 $\\{c_i\\}$，给出 $m$ 组询问，每次询问 $[l_i, \\; r_i]$ 内有多少种颜色的数量大于 $1$。\n\n$1 \\leqslant n, \\; c_i, \\; m \\leqslant 1,000,000$\n\n## 题目链接\n\n[【HEOI 2012】采花 - Luogu 4113](https://www.luogu.com.cn/problem/P4113)\n\n<!-- more -->\n\n## 题解\n\n离线询问排序 + 链表 + 树状数组。\n\n为每一个颜色开一个链表，树状数组在每个颜色第二次出现的位置上加 $1$。按起始位置排序询问，从左到右枚举起始位置，每右移一个位置，在树状数组上删去该颜色下一次出现的位置（减 $1$），给再下一次的位置上加 $1$。\n\n用这种方法也可以处理 [HH 的项链](https://www.luogu.com.cn/problem/P1972)一题。（之前是用莫队做的）\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 1000005;\nconst int MAXM = 1000005;\nstruct Query {\n    int l, r, *ans;\n    bool operator<(const Query &another) const {\n        return l < another.l;\n    }\n} q[MAXM];\nstruct BinaryIndexedTree {\n    int c[MAXN], n;\n    static int lowbit(int x) {\n        return x & -x;\n    }\n    void update(int pos, int d) {\n        for (int i = pos; i <= n; i += lowbit(i)) c[i] += d;\n    }\n    int query(int pos) {\n        int res = 0;\n        for (int i = pos; i; i -= lowbit(i)) res += c[i];\n        return res;\n    }\n    int query(int l, int r) {\n        return query(r) - query(l - 1);\n    }\n    void init(int n) {\n        this->n = n;\n    }\n} bit;\nvoid read(int &x) {\n    char ch;\n    while ((ch = getchar()) > '9' || ch < '0');\n    x = ch - '0';\n    while ((ch = getchar()) >= '0' && ch <= '9') x = x * 10 + ch - '0';\n}\nint main() {\n    int n, c, m;\n    scanf(\"%d %d %d\", &n, &c, &m);\n    static int a[MAXN];\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    static int next[MAXN], first[MAXN];\n    for (int i = n; i; i--) next[i] = first[a[i]], first[a[i]] = i;\n    bit.init(n);\n    for (int i = 1; i <= c; i++) if (next[first[i]]) bit.update(next[first[i]], 1);\n    static int ans[MAXM];\n    for (int i = 1; i <= m; i++) {\n        scanf(\"%d %d\", &q[i].l, &q[i].r);\n        q[i].ans = &ans[i];\n    }\n    std::sort(q + 1, q + m + 1);\n    int curr = 1;\n    for (int i = 1; i <= m; i++) {\n        while (curr < q[i].l) {\n            if (next[curr]) bit.update(next[curr], -1);\n            if (next[next[curr]]) bit.update(next[next[curr]], 1);\n            curr++;\n        }\n        *q[i].ans = bit.query(q[i].l, q[i].r);\n    }\n    for (int i = 1; i <= m; i++) printf(\"%d\\n\", ans[i]);\n    return 0;\n}\n```","tags":["链表","树状数组"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2007] 社交网络","url":"/BZOJ-1491-NOI-2007-社交网络/","content":"\n## 题目大意\n\n给定 $n$ 个点、$m$ 条无向带权边的图，定义一个顶点的重要度为：\n$$\nI(u) = \\sum_{s \\neq u \\; \\& \\; t \\neq u} \\frac{C_{s, \\; t}(u)}{C_{s, \\; t}}\n$$\n其中，$C_{s, \\; t}$ 表示 $s$、$t$ 之间的最短路数量，$C_{s, \\; t}(u)$ 表示其中经过 $u$ 的数量。\n\n求每个节点的重要度。\n\n$1 \\leqslant n \\leqslant 100$\n\n$1 \\leqslant w_i \\leqslant 1,000$ （边权）\n\n$1 \\leqslant C_{s, \\; t} \\leqslant 10,000,000,000$\n\n## 题目链接\n\n[【NOI 2007】社交网络](https://www.luogu.com.cn/problem/P2047)\n\n<!-- more -->\n\n## 题解\n\n边 Floyd 边计算经过某个节点的最短路数量。\n\n注意，$dist_{i, \\; i}$ 最好设为大于 $0$ 的数，不然一个节点自已会把答案更新得特别大。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\nconst int MAXN = 105;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static long long cnt[MAXN][MAXN];\n    static int dist[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            cnt[i][j] = 0;\n            dist[i][j] = INT_MAX / 2;\n        }\n        cnt[i][i] = 1;\n        dist[i][i] = 1;\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        dist[v][u] = dist[u][v] = w;\n        cnt[v][u] = cnt[u][v] = 1;\n    }\n    for (int k = 1; k <= n; k++) for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++) {\n        if (dist[i][k] + dist[k][j] < dist[i][j]) {\n            dist[i][j] = dist[i][k] + dist[k][j];\n            cnt[i][j] = cnt[i][k] * cnt[k][j];\n        } else if (dist[i][k] + dist[k][j] == dist[i][j]) \n            cnt[i][j] += cnt[i][k] * cnt[k][j];\n    }\n    for (int k = 1; k <= n; k++) {\n        double ans = 0;\n        for (int i = 1; i <= n; i++) for (int j = 1; j <= n; j++)\n            if (dist[i][k] + dist[k][j] == dist[i][j]) \n                ans += (double) cnt[i][k] * cnt[k][j] / cnt[i][j];\n        printf(\"%.3lf\\n\", ans);\n    }\n    return 0;\n}\n```","tags":["Floyd"],"categories":["题解（OI/XCPC）"]},{"title":"[SPOJ 10628] Count on a tree","url":"/BZOJ-2588-SPOJ-10628-Count-on-a-tree/","content":"\n## 题目大意\n\n给定一棵 $n$ 个节点的树，每个点有一个权值，对于 $m$ 个询问 $(u, \\; v, \\; k)$，你需要回答 $u \\; xor \\; lastans$ 和 $v$ 这两个节点间第 $k$ 小的点权。其中 $lastans$ 是上一个询问的答案，初始为 $0$。\n\n$1\\leqslant n, \\; m \\leqslant 100,000$\n\n## 题目链接\n\n[Count on a tree - Luogu 2633](https://www.luogu.com.cn/problem/P2633)\n\n[SPOJ 10628 - COT](http://www.spoj.com/problems/COT/)\n\n<!-- more -->\n\n## 题解\n\n主席树。对于每一个询问，求出 $p = lca(u, \\; v)$，然后在线段树 $u + v - p - p.fa$ 上二分即可。\n\n求 lca 用倍增。\n\n## 代码\n\n有烦人的 PE。。。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 100005;\nconst int MAXLOGN = 17;\nstruct PSegT *null;\nstruct PSegT {\n    PSegT *lc, *rc;\n    int cnt;\n    PSegT(PSegT *lc, PSegT *rc) : lc(lc), rc(rc), cnt(lc->cnt + rc->cnt) {}\n    PSegT(PSegT *lc, PSegT *rc, int cnt) : lc(lc), rc(rc), cnt(cnt) {}\n    PSegT *insert(int l, int r, int x) {\n        if (l == r) return new PSegT(null, null, cnt + 1);\n        else {\n            int mid = l + (r - l) / 2;\n            if (x <= mid) return new PSegT(lc->insert(l, mid, x), rc);\n            else return new PSegT(lc, rc->insert(mid + 1, r, x));\n        }\n    }\n};\nstruct Node {\n    std::vector<Node *> adj;\n    Node *fa;\n    int dep, w;\n    bool vis;\n    PSegT *seg;\n} N[MAXN];\nvoid addEdge(int u, int v) {\n    N[u].adj.push_back(&N[v]);\n    N[v].adj.push_back(&N[u]);\n}\nvoid init() {\n    null = new PSegT(NULL, NULL, 0);\n    null->lc = null->rc = null;\n}\nint n, f[MAXN][MAXLOGN], logn;\nvoid build() {\n    N[0].vis = true;\n    N[0].seg = null;\n    std::queue<Node *> q;\n    q.push(&N[1]);\n    N[1].vis = true;\n    N[1].dep = 1;\n    N[1].fa = &N[0];\n    while (!q.empty()) {\n        Node *u = q.front();\n        q.pop();\n        u->seg = u->fa->seg->insert(0, INT_MAX, u->w);\n        for (Node **p = &u->adj.front(), *v = *p; p <= &u->adj.back(); v = *++p) {\n            if (!v->vis) {\n                v->vis = true;\n                v->dep = u->dep + 1;\n                v->fa = u;\n                q.push(v);\n            }\n        }\n    }\n    while ((1 << (logn + 1)) <= n) logn++;\n    f[1][0] = 1;\n    for (int i = 2; i <= n; i++) f[i][0] = N[i].fa - N;\n    for (int j = 1; j <= logn; j++) {\n        for (int i = 1; i <= n; i++) {\n            f[i][j] = f[f[i][j - 1]][j - 1];\n        }\n    }\n}\nint lca(int u, int v) {\n    if (N[u].dep < N[v].dep) std::swap(u, v);\n    if (N[u].dep > N[v].dep) {\n        for (int i = logn; i >= 0; i--) {\n            if (N[f[u][i]].dep >= N[v].dep) u = f[u][i];\n        }\n    }\n    if (u != v) {\n        for (int i = logn; i >= 0; i--) {\n            if (f[u][i] != f[v][i]) {\n                u = f[u][i];\n                v = f[v][i];\n            }\n        }\n        return f[u][0];\n    }\n    return u;\n}\nint query(int u, int v, int k) {\n    int p = lca(u, v);\n    PSegT *su = N[u].seg, *sv = N[v].seg, *sp = N[p].seg, *sf = N[p].fa->seg;\n    int l = 0, r = INT_MAX;\n    while (l < r) {\n        int mid = l + (r - l) / 2;\n        int s = su->lc->cnt + sv->lc->cnt - sp->lc->cnt - sf->lc->cnt;\n        if (k > s) {\n            k -= s;\n            l = mid + 1;\n            su = su->rc;\n            sv = sv->rc;\n            sp = sp->rc;\n            sf = sf->rc;\n        } else {\n            r = mid;\n            su = su->lc;\n            sv = sv->lc;\n            sp = sp->lc;\n            sf = sf->lc;\n        }\n    }\n    return l;\n}\nint main() {\n    int m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &N[i].w);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    init();\n    build();\n    int lastAns = 0;\n    while (m--) {\n        int u, v, k;\n        scanf(\"%d %d %d\", &u, &v, &k);\n        u ^= lastAns;\n        printf(m ? \"%d\\n\" : \"%d\", lastAns = query(u, v, k));\n    }\n    return 0;\n}\n```","tags":["主席树","LCA"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2006] 公路修建问题","url":"/BZOJ-1196-HNOI-2006-公路修建问题/","content":"\n## 题目大意\n\n给定一个 $n$ 个定点、$m$ 条边的图，每条边有 $w1$、$w2$ 两个权值（可视作是两条边），求至少有 $k$ 条边选择第一权值的生成树中，最大边权的最小值。\n\n$1 \\leqslant n \\leqslant 10,000$\n\n$1 \\leqslant m \\leqslant 20,000$\n\n## 题目链接\n\n[【HNOI 2006】公路修建问题 - Luogu 2323](https://www.luogu.com.cn/problem/P2323)\n\n<!-- more -->\n\n## 题解\n\n用类似 Kruskal 的方法，先选出 $k$ 条第一权值的边，再求最小生成树。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 10005;\nconst int MAXM = 20005;\nstruct Edge {\n    int u, v, w, type;\n    Edge() {}\n    Edge(int u, int v, int w, int type) : u(u), v(v), w(w), type(type) {}\n    bool operator<(const Edge &another) const {\n        return w < another.w;\n    }\n} E[MAXM << 1];\nstruct UnionFindSet {\n    int fa[MAXN];\n    int find(int x) {\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    }\n    void merge(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return;\n        fa[q] = p;\n    }\n    void init(int n) {\n        for (int i = 1; i <= n; i++) fa[i] = i;\n    }\n} ufs;\nint main() {\n    int n, k, m;\n    scanf(\"%d %d %d\", &n, &k, &m);\n    m--;\n    int cnt = 0;\n    for (int i = 0; i < m; i++) {\n        int u, v, w1, w2;\n        scanf(\"%d %d %d %d\", &u, &v, &w1, &w2);\n        E[cnt++] = Edge(u, v, w1, 1);\n        E[cnt++] = Edge(u, v, w2, 2);\n    }\n    m = cnt;\n    std::sort(E, E + m);\n    int ans = 0;\n    ufs.init(n);\n    for (int i = 0; i < m; i++) {\n        if (E[i].type == 1 && ufs.find(E[i].u) != ufs.find(E[i].v)) {\n            ufs.merge(E[i].u, E[i].v);\n            ans = std::max(ans, E[i].w);\n            n--;\n            if (!--k) break;\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        if (ufs.find(E[i].u) != ufs.find(E[i].v)) {\n            ufs.merge(E[i].u, E[i].v);\n            ans = std::max(ans, E[i].w);\n            if (--n == 1) break;\n        }\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["图","最小生成树"],"categories":["题解（OI/XCPC）"]},{"title":"完全平方数","url":"/BZOJ-2440-完全平方数/","content":"\n## 题目大意\n\n求从 $1$ 开始第 $k$ 个不是完全平方数的整倍数的数，多组询问。\n\n$1 \\leqslant k \\leqslant 1,000,000,000$\n\n$1 \\leqslant T \\leqslant 50$\n\n## 题目链接\n\n[完全平方数 - Luogu 4318](https://www.luogu.com.cn/problem/P4318)\n\n## 题解\n\n可以用容斥原理计算出小于等于 $n$ 的数中有多少个是完全平方数的整倍数，即加上 $\\frac{n}4$、$\\frac{n}9$、$\\frac{n}{25}$ 等质数的平方，再减去 $\\frac{n}{16}$、$\\frac{n}{36}$ 等有两个质因数的数的平方……我们发现，它们的系数就是对应数的莫比乌斯函数的定义（的相反数），因此可以直接算出小于等于 $n$ 的数中有多少个满足要求：\n$$\n\\sum_{i = 1}^{\\lfloor \\sqrt{n} \\rfloor} \\mu(i) * \\frac{n}{i^2}\n$$\n线性筛预处理出莫比乌斯函数即可。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 100005;\nint prime[MAXN], mu[MAXN], primeCnt;\nbool notPrime[MAXN];\nvoid linearShaker() {\n    notPrime[0] = notPrime[1] = true;\n    mu[1] = 1;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            mu[i] = -1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                mu[i * prime[j]] = 0;\n                break;\n            } else {\n                mu[i * prime[j]] = -mu[i];\n            }\n        }\n    }\n}\nlong long check(long long x) {\n    long long res = 0;\n    for (long long i = 1; i * i <= x; i++) res += mu[i] * x / i / i;\n    return res;\n}\nlong long dichotomy(int k) {\n    long long l = 1, r = (long long) MAXN * MAXN;\n    while (l < r) {\n        long long mid = l + (r - l) / 2;\n        if (check(mid) >= k) r = mid;\n        else l = mid + 1;\n    }\n    return l;\n}\nint main() {\n    linearShaker();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int k;\n        scanf(\"%d\", &k);\n        printf(\"%lld\\n\", dichotomy(k));\n    }\n    return 0;\n}\n```","tags":["数论","线性筛","莫比乌斯函数"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2011] 数学作业","url":"/BZOJ-2326-HNOI-2011-数学作业/","content":"\n## 题目大意\n\n求将从 $1$ 到 $n$ 的正整数顺序连接起来得到的数模 $m$ 的值。\n\n$1 \\leqslant n \\leqslant 10^{18}$\n\n$1 \\leqslant m \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【HNOI 2011】数学作业 - Luogu 3216](https://www.luogu.com.cn/problem/P3216)\n\n<!-- more -->\n\n## 题解\n\n按位数分开算，记 $f[n]$ 为答案，有（$k$ 为位数）：\n$$\nf[i] = (f[i - 1] \\times 10^k + i) \\bmod \\; m\n$$\n每一段（位数相同）用矩阵乘法计算。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n// #define DBG\nstruct Matrix {\n    long long a[3][3];\n    Matrix(bool unit) {\n        memset(a, 0, sizeof (a));\n        if (unit) for (int i = 0; i < 3; i++) a[i][i] = 1;\n    }\n    long long &operator()(int i, int j) {\n        return a[i][j];\n    }\n    const long long &operator()(int i, int j) const {\n        return a[i][j];\n    }\n#ifdef DBG\n    void print() const {\n        puts(\"Matrix is :\");\n        for (int i = 0; i < 3; i++) {\n            printf(\"( \");\n            for (int j = 0; j < 3; j++) printf(\"%lld \", a[i][j]);\n            printf(\")\\n\");\n        }\n    }\n#endif  \n} trans(false), f(false);\nlong long n, m;\nlong long mul(long long a, long long b) {\n    long long res = 0;\n    for (; b; b >>= 1, a = (a + a) % m) if (b & 1) res = (res + a) % m;\n    return res;\n}\nMatrix operator*(const Matrix &a, const Matrix &b) {\n#ifdef DBG\n    puts(\"Matrix multiply:\");\n    a.print();\n    b.print();\n#endif  \n    Matrix res(false);\n    for (int i = 0; i < 3; i++) for (int j = 0; j < 3; j++) for (int k = 0; k < 3; k++) (res(i, j) += mul(a(i, k), b(k, j))) %= m;\n#ifdef DBG\n    res.print();\n#endif  \n    return res;\n}\nMatrix pow(Matrix a, long long n) {\n#ifdef DBG\n    printf(\"pow(trans, %lld)\\n\", n);\n#endif  \n    Matrix res(true);\n    for (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n    return res;\n}\nvoid initMatrix() {\n    f(2, 0) = 1;\n    trans(0, 1) = trans(0, 2) = trans(1, 1) = trans(1, 2) = trans(2, 2) = 1;\n}\nvoid calc(long long k, long long last) {\n    trans(0, 0) = k % m;\n#ifdef DBG\n    printf(\"calc(%lld, %lld)\\n\", k, last);\n    trans.print();\n    f.print();\n#endif  \n    long long n = last - k / 10 + 1;\n    f = pow(trans, n) * f;\n}\nint main() {\n    scanf(\"%lld %lld\", &n, &m);\n    initMatrix();\n    long long k = 10;\n    while (n >= k) {\n#ifdef DBG\n        printf(\"k = %lld\\n\", k);\n#endif      \n        calc(k, k - 1);\n        k *= 10;\n    }\n    calc(k, n);\n    printf(\"%lld\\n\", f(0, 0));\n    return 0;\n}\n```","tags":["矩阵乘法"],"categories":["题解（OI/XCPC）"]},{"title":"后缀数组整理笔记","url":"/后缀数组整理笔记/","content":"\n后缀数组这种东西，还是不要背代码的好。。。\n\n## 一些定义\n\n* $s[0 \\dots n - 1]$：一个长为 $n$ 的字符串，编号从 $0$ 开始。\n* $suffix[i]$：后缀 $i$ ——以第 $i$ 个字符开始的后缀，即 $s[i \\dots n - 1]$。\n* $sa[i]$：后缀数组，表示排名（从 $0$ 开始）为 $i$ 的后缀。\n* $rank[i]$：名次数组，表示后缀 $i$ 的排名，有 $rank[sa[i]] = i$。\n* $height[i]$：高度数组，表示排名相连的两个后缀的 lcp（最长公前缀），即 $lcp(suffix[sa[i]], \\; suffix[sa[i - 1]])$，故有意义的取值从下表 $1$ 开始。\n\n<!-- more -->\n\n## 倍增算法构造后缀数组\n\n一般我们会在字符串的最后添加一个不在字符集中的更小的字符，使得排名$0$的后缀一定为它，在防止过程中的各种越界中有用。\n\n关于这一块，强烈安利 [Menci 的博客](https://oi.men.ci/suffix-array-notes/)，讲的很易于理解，另外 [Sengxian 的博客](https://blog.sengxian.com/algorithms/suffix-array)在实现细节上与Menci有一定不同，个人觉得 Sengxian 的实现更为方便，也不是很难理解。\n\n倍增算法采用双关键字排序后缀。\n\n对于一次排序，要求出长为 $2^{k + 1}$ 的字符串的的排名，第一关键字为每个字符开始的长为 $2^k$ 的字串的排名，第二关键字为每个位置 $i' = i + 2^k$ 开始的字串的排名，过程中越界的部分直接当作更小的字符。当每个排名都不同时结束算法。排序的实现一般为基数排序。\n\n```c++\nfor (int i = 0; i < n; i++)\n    fir[i] = rank[i], sec[i] = i + l < n ? rank[i + l] : 0;\n```\n\n排序部分。\n\n对于第二关键字的排序，用一个辅助数组 $temp[i]$ 存储相关信息，使得字典序越小的字符串越在前，实现时倒序遍历，为第二关键字更大的分配到更后的排名，第二关键字相同的靠前的后缀分配到了更小的排名（`cnt[i]`数组的数是由大变小的），辅助数组即表示第二关键字排序后，第 $i$ 小的是哪一个。\n\n```c++\nfor (i = n - 1; ~i; i--) temp[--cnt[sec[i]]] = i;\n```\n\n再以辅助数组的顺序，采用同样的方法排序第一关键字， 第一关键字更大的分配到更后的排名，**由于 `cnt[i]` 数组的数是由大变小的，第一关键字相同的，第二关键字更大的分配到了更大的排名**，得到当前的 $sa$ 数组。\n\n```c++\nfor (i = n - 1; ~i; i--) sa[--cnt[fir[temp[i]]]] = temp[i];\n```\n\n## 计算 $height[i]$ 数组\n\n$O(n)$ 计算 $height[i]$ 数组基于这么一个事实：\n\n> 记 $h[i] = height[rank[i]]$，有 $h[i] \\geqslant h[i - 1]  -1$\n\n证明：\n\n设 $suffix[i - 1]$ 在后缀数组中的前一个是 $suffix[k] = suffix[sa[rank[i - 1] - 1]]$，那么它们的 lcp 即为 $h[i - 1]$。考虑去掉它们的第一个字符，将得到 $suffix[i]$ 和 $suffix[k + 1]$，它们的 lcp 为 $h[i - 1] - 1$，记 $suffix[i]$ 在后缀数组中的前一个是 $suffix[p] = suffix[sa[rank[i] - 1]]$，那么显然有 $suffix[k + 1] \\geqslant suffix[p] > suffix[i]$，而显然 $lcp(suffix[k + 1], \\; suffix[i]) \\leqslant lcp(suffix[p], \\; suffix[i])$。证毕。（「显然」的地方意会一下就好。。。）\n\n```c++\nvoid getHeight() {\n    int k = 0;\n    for (int i = 0; i < n - 1; i++) {\n        k ? k-- : 0;\n        int j = sa[rank[i] - 1];\n        while (str[i + k] == str[j + k]) k++;\n        height[rank[i]] = k;\n    }\n}\n```\n\n## 模版题与代码\n\n模版题就是 UOJ 上的[UOJ 35](http://uoj.ac/problem/35).\n\n**注意**：$height[0]$ 无意义，$sa[0]$ 与 $height[1]$ 均是我们在字符串末尾添的字符。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <stack>\nconst int MAXN = 500005;\nnamespace SuffixArray {\n    int rank[MAXN], sa[MAXN], height[MAXN], n;\n    char str[MAXN];\n    void buildSA(int m) {\n        static int fir[MAXN], sec[MAXN], temp[MAXN], cnt[MAXN], i;\n        n = strlen(str) + 1;\n        str[n - 1] = 0;\n        memset(cnt, 0, sizeof cnt);\n        for (i = 0; i < n; i++) cnt[(int) str[i]]++;\n        for (i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n        for (i = 0; i < n; i++) rank[i] = cnt[(int) str[i]] - 1;\n        for (int l = 1; l < n; l <<= 1) {\n            for (int i = 0; i < n; i++)\n                fir[i] = rank[i], sec[i] = i + l < n ? rank[i + l] : 0;\n            memset(cnt, 0, sizeof cnt);\n            for (i = 0; i < n; i++) cnt[sec[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) temp[--cnt[sec[i]]] = i;\n            memset(cnt, 0, sizeof cnt);\n            for (i = 0; i < n; i++) cnt[fir[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) sa[--cnt[fir[temp[i]]]] = temp[i];\n            bool unique = true;\n            rank[sa[0]] = 0;\n            for (i = 1; i < n; i++) {\n                rank[sa[i]] = rank[sa[i - 1]];\n                if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) \n                    unique = false;\n                else rank[sa[i]]++;\n            }\n            if (unique) break;\n        }\n    }\n    void getHeight() {\n        int k = 0;\n        for (int i = 0; i < n - 1; i++) {\n            k ? k-- : 0;\n            int j = sa[rank[i] - 1];\n            while (str[i + k] == str[j + k]) k++;\n            height[rank[i]] = k;\n        }\n    }\n}\nint main() {\n    char *str = SuffixArray::str;\n    scanf(\"%s\", str);\n    int n = strlen(str);\n    SuffixArray::buildSA(128);\n    SuffixArray::getHeight();\n    int *height = SuffixArray::height + 1, *sa = SuffixArray::sa;\n    for (int i = 1; i <= n; i++) printf(\"%d%c\", sa[i], i == n ? '\\n' : ' ');\n    for (int i = 1; i < n; i++) printf(\"%d%c\", height[i], i == n - 1 ? '\\n' : ' ');\n    return 0;\n}\n```","tags":["学习笔记","字符串","模版","后缀数组"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[SHOI 2007] 善意的投票","url":"/BZOJ-1934-SHOI-2007-善意的投票Vote/","content":"\n## 题目大意\n\n有 $n$ 个小朋友打算投票，同时有 $m$ 对好朋友，每个小朋友有一个一开始的投票意愿。定义冲突数为好朋友之间投票不同的对数加上投票与自己意愿不同的个数。求最小冲突数。\n\n$2 \\leqslant n \\leqslant 300$\n\n## 题目链接\n\n[【SHOI2007】善意的投票 / 【JLOI2010】冠军调查 - Luogu 2057](https://www.luogu.com.cn/problem/P2057)\n\n<!-- more -->\n\n## 题解\n\n建最小割跑最大流即为答案。\n\n从源点向意愿赞同／反对的小朋友连一条容量为 $1$ 的边，从意愿反对／赞同的小朋友向汇点连一条容量为 $1$ 的边，以上两组边若被割断，则表示投票与意愿相反；每对朋友互连一条容量为 $1$ 的边，割断表示朋友间投票不同，但实际有用的边只有从赞同／反对的人连向反对／赞同的边。\n\n像 `Dinic` 这样的类似工具类的东西，还是写成 `namespace` 比较合适。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 305;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap = 1) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nnamespace Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int solve(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static int vote[MAXN];\n    const int s = 0, t = n + 1;\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &vote[i]);\n        if (vote[i] == 1) addEdge(s, i);\n        else addEdge(i, t);\n    }\n    for (int i = 0; i < m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        if (vote[u] == 1 && vote[v] == 0) addEdge(u, v);\n        if (vote[v] == 1 && vote[u] == 0) addEdge(v, u);\n    }\n    printf(\"%d\\n\", Dinic::solve(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割"],"categories":["题解（OI/XCPC）"]},{"title":"GCD","url":"/BZOJ-2818-Gcd/","content":"\n## 题目大意\n\n给定整数 $n$，求 $1 \\leqslant x, \\; y \\leqslant n$ 且 $gcd(x, \\; y)$ 为质数的数对 $(x, \\; y)$ 有多少对。\n\n$1 \\leqslant n \\leqslant 10,000,000$\n\n## 题目链接\n\n[GCD - Luogu 2568](https://www.luogu.com.cn/problem/P2568)\n\n<!-- more -->\n\n## 题解\n\n这题应该叫做「为什么我讨厌 gcd」。\n\n在之前的两道题（[【HAOI 2011】problem b](http://pepcy.cf/BZOJ-2301-HAOI-2011-Problem-b/) 和 [【NOI 2010】能量采集](http://pepcy.cf/BZOJ-2005-NOI-2010-能量采集/)）中，我们推出了两个式子。然而，这里我们一个都不用。。。\n\n考虑枚举每个质数，贡献即为\n$$\n\\sum_{1 \\leqslant i, \\; j \\leqslant \\lfloor \\frac{n}p \\rfloor} [gcd(i, \\; j) = 1]\n$$\n考虑范围内每个数，小于它且与它互质的数的个数正好是 $\\varphi$ 函数的定义，由于数对有序，且两数相等并互质的数对只有一个 $(1, \\; 1)$，故上式等于\n$$\n2 \\times \\sum_{1 \\leqslant i \\leqslant \\lfloor \\frac{n}p \\rfloor} \\varphi(i) - 1\n$$\n（这个式子本身应该是只当两数范围均为 $[1, \\; n]$ 时才成立；以及这应该不算莫比乌斯反演了吧。。。）\n\n预处理 $\\varphi$ 及其前缀和，枚举每个质数即可。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 10000005;\nint prime[MAXN], primeCnt;\nlong long phi[MAXN];\nbool notPrime[MAXN];\nvoid linearShaker() {\n    phi[1] = 1;\n    notPrime[0] = notPrime[1] = true;\n    for (int i = 2; i < MAXN; i++) {\n        if (!notPrime[i]) {\n            prime[++primeCnt] = i;\n            phi[i] = i - 1;\n        }\n        for (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n            notPrime[i * prime[j]] = true;\n            if (i % prime[j] == 0) {\n                phi[i * prime[j]] = phi[i] * prime[j];\n                break;\n            } else phi[i * prime[j]] = phi[i] * (prime[j] - 1);\n        }\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    linearShaker();\n    for (int i = 2; i <= n; i++) phi[i] += phi[i - 1];\n    long long ans = 0;\n    for (int i = 1; i <= primeCnt && prime[i] <= n; i++) ans += 2 * phi[n / prime[i]] - 1;\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["线性筛"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2012] 永无乡","url":"/BZOJ-2733-HNOI-2012-永无乡/","content":"\n## 题目大意\n\n有 $n$ 座岛屿，给出每座岛屿的重要度排名（不会并列），同时有 $m$ 条边连接这些岛屿。现有 $q$ 次操作，操作有两种：\n\n* `B x y`：在岛屿 $x$ 与 $y$ 之间连一条边。\n* `Q x k`：查询与岛屿 $x$ 连通的所有岛屿中，重要度第 $k$ 大（排名第 $k$ 小）的岛屿。\n\n$1 \\leqslant n, \\; m \\leqslant 100,000$\n\n$1 \\leqslant q \\leqslant 300,000$\n\n## 题目链接\n\n[【HNOI 2012】永无乡 - Luogu 3224](https://www.luogu.com.cn/problem/P3224)\n\n<!-- more-->\n\n## 题解\n\n并查集维护连通性，权值线段树维护区间信息。\n\n连接两个点时，并查集合并对应的点，两个线段树也合并。查询时在对应线段树中查询。\n\n想着这么多棵线段树，于是用了动态开点。。。\n\n另外这个线段树合并并不算是完全的线段树合并，因为同一个权值不会有第二个。。。所以不太能作线段树合并的版子。。。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 100005;\nstruct SegT {\n    struct Node {\n        Node *lc, *rc;\n        int l, r, cnt, sum;\n        Node(int l, int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt(0), sum(0) {}\n        void maintain() {\n            sum = (lc ? lc->sum : 0) + (rc ? rc->sum : 0);\n        }\n        void pushDown() {\n            if (lc && rc) return;\n            int mid = l + (r - l) / 2;\n            if (!lc) lc = new Node(l, mid);\n            if (!rc) rc = new Node(mid + 1, r);\n        }\n        void insert(int val) {\n            if (l == r) {\n                cnt = sum = 1;\n                return;\n            }\n            pushDown();\n            int mid = l + (r - l) / 2;\n            if (val <= mid) lc->insert(val);\n            else rc->insert(val);\n            maintain();\n        }\n    } *root;\n    SegT() : root(NULL) {}\n    int query(int k) {\n        Node *u = root;\n        if (u->sum < k) return -1;\n        while (u->l != u->r) {\n            u->pushDown();\n            if (u->lc->sum >= k) u = u->lc;\n            else k -= u->lc->sum, u = u->rc;\n        }\n        return u->l;\n    }\n    void insert(int val) {\n        root->insert(val);\n    }\n    void init(int l, int r) {\n        root = new Node(l, r);\n    }\n} segT[MAXN];\nSegT::Node *merge(SegT::Node *a, SegT::Node *b) {\n    if (!a->sum) return b;\n    if (!b->sum) return a;\n    a->lc = merge(a->lc, b->lc);\n    a->rc = merge(a->rc, b->rc);\n    a->maintain();\n    return a;\n}\nstruct UnionFindSet {\n    int fa[MAXN];\n    int find(int x) {\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    }\n    void merge(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return;\n        fa[q] = p;\n    }\n    void init(int n) {\n        for (int i = 1; i <= n; i++) fa[i] = i;\n    }\n} ufs;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static int w[MAXN], id[MAXN];\n    for (int i = 1; i <= n; i++) {\n        scanf(\"%d\", &w[i]);\n        id[w[i]] = i;\n    }\n    ufs.init(n);\n    while (m--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        ufs.merge(u, v);\n    }\n    for (int i = 1; i <= n; i++) segT[i].init(1, n);\n    for (int i = 1; i <= n; i++) segT[ufs.find(i)].insert(w[i]);\n    int q;\n    scanf(\"%d\", &q);\n    while (q--) {\n        char op[2];\n        int x, y;\n        scanf(\"%s %d %d\", op, &x, &y);\n        if (op[0] == 'Q') {\n            int temp = segT[ufs.find(x)].query(y);\n            printf(\"%d\\n\", temp == -1 ? temp : id[temp]);\n        }\n        else {\n            int p = ufs.find(x), q = ufs.find(y);\n            if (p != q) {\n                ufs.fa[q] = p;\n                segT[p].root = merge(segT[p].root, segT[q].root);\n            }\n        }\n    }\n    return 0;\n}\n```","tags":["并查集","线段树","线段树合并"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2009] 狼和羊的故事","url":"/BZOJ-1412-ZJOI-2009-狼和羊的故事/","content":"\n## 题目大意\n\n有一个 $n \\times m$ 的网格，每一个格子上是羊、狼、空地中的一种，羊和狼可以走上空地。现要在格子边上建立围栏，求把狼羊分离的最少围栏数。\n\n$1 \\leqslant n, \\; m \\leqslant 100$\n\n## 题目链接\n\n[【ZJOI 2009】狼和羊的故事 - Luogu 2598](https://www.luogu.com.cn/problem/P2598)\n\n<!-- more -->\n\n## 题解\n\n最小割。\n\n从源点向羊／狼连一条容量无限的边，从狼／羊向汇点连一条容量无限的边。考虑相邻的两格，若是一狼一羊，则连一条容量为 $1$ 的边（分割狼羊），若至少有一方为空地，也连一条容量为 $1$ 的边（狼羊会走上空地）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 105;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nstruct Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int operator()(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n} dinic;\nint n, m;\nint getID(int x, int y) {\n    return (x - 1) * m + y;\n}\nbool valid(int x, int y) {\n    return (x > 0) && (y > 0) && (x <= n) && (y <= m);\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    const int s = 0, t = n * m + 1;\n    static int mat[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        scanf(\"%d\", &mat[i][j]);\n        if (mat[i][j] == 2) addEdge(s, getID(i, j), INT_MAX);\n        if (mat[i][j] == 1) addEdge(getID(i, j), t, INT_MAX);\n    }\n    static int d[4][2] = {\n        {0, 1},\n        {0, -1},\n        {1, 0},\n        {-1, 0}\n    };\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        for (int k = 0; k < 4; k++) {\n            int x = i + d[k][0], y = j + d[k][1];\n            if (!valid(x, y)) continue;\n            if (mat[i][j] != mat[x][y] || (mat[i][j] == mat[x][y] && mat[x][y] == 0))\n                addEdge(getID(i, j), getID(x, y), 1);\n        }\n    }\n    printf(\"%d\\n\", dinic(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2006] 旅行","url":"/BZOJ-1050-HAOI-2006-旅行comf/","content":"\n## 题目大意\n\n给定一个 $n$ 个节点、$m$ 条边的无向图，每条边有一个权值 $w_i$。给你两个顶点 $s$ 和 $t$ ，求一条路径，使得路径上最大边和最小边的比值最小。如果 $s$ 和 $t$ 之间没有路径，输出 `IMPOSSIBLE`；否则输出这个比值，如果答案不为整数，表示成一个约分到最简的分数。\n\n$1 \\leqslant n \\leqslant 500$\n\n$1 \\leqslant m \\leqslant 5,000$\n\n$1 \\leqslant w_i < 30,000$\n\n## 题目链接\n\n[【HAOI 2006】旅行 - Luogu 2502](https://www.luogu.com.cn/problem/P2502)\n\n<!-- more -->\n\n## 题解\n\n对边进行排序，用类似 Kruscal 的方法，依次加入每条边，直至 $s$ 与 $t$ 连通，更新答案，枚举从哪条边开始添边即可。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\nconst int MAXN = 505;\nconst int MAXM = 5005;\nstruct Edge {\n    int u, v, w;\n    bool operator<(const Edge &another) const {\n        return w < another.w;\n    }\n} E[MAXM];\nstruct UnionFindSet {\n    int fa[MAXN], n;\n    int find(int x) {\n        return x == fa[x] ? x : fa[x] = find(fa[x]);\n    }\n    void merge(int x, int y) {\n        int p = find(x), q = find(y);\n        if (p == q) return;\n        fa[q] = p;\n    }\n    void init(int n) {\n        this->n = n;\n        for (int i = 1; i <= n; i++) fa[i] = i;\n    }\n} ufs;\nint gcd(int a, int b) {\n    return b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < m; i++) scanf(\"%d %d %d\", &E[i].u, &E[i].v, &E[i].w);\n    std::sort(E, E + m);\n    int s, t;\n    scanf(\"%d %d\", &s, &t);\n    double ans = DBL_MAX;\n    int ansMax, ansMin;\n    for (int i = 0; i < m; i++) {\n        ufs.init(n);\n        int min = E[i].w, max;\n        for (int j = i; j < m; j++) {\n            max = E[j].w;\n            ufs.merge(E[j].u, E[j].v);\n            if (ufs.find(s) == ufs.find(t)) {\n                if ((double) max / min < ans) {\n                    ans = (double) max / min;\n                    ansMax = max;\n                    ansMin = min;\n                }\n                break;\n            }\n        }\n    }\n    if (ans == DBL_MAX) puts(\"IMPOSSIBLE\");\n    else if ((ansMax / ansMin) * ansMin == ansMax) printf(\"%.0lf\\n\", ans);\n    else {\n        int g = gcd(ansMax, ansMin);\n        printf(\"%d/%d\\n\", ansMax / g, ansMin / g);\n    }\n    return 0;\n}\n```","tags":["枚举","并查集"],"categories":["题解（OI/XCPC）"]},{"title":"[APIO 2012] 派遣","url":"/BZOJ-2809-APIO-2012-派遣dispatching/","content":"\n## 题目大意\n\n有 $n$ 名忍者，每名忍者有一个上级（当然，最上级的那位没有），同时每名忍者有薪水 $s_i$、领导力 $l_i$，现选定一批忍者，这些忍者均是某一个忍者（作为管理者）的下级（管理者可以不选），将获得满意度：管理者领导力$\\times$所选忍者个数。求在薪水预算 $m$ 范围内的最大满意度。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant m \\leqslant 1,000,000,000$\n\n$1 \\leqslant l_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【APIO 2012】派遣 - Luogu 1552](https://www.luogu.com.cn/problem/P1552)\n\n<!-- more -->\n\n## 题解\n\ndfs 序 $+$ 主席树。\n\n一个节点为根的子树在 dfs 序上是连续的。对于每一个节点，考虑其子树的区间，要使满意度更大，应该从薪水少的开始选，直到薪水和会超过预算，该操作可以用主席树做到 $O(\\log n)$。\n\n对于数据的处理要特别提一下：离散化时，相同的数应化为不同的数。（一开始没有意识到，各种 WA，于是在 COGS 上提了第一道题，找到了一份小的数据才发现问题的。。。不过要在「题目链接」中添加 COGS 的话，就要改所有的博文了。。。）\n\n本题标算好像是左偏树，然而我不会。。。可是主席树常数好大。。。\n\nVW：复杂度能和标算同阶就好啦\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    Node *fa;\n    int dfn, rDfn, w;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\nstruct Ninja {\n    int s, l, id;\n    bool operator<(const Ninja &another) const {\n        return s < another.s;\n    }\n} a[MAXN];\nbool cmp(const Ninja &a, const Ninja &b) {\n    return a.id < b.id;\n}\nint map[MAXN], n;\nvoid discretization() {\n    std::sort(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) map[i] = a[i].s, a[i].s = i;\n    std::sort(a + 1, a + n + 1, cmp);\n}\nstruct PSegT {\n    struct Node {\n        Node *lc, *rc;\n        int l, r, cnt;\n        long long sum;\n        Node(int l, int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)), sum((lc ? lc->sum : 0) + (rc ? rc->sum : 0)) {}\n        Node(int l, int r, int cnt) : l(l), r(r), cnt(cnt), sum(cnt * (long long) map[l]), lc(NULL), rc(NULL) {}\n        void pushDown() {\n            if (lc && rc) return;\n            int mid = l + (r - l) / 2;\n            if (!lc) lc = new Node(l, mid);\n            if (!rc) rc = new Node(mid + 1, r);\n        }\n        Node *insert(int num) {\n            if (num < l || num > r) return this;\n            if (num == l && num == r) return new Node(l, r, this->cnt + 1);\n            int mid = l + (r - l) / 2;\n            pushDown();\n            if (num <= mid) return new Node(l, r, lc->insert(num), rc);\n            else return new Node(l, r, lc, rc->insert(num));\n        }\n        int rank() {\n            return lc ? lc->cnt : 0;\n        }\n    } *roots[MAXN];\n    int n;\n    void build(int a[], int n) {\n        this->n = n;\n        roots[0] = new Node(1, n);\n        for (int i = 1; i <= n; i++) roots[i] = roots[i - 1]->insert(a[i]);\n    }\n    int query(int l, int r, int m) {\n        Node *L = roots[l - 1], *R = roots[r];\n        int res = 0;\n        while (R->sum - L->sum > m) {\n#ifdef DBG\n            printf(\"query in [%d, %d]\\n\", l, r);\n            printf(\" L-([%d, %d], cnt = %d, sum = %lld)\\n\", L->l, L->r, L->cnt, L->sum);\n            printf(\" R-([%d, %d], cnt = %d, sum = %lld)\\n\", R->l, R->r, R->cnt, R->sum);\n#endif\n            L->pushDown();\n            R->pushDown();\n            long long temp = R->lc->sum - L->lc->sum;\n#ifdef DBG\n            printf(\" temp = %lld, res += %d\\n\", temp, R->lc->cnt - L->lc->cnt);\n#endif\n            if (temp <= m) {\n                m -= temp;\n                res += R->lc->cnt - L->lc->cnt;\n                L = L->rc;\n                R = R->rc;\n            } else {\n                L = L->lc;\n                R = R->lc;\n            }\n        }\n#ifdef DBG\n        printf(\"query in [%d, %d], return %d\\n\", l, r, res + R->cnt - L->cnt);\n#endif\n        return res + R->cnt - L->cnt;\n    }\n} pst;\nint s[MAXN];\nvoid dfs(Node *u, Node *fa = NULL) {\n    static int dfsClock = 0;\n    u->dfn = ++dfsClock;\n    s[dfsClock] = u->w;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->v != fa) dfs(e->v, u);\n    }\n    u->rDfn = dfsClock;\n}\nint main() {\n    int m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 1; i <= n; i++) {\n        int f;\n        scanf(\"%d %d %d\", &f, &a[i].s, &a[i].l);\n        if (f != 0) addEdge(i, f);\n        a[i].id = i;\n    }\n    discretization();\n    for (int i = 1; i <= n; i++) N[i].w = a[i].s;\n    dfs(&N[1]);\n#ifdef DBG\n    for (int i = 1; i <= n; i++) printf(\"N[%d].dfn = %d\\n\", i, N[i].dfn);\n#endif\n    pst.build(s, n);\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) ans = std::max(ans, \n                                 (long long) pst.query(N[i].dfn, N[i].rDfn, m) * a[i].l);\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["主席树","DFS序"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2008] 骑士","url":"/BZOJ-1040-ZJOI-2008-骑士/","content":"\n## 题目大意\n\n有 $n$ 个骑士，每个骑士有一个战斗力值 $a_i$，同时每个骑士有一个讨厌的骑士。现从中选出一堆骑士使得战斗力和最大，同时一个骑士不能与他讨厌的骑士都被选，求最大战斗力和。\n\n$1 \\leqslant n \\leqslant 1,000,000$\n\n$1 \\leqslant a_i \\leqslant 1,000,000$\n\n## 题目链接\n\n[【ZJOI 2008】骑士 - 2607](https://www.luogu.com.cn/problem/P2607)\n\n<!-- more -->\n\n## 题解\n\n讨厌关系其实是双向的，所以以讨厌关系建图，将得到一个环套树森林。考虑每一棵环套树，用 dfs 找到环，随便选环上的一条边断开，分别以边两边的节点为根跑树形 DP，取让根节点不被选择的值更新答案（这样可以保证它与被断开的边那头的点不同时被选）。\n\n树形 DP 部分比较显然：\n$$\n\\begin{align}\nf[u, \\; 1] &= \\sum_{v\\; is\\; son\\; of\\; u} f[v, \\; 0] \\\\\nf[u, \\; 0] &= \\sum_{v\\; is\\; son\\; of\\; u} max(f[v, \\; 0], \\; f[v, \\; 1])\n\\end{align}\n$$\n以下是吐槽部分：\n\n我写这道题时脑子似乎进水了。。。\n\n先是读数时每个骑士少读一个数，再是 dfs 时 `banned` 前少了引用，更傻的是 DBG 时写成了 `#define BDG`，以上三个错误每一个各找了半个小时。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 1000005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int val;\n    long long f[2];\n    bool vis;\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nint n;\nvoid dfs(Node *u, Edge *last, Node *&n1, Node *&n2, Edge *&banned) {\n#ifdef DBG\n    printf(\"dfs(%d)\\n\", u->id);\n#endif\n    u->vis = true;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->rev == last) continue;\n        if (e->v->vis) {\n            n1 = u;\n            n2 = e->v;\n            banned = e;\n#ifdef DBG\n            printf(\"get n1 = %d, n2 = %d\\n\", n1->id, n2->id);\n            printf(\"banned:(%d, %d)\\n\", banned->u->id, banned->v->id);\n#endif\n            continue;\n        }\n        dfs(e->v, e, n1, n2, banned);\n    }\n}\nvoid dp(Node *u, Edge *banned, Edge *last = NULL) {\n#ifdef DBG\n    printf(\"dp(%d)\\n\", u->id);\n    printf(\"banned:(%d, %d)\\n\", banned->u->id, banned->v->id);\n#endif\n    u->f[0] = 0;\n    u->f[1] = u->val;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e == banned || e->rev == banned || e->rev == last) continue;\n        dp(e->v, banned, e);\n        u->f[1] += e->v->f[0];\n        u->f[0] += std::max(e->v->f[0], e->v->f[1]);\n    }\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        int x, v;\n        scanf(\"%d %d\", &x, &v);\n        N[i].val = x;\n        addEdge(v, i);\n#ifdef DBG\n        N[i].id = i;\n#endif\n    }\n    Node *n1, *n2;\n    Edge *banned;\n    long long ans = 0;\n    for (int i = 1; i <= n; i++) if (!N[i].vis) {\n        dfs(&N[i], NULL, n1, n2, banned);\n        dp(n1, banned);\n        long long temp = n1->f[0];\n        dp(n2, banned);\n        ans += std::max(temp, n2->f[0]);\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}\n```","tags":["树形DP","DP","环套树","DFS"],"categories":["题解（OI/XCPC）"]},{"title":"[CQOI 2009] 中位数","url":"/BZOJ-1303-CQOI-2009-中位数图/","content":"\n## 题目大意\n\n给出 $1 \\sim n$ 的一个排列，统计该排列有多少个长度为奇数的连续子序列的中位数是 $b$。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n## 题目链接\n\n[【SQOI 2009】中位数 - Luogu 1627](https://www.luogu.com.cn/problem/P1627)\n\n<!-- more -->\n\n## 题解\n\nDP。\n\n找到值为 $b$ 的位置，记为 $bPos$，记 $f[i + n, \\; 0]$ 表示区间起点在 $bPos$ 左侧、区间终点为 $bPos$、区间内比 $b$ 小的数比大的多 $i$ 个的区间数，记 $f[i + n, \\; 1]$ 表示区间起点为 $bPos$、区间终点在 $bPod$ 右侧、区间内比 $b$ 大的数比小的多 $i$ 个的区间数（与刚刚反过来了，为了方便计算答案，很巧的一点啊）。答案为：\n$$\n\\sum_{i = 1 - n}^{n - 1} f[i + n, \\; 0] \\times f[i + n, \\; 1] + f[n, \\; 0] + f[n, \\; 1]\n$$\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 100005;\nint a[MAXN], f[MAXN << 1][2];\nint main(){\n    int n, b;\n    scanf(\"%d%d\", &n, &b);\n    int bPos;\n    for (int i = 0; i < n; i++){\n        int x;\n        scanf(\"%d\", &x);\n        a[i] = x;\n        if (x == b) bPos = i;\n    }\n    int d = 0;\n    for (int i = bPos - 1; i >= 0; i--){\n        if (a[i] < b) d--;\n        if (a[i] > b) d++;\n        f[d + n][0]++;\n    }\n    d = 0;\n    for (int i = bPos + 1; i < n; i++){\n        if (a[i] > b) d--;\n        if (a[i] < b) d++;\n        f[d + n][1]++;\n    }\n    int ans = 1;\n    for (int i = 1; i <= 2 * n - 1; i++){\n        if (i == n) ans += f[i][0] + f[i][1];\n        ans += f[i][0] * f[i][1];\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["DP"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2007] 文本生成器","url":"/BZOJ-1030-JSOI-2007-文本生成器/","content":"\n## 题目大意\n\n给定词典 $D$ 与文章长度 $m$，称一篇文章是可读的当且仅当其中包含了至少一个来自于词典中的词，文章、单词由大写英文字母组成。求可读文章的篇数，答案对 $10,007$ 取模。\n\n$1 \\leqslant |D| \\leqslant 60$\n\n$1 \\leqslant len \\leqslant 100$\n\n## 题目链接\n\n[【JSOI 2007】文本生成器 - Luogu 4052](https://www.luogu.com.cn/problem/P4052)\n\n<!-- more -->\n\n## 题解\n\n建立 AC 自动机。\n\n答案不方便直接计算，考虑答案的对立面——不可读文章的篇数，记 $f[i, \\; j]$ 表示到达了 AC 自动机上的节点 $j$、文章已经考虑了 $i$ 个字符时，不可读文章的篇数。转移时，枚举考虑的字符数 $i$，再枚举每一个节点 $j$，枚举当前字符 $c$，若 AC 自动机上节点 $j$ 再加上字符 $c$ 不是单词节点，则进行转移，把 $f[i, \\; j]$ 的答案加上 $f[i - 1, \\; node(j + c)]$（对于那个 $node(j + c)$，会意即可。。。）。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\nconst int MAXN = 60;\nconst int MAXM = 105;\nconst int CHARSET_SIZE = 'Z' - 'A' + 1;\nconst char BASE_CHAR = 'A';\nconst int MOD = 10007;\nstruct Trie {\n    struct Node {\n        Node *c[CHARSET_SIZE], *fail, *next;\n        int id;\n        bool isWord;\n        Node (bool isWord = false) : isWord(isWord), fail(NULL), next(NULL) {\n            for (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n        }\n    } *root;\n    Trie() : root(NULL) {}\n    void insert(char *begin, char *end) {\n        Node **u = &root;\n        for (char *p = begin; p != end; p++) {\n            if (!(*u)) *u = new Node();\n            u = &(*u)->c[*p];\n        }\n        if (!(*u)) *u = new Node(true);\n        else (*u)->isWord = true;\n    }\n    void build() {\n        std::queue<Node *> q;\n        q.push(root);\n        root->fail = root;\n        root->next = NULL;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (int i = 0; i < CHARSET_SIZE; i++) {\n                Node *c = u->c[i];\n                if (!c) continue;\n                Node *v = u->fail;\n                while (v != root && !v->c[i]) v = v->fail;\n                c->fail = u != root && v->c[i] ? v->c[i] : root;\n                c->next = c->fail->isWord ? c->fail : c->fail->next;\n                q.push(c);\n            }\n        }\n    }\n    bool next(Node *u, int ch, Node *&next) {\n        while (u != root && !u->c[ch]) u = u->fail;\n        next = u->c[ch] ? u->c[ch] : root;\n        if (!u->c[ch]) return false;\n        else if (u->c[ch]->isWord) return true;\n        else if (u->c[ch]->next) return true;\n        else return false;\n    }\n    void getNodeList(std::vector<Node *> &vec) {\n        std::queue<Node *> q;\n        q.push(root);\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            vec.push_back(u);\n            for (int i = 0; i < CHARSET_SIZE; i++) if (u->c[i]) q.push(u->c[i]);\n        }\n    }\n} t;\nint pow(int a, int n) {\n    int res = 1;\n    for (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n    return res % MOD;\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i < n; i++) {\n        static char str[MAXM];\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        for (int i = 0; i < len; i++) str[i] -= BASE_CHAR;\n        t.insert(str, str + len);\n    }\n    t.build();\n    std::vector<Trie::Node *> vec;\n    t.getNodeList(vec);\n    static int f[MAXM][MAXN * MAXM];\n    for (int i = 0; i < vec.size(); i++) vec[i]->id = i, f[0][i] = 1;\n    for (int i = 1; i <= m; i++) {\n        for (int j = 0; j < vec.size(); j++) {\n            for (int k = 0; k < CHARSET_SIZE; k++) {\n                Trie::Node *next;\n                if (!t.next(vec[j], k, next)) (f[i][j] += f[i - 1][next->id]) %= MOD;\n            }\n        }\n    }\n    printf(\"%d\\n\", ((pow(CHARSET_SIZE, m) - f[m][t.root->id] % MOD) + MOD) % MOD);\n    return 0;\n}\n```","tags":["DP","AC自动机","字符串"],"categories":["题解（OI/XCPC）"]},{"title":"[TJOI 2013] 单词","url":"/BZOJ-3172-TJOI-2013-单词/","content":"\n## 题目大意\n\n给定词典 $D$，词典中的单词连起来（单词间分割开来）为文章。求每个单词在文章中的出现次数。\n\n$1 \\leqslant |D| \\leqslant 200$\n\n$1 \\leqslant |T| \\leqslant 1,000,000$\n\n## 题目链接\n\n[【TJOI 2013】单词 - Luogu 3966](https://www.luogu.com.cn/problem/P3966)\n\n<!-- more -->\n\n## 题解\n\n AC 自动机模版题。\n\n单词间用字符集外的字符连接。\n\n## 代码\n\n为了让儿子数少点，`` ` 是ASCII中 `a` 的前一个。。。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <queue>\nconst int MAXN = 205;\nconst int MAXLEN = 1000005;\nconst int CHARSET_SIZE = 'z' - '`' + 1;\nconst int BASE_CHAR = '`';\nstruct Trie {\n    struct Node {\n        Node *c[CHARSET_SIZE], *fail, *next;\n        bool isWord;\n        int ans;\n        Node(bool isWord = false) : isWord(isWord), fail(NULL), next(NULL), ans(0) {\n            for (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n        }\n        void apply() {\n            ans++;\n            if (next) next->apply();\n        }\n    } *root;\n    Trie() : root(NULL) {}\n    Node *insert(char *begin, char *end) {\n        Node **u = &root;\n        for (char *p = begin; p != end; p++) {\n            if (!(*u)) *u = new Node();\n            u = &(*u)->c[*p];\n        }\n        if (!(*u)) *u = new Node(true);\n        else (*u)->isWord = true;\n        return *u;\n    }\n    void build() {\n        std::queue<Node *> q;\n        q.push(root);\n        root->fail = root;\n        root->next = NULL;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (int i = 0; i < CHARSET_SIZE; i++) {\n                Node *c = u->c[i];\n                if (!c) continue;\n                Node *v = u->fail;\n                while (v != root && !v->c[i]) v = v->fail;\n                c->fail = u != root && v->c[i] ? v->c[i] : root;\n                c->next = c->fail->isWord ? c->fail : c->fail->next;\n                q.push(c);\n            }\n        }\n    }\n    void exec(char *begin, char *end) {\n        Node *u = root;\n        for (char *p = begin; p != end; p++) {\n            while (u != root && !u->c[*p]) u = u->fail;\n            u = u->c[*p] ? u->c[*p] : root;\n            if (u->isWord) u->apply();\n            else if (u->next) u->next->apply();\n        }\n    }\n} t;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    static Trie::Node *words[MAXN];\n    static char str[MAXLEN + MAXN];\n    char *p = str;\n    for (int i = 0; i < n; i++) {\n        static char s[MAXLEN];\n        scanf(\"%s\", s);\n        int len = strlen(s);\n        for (int i = 0; i < len; i++) s[i] -= BASE_CHAR, *p++ = s[i];\n        words[i] = t.insert(s, s + len);\n        *p++ = 0;\n    }\n    *--p = 0;\n    t.build();\n    t.exec(str, p);\n    for (int i = 0; i < n; i++) printf(\"%d\\n\", words[i]->ans);\n    return 0;\n}\n```","tags":["AC自动机","字符串","模版"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2007] 蜥蜴","url":"/BZOJ-1066-SCOI-2007-蜥蜴/","content":"\n## 题目大意\n\n$n \\times m$ 的网格上有一些柱子，一些柱子上有蜥蜴，蜥蜴可以跳向曼哈顿距离小于等于 $d$ 的柱子上，一个柱子上最多有一只蜥蜴，当蜥蜴跳走后，原柱子高度减一。求无法跳出网格的蜥蜴数量的最小值。\n\n$1 \\leqslant n, \\; m \\leqslant 20$\n\n$1 \\leqslant d \\leqslant 4$\n\n## 题目链接\n\n[【SCOI 2007】蜥蜴 - Luogu 2472](https://www.luogu.com.cn/problem/P2472)\n\n<!-- more -->\n\n## 题解\n\n建图跑网络流，最大流为最多跳出去的蜥蜴只数。\n\n每个点拆成两个点，记为 $1$ 号点和 $2$ 号点。\n\n对于柱子高度的限制，从对应的 $1$ 号点向 $2$ 号点连一条容量为高度的边。\n\n对与每一个点，从它的 $2$ 号点向与其曼哈顿距离小于等于 $d$ 的点的 $1$ 号点连一条容量无限的边。\n\n最后，从源点向每一只蜥蜴的 $1$ 号点连一条容量为 $1$ 的边，从能跳出去的 $2$ 号点向汇点连一条容量为$1$的边。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstdlib>\n#include <climits>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 20;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN * 2 + 2];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n#ifdef DBG\n    printf(\"edge : %d --> %d, cap = %d\\n\", u, v, cap);\n#endif\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nstruct Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int operator()(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n} dinic;\nint n, m;\nint getID(int x, int y, int k) {\n    return k * n * m + (x - 1) * m + y;\n}\nint main() {\n    int d;\n    scanf(\"%d %d %d\", &n, &m, &d);\n    const int s = 0, t = n * m * 2 + 1;\n    for (int i = 1; i <= n; i++) {\n        static char str[MAXN + 1];\n        scanf(\"%s\", str + 1);\n        for (int j = 1; j <= m; j++) if (str[j] != '0')\n            addEdge(getID(i, j, 0), getID(i, j, 1), str[j] - '0');\n    }\n    int cnt = 0;\n    for (int i = 1; i <= n; i++) {\n        static char str[MAXN + 1];\n        scanf(\"%s\", str + 1);\n        for (int j = 1; j <= m; j++) if (str[j] == 'L') {\n            cnt++;\n            addEdge(s, getID(i, j, 0), 1);\n        }\n    }\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        for (int k = 1; k <= n; k++) for (int l = 1; l <= m; l++) {\n            if (abs(i - k) + abs(j - l) <= d) \n                addEdge(getID(i, j, 1), getID(k, l, 0), INT_MAX);\n        }\n        if (i <= d || i > n - d || j <= d || j > m - d) \n            addEdge(getID(i, j, 1), t, INT_MAX);\n    }\n    printf(\"%d\\n\", cnt - dinic(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流"],"categories":["题解（OI/XCPC）"]},{"title":"[USACO 2008] 土地购买","url":"/BZOJ-1597-USACO-2008-土地购买/","content":"\n## 题目大意\n\n有 $n$ 块土地，每块的大小为 $w_i \\times h_i$。对于一块土地，它的价格是它的面积；一次可以购买多块土地，价格为 $max(w) \\times max(h)$。求购买所有土地的最小花费。\n\n$1 \\leqslant n \\leqslant 50,000$\n\n$1 \\leqslant w_i, \\; h_i \\leqslant 1,000,000$\n\n## 题目链接\n\n[【USACO08MAR】Land Acquisition G - Luogu 2900](https://www.luogu.com.cn/problem/P2900)\n\n<!-- more -->\n\n## 题解\n\nDP + 斜率优化。\n\n对土地按宽排序，如果有一块土地的长宽均小于另一个，则该土地队答案无影响。删掉所有的无用土地后，得到的土地序列是一维降序，另一维升序，我们可以让宽降序、长升序。\n\n记 $f[i]$ 为此时前 $i$ 块的答案，则转移为：\n$$\nf[i] = min(f[j] + w[j + 1] \\times h[i])\n$$\n对于后面的一堆，考虑两个决策点 $a$、$b$（$a > b$），假设 $a$ 优于 $b$，有：\n$$\n\\begin{align}\nf[a] + w[a + 1] \\times h[i] &< f[b] + w[b + 1] \\times h[i] \\\\\n\\frac{f[a] - f[b]}{w[b + 1] - w[a + 1]} &< h[i]\n\\end{align}\n$$\n用斜率的单调队列维护决策点，最优决策点在一个下凸包上。\n\n## 代码\n\n交的代码数组们开成长宽的范围了。。。\n\n```c++\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nconst int MAXN = 50005;\nlong long f[MAXN];\nstd::pair<int, int> a[MAXN];\nstd::vector<std::pair<int, int> *> vec;\ndouble slope(int i, int j) {\n    return (double) (f[i] - f[j]) / (vec[j]->first - vec[i]->first);\n}\nint n;\nvoid dp() {\n    static int q[MAXN];\n    int *l = q, *r = q;\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*l, *(l + 1)) < vec[i - 1]->second) l++;\n        int k = *l;\n        f[i] = f[k] + (long long) vec[k]->first * vec[i - 1]->second;\n        if (i < n) {\n            while (l < r && slope(*(r - 1), *r) > slope(*r, i)) r--;\n            *++r = i;\n        }\n    }\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%d %d\", &a[i].first, &a[i].second);\n    std::pair<int, int> *last = NULL;\n    std::sort(a + 1, a + n + 1);\n    for (int i = n; i; i--) {\n        if (!last || a[i].second > last->second) {\n            last = &a[i];\n            vec.push_back(last);\n        }\n    }\n    n = vec.size();\n    dp();\n    printf(\"%lld\\n\", f[n]);\n    return 0;\n}\n```","tags":["DP","单调队列","斜率优化DP"],"categories":["题解（OI/XCPC）"]},{"title":"[APIO 2010] 特别行动队","url":"/BZOJ-1911-APIO-2010-特别行动队/","content":"\n## 题目大意\n\n有 $n$ 个士兵，初始战斗力为 $x_i$。先分为几段作为特别行动队（每段编号连续），每段的初始战斗力为 $x = \\sum_{i \\in [l, \\; r]} x_i$，之后再处理为 $x' = A x^2 + B x + C$。求最大的战斗力。\n\n$1 \\leqslant n \\leqslant 1,000,000$\n\n$1\\leqslant x_i \\leqslant 100$\n\n$-5 \\leqslant A \\leqslant -1$\n\n$|B|, \\; |C| \\leqslant 10,000,000$\n\n## 题目链接\n\n[【APIO 2010】特别行动队](https://www.luogu.com.cn/problem/P3628)\n\n<!-- more -->\n\n## 题解\n\nDP + 斜率优化。\n\n记 $f[i]$ 为前 $i$ 个的答案，则转移为：\n$$\nf[i] = max(f[j] + A (X[i] - X[j])^2 + B (X[i] - X[j]) + C) \\quad j \\in [1, \\; i - 1]\n$$\n其中 $X$ 为 $x_i$ 的前缀和。\n\n对于后面的一堆，考虑两个决策点 $a$、$b$（$a > b$），假设 $a$ 优于 $b$，有：\n$$\n\\begin{align}\nf[a] + A(X[i] - X[a])^2 + B(X[i] - X[a]) + C &> f[b] + A(X[i] - X[b])^2\\\\\n&+ B(X[i] - X[b]) + C \\\\\nf[a] + A X[a]^2 - 2 A X[i] X[a] - B X[a] &> f[b] + A X[b]^2\\\\\n&- 2 A X[i] X[b] - B X[b] \\\\\n\\frac{(f[a] + A X[a]^2 - B X[a]) - (f[b] + A X[b]^2 - B X[b])}{X[a] - X[b]} &> 2 A X[i]\n\\end{align}\n$$\n用斜率的单调队列维护决策点，最优决策点在一个上凸包上。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 1000005;\nlong long f[MAXN];\nlong long x[MAXN], pSumX[MAXN], a, b, c;\nlong long y(int i) {\n    return f[i] + a * pSumX[i] * pSumX[i] - b * pSumX[i];\n}\ndouble slope(int i, int j) {\n    return (double) (y(i) - y(j)) / (pSumX[i] - pSumX[j]);\n}\nint n;\nvoid dp() {\n    static int q[MAXN];\n    int *l = q, *r = q;\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*l, *(l + 1)) > 2 * a * pSumX[i]) l++;\n        int k = *l;\n        long long temp = pSumX[i] - pSumX[k];\n        f[i] = f[k] + a * temp * temp + b * temp + c;\n        while (l < r && slope(*(r - 1), *r) < slope(*r, i)) r--;\n        *++r = i;\n    }\n}\nint main() {\n    scanf(\"%d %lld %lld %lld\", &n, &a, &b, &c);\n    for (int i = 1; i <= n; i++) scanf(\"%lld\", &x[i]);\n    for (int i = 1; i <= n; i++) pSumX[i] = pSumX[i - 1] + x[i];\n    dp();\n    printf(\"%lld\\n\", f[n]);\n    return 0;\n}\n```","tags":["DP","单调队列","斜率优化DP"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2007] 仓库建设","url":"/BZOJ-1096-ZJOI-2007-仓库建设/","content":"\n## 题目大意\n\n有 $n$ 个工厂，每个工厂距工厂 $1$ 的距离为 $x_i$（递增），有产品 $p_i$ 个，建立仓库的费用为 $c_i$。现建设一些仓库，每个工厂的产品只能向编号更大的仓库运送，费用为产品数 $\\times$ 距离。求把所有产品运送到仓库的最小费用。\n\n$1 \\leqslant n \\leqslant 1,000,000$\n\n$x_i$、$p_i$、$c_i$均在 `int` 内\n\n## 题目链接\n\n[【ZJOI 2007】仓库建设 - Luogu 2120](https://www.luogu.com.cn/problem/P2120)\n\n<!-- more -->\n\n## 题解\n\nDP + 斜率优化。\n\n记 $f[i]$ 表示前 $i$ 个仓库的答案，转移为：\n$$\n\\begin{align}\nf[i] &= min(f[j] + c[i] + \\sum_{k = j + 1}^{i} p[k] \\times (x[i] - x[k]) \\quad j \\in [1, \\; i - 1] \\\\\n&= min(f[j] + c[i] + (P[i] - P[j]) \\times x[i] - (XP[i] - XP[j]))\n\\end{align}\n$$\n其中 $P$ 为 $p_i$ 的前缀和，$XP$ 为 $x_i \\times p_i$ 的前缀和。\n\n对于后面的一堆，考虑两个决策点 $a$、$b$（$a > b$），假设 $a$ 优于 $b$，有：\n$$\n\\begin{align}\nf[a] + c[i] + (P[i] - P[a]) \\times x[i] - (XP[i] - XP[a])  &< f[b] + c[i] + (P[i] - P[b]) \\times x[i] \\\\\n& - (XP[i] - XP[b]) \\\\\nf[a] - P[a] \\times x[i] + XP[a] &< f[b] - P[b] \\times x[i] + XP[b] \\\\\n\\frac{(f[a] + XP[a]) - (f[b] + XP[b])}{P[a] - P[b]} &< x[i]\n\\end{align}\n$$\n用斜率的单调队列维护决策点，最优决策点在一个下凸包上。\n\n## 代码\n\n```c++\n#include <cstdio>\nconst int MAXN = 1000005;\nlong long f[MAXN];\nlong long p[MAXN], x[MAXN], c[MAXN];\nlong long pSumP[MAXN], pSumXP[MAXN];\nlong long y(int i) {\n    return f[i] + pSumXP[i];\n}\ndouble slope(int i, int j) {\n    return (double) (y(i) - y(j)) / (pSumP[i] - pSumP[j]);\n}\nint n;\nvoid dp() {\n    static int q[MAXN];\n    int *l = q, *r = q;\n    for (int i = 1; i <= n; i++) {\n        while (l < r && slope(*l, *(l + 1)) < x[i]) l++;\n        int k = *l;\n        f[i] = f[k] + (pSumP[i] - pSumP[k]) * x[i] - (pSumXP[i] - pSumXP[k]) + c[i];\n        while (l < r && slope(*(r - 1), *r) > slope(*r, i)) r--;\n        *++r = i;\n    }\n}\nint main() {\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) scanf(\"%lld %lld %lld\", &x[i], &p[i], &c[i]);\n    for (int i = 1; i <= n; i++) {\n        pSumP[i] = pSumP[i - 1] + p[i];\n        pSumXP[i] = pSumXP[i - 1] + x[i] * p[i];\n    }\n    dp();\n    printf(\"%lld\\n\", f[n]);\n    return 0;\n}\n```","tags":["DP","单调队列","斜率优化DP"],"categories":["题解（OI/XCPC）"]},{"title":"[POJ 2774] Long Long Message","url":"/POJ-2774-Long-Long-Message/","content":"\n## 题目大意\n\n给定两个字符串 $S$、$T$。求两个字符串的最长公共字串。\n\n$1 \\leqslant |S|, \\; |T| \\leqslant 10,000$\n\n## 题目链接\n\n[POJ 2774](http://poj.org/problem?id=2774)\n\n<!-- more -->\n\n## 题解\n\n连接两个字符串，中间用不属于原字符集的字符隔开。\n\n建立后缀数组，当排名相连的两个后缀满足：一个的第一个字符在前一个字符串中，另一在后一个字符串中时，用 $heigh[i]$ 更新答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nnamespace SuffixArray {\n    const int MAXN = ::MAXN << 1;\n    int rank[MAXN], sa[MAXN], height[MAXN], n;\n    char str[MAXN];\n    void buildSA(int m) {\n        static int fir[MAXN], sec[MAXN], temp[MAXN], cnt[MAXN], i;\n        n = strlen(str);\n        memset(cnt, 0, sizeof (cnt));\n        for (i = 0; i < n; i++) cnt[(int) str[i]]++;\n        for (i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n        for (i = 0; i < n; i++) rank[i] = cnt[(int) str[i]] - 1;\n        for (int l = 1; l < n; l <<= 1) {\n            for (i = 0; i < n; i++)\n                fir[i] = rank[i], sec[i] = i + l < n ? rank[i + l] : 0;\n            memset(cnt, 0, sizeof (cnt));\n            for (i = 0; i < n; i++) cnt[sec[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) temp[--cnt[sec[i]]] = i;\n            memset(cnt, 0, sizeof (cnt));\n            for (i = 0; i < n; i++) cnt[fir[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) sa[--cnt[fir[temp[i]]]] = temp[i];\n            bool unique = true;\n            rank[sa[0]] = 0;\n            for (i = 1; i < n; i++) {\n                rank[sa[i]] = rank[sa[i - 1]];\n                if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) \n                    unique = false;\n                else rank[sa[i]]++;\n            }\n            if (unique) break;\n        }\n    }\n    void calcHeight() {\n        for (int i = 0, k = 0; i < n - 1; i++) {\n            k ? k-- : 0;\n            int j = sa[rank[i] - 1];\n            while (str[i + k] == str[j + k]) k++;\n            height[rank[i]] = k;\n        }\n    }\n}\nint main() {\n    static char str1[MAXN], str2[MAXN];\n    scanf(\"%s %s\", str1, str2);\n    int l1 = strlen(str1), l2 = strlen(str2);\n    str1[l1++] = '#';\n    str2[l2++] = '$';\n    char *str = SuffixArray::str;\n    for (int i = 0; i < l1; i++) str[i] = str1[i];\n    for (int i = 0; i < l2; i++) str[i + l1] = str2[i];\n    SuffixArray::buildSA(128);\n    SuffixArray::calcHeight();\n    int ans = 0;\n    int *height = SuffixArray::height + 2, *sa = SuffixArray::sa + 2, \n        n = l1 + l2 - 2;\n    l1--;\n#ifdef DBG\n    printf(\"new string is: %s\\n\", SuffixArray::str);\n    printf(\"sa: \");\n    for (int i = 0; i < n; i++) printf(\"%d%c\", sa[i], i == n - 1 ? '\\n' : ' ');\n    printf(\"height: \");\n    for (int i = 1; i < n; i++) printf(\"%d%c\", height[i], i == n - 1 ? '\\n' : ' ');\n#endif\n    for (int i = 1; i < n; i++) {\n        if ((sa[i] < l1 && sa[i - 1] > l1) || (sa[i] > l1 && sa[i - 1] < l1)) \n            ans = std::max(ans, height[i]);\n    }\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["字符串","后缀数组"],"categories":["题解（OI/XCPC）"]},{"title":"[AHOI 2013] 差异","url":"/BZOJ-3238-AHOI-2013-差异/","content":"\n## 题目大意\n\n长度为 $n$ 的字符串 $S$，记 $T_i$ 为其从第 $i$ 个字符开始的后缀，求：\n$$\n\\sum_{1 \\leqslant i < j \\leqslant n} len(T_i) + len(T_j) - 2 \\; lcp(T_i, \\; T_j)\n$$\n$1 \\leqslant n \\leqslant 500,000$\n\n## 题目链接\n\n[【AHOI 2013】差异 - Luogu 4248](https://www.luogu.com.cn/problem/P4248)\n\n<!-- more -->\n\n## 题解\n\n将所求式分成两部分。\n\n第一部分易得为：\n$$\n\\sum_{1 \\leqslant i < j \\leqslant n} len(T_i) + len(T_j) = (n - 1) \\times \\frac{n (n + 1)}2\n$$\n因为每个后缀均被枚举了 $n - 1$ 次。\n\n第二部分（不管系数），由后缀数组中 $height$ 数组的性质可化为：\n$$\n\\begin{align}\n\\sum_{1 \\leqslant i < j \\leqslant n} lcp(T_i, \\; T_j) &= \\sum_{1 \\leqslant i < j \\leqslant n} min(height[k]), \\; k \\in [rank[i] + 1, \\; rank[j]] \\\\\n&= \\sum_{1 \\leqslant i < j \\leqslant n} min(height[k]), \\; k \\in [i + 1, \\; j]\n\\end{align}\n$$\n即所有区间的 $ height$的最小值。暴力求解显然会 TLE。\n\n枚举区间的结尾 $i$，在这之前比 $height[i]$ 大的值都不会对答案产生影响，考虑维护一个 $height$ 单调栈（说来在这道题里，它只进不出的，说单调队列也没错。。。）记录 $i$。\n\n当考虑到 $i$ 对答案的贡献时，记在 $i$ 之前第一个满足 $height[j] \\leqslant height[i]$ 的 $j$，区间开头在 $[j + 1, \\; i]$ 内的区间的最小值均为 $height[i]$，即对答案的贡献为 $(i - j) \\times height[i]$。从头枚举一遍即可。\n\n## 代码\n\n就是这道题，让我换了后缀数组的版子，因为，这个版子理解起来容易一些（后缀数组的代码终于不用背了！）。。。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <stack>\nconst int MAXN = 500005;\nnamespace SuffixArray {\n    int rank[MAXN], sa[MAXN], height[MAXN], n;\n    char str[MAXN];\n    void buildSA(int m) {\n        static int fir[MAXN], sec[MAXN], temp[MAXN], cnt[MAXN], i;\n        n = strlen(str) + 1;\n        str[n - 1] = 0;\n        memset(cnt, 0, sizeof cnt);\n        for (i = 0; i < n; i++) cnt[(int) str[i]]++;\n        for (i = 1; i < m; i++) cnt[i] += cnt[i - 1];\n        for (i = 0; i < n; i++) rank[i] = cnt[(int) str[i]] - 1;\n        for (int l = 1; l < n; l <<= 1) {\n            for (int i = 0; i < n; i++)\n                fir[i] = rank[i], sec[i] = i + l < n ? rank[i + l] : 0;\n            memset(cnt, 0, sizeof cnt);\n            for (i = 0; i < n; i++) cnt[sec[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) temp[--cnt[sec[i]]] = i;\n            memset(cnt, 0, sizeof cnt);\n            for (i = 0; i < n; i++) cnt[fir[i]]++;\n            for (i = 1; i < n; i++) cnt[i] += cnt[i - 1];\n            for (i = n - 1; ~i; i--) sa[--cnt[fir[temp[i]]]] = temp[i];\n            bool unique = true;\n            rank[sa[0]] = 0;\n            for (i = 1; i < n; i++) {\n                rank[sa[i]] = rank[sa[i - 1]];\n                if (fir[sa[i]] == fir[sa[i - 1]] && sec[sa[i]] == sec[sa[i - 1]]) \n                    unique = false;\n                else rank[sa[i]]++;\n            }\n            if (unique) break;\n        }\n    }\n    void getHeight() {\n        int k = 0;\n        for (int i = 0; i < n - 1; i++) {\n            k ? k-- : 0;\n            int j = sa[rank[i] - 1];\n            while (str[i + k] == str[j + k]) k++;\n            height[rank[i]] = k;\n        }\n    }\n}\nint main() {\n    char *str = SuffixArray::str;\n    scanf(\"%s\", str);\n    int n = strlen(str);\n    SuffixArray::buildSA(128);\n    SuffixArray::getHeight();\n    int *height = SuffixArray::height + 1;\n    long long ans = 0;\n    std::stack<int> s;\n    s.push(0);\n    static long long f[MAXN];\n    for (int i = 1; i < n; i++) {\n        while (!s.empty() && height[s.top()] > height[i]) s.pop();\n        ans += f[i] = f[s.top()] + (long long) (i - s.top()) * height[i];\n        s.push(i);\n    }\n    printf(\"%lld\\n\", (long long) (n - 1) * n * (n + 1) / 2 - 2 * ans);\n    return 0;\n}\n```","tags":["字符串","后缀数组","单调栈"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2011] 染色","url":"/BZOJ-2243-SDOI-2011-染色/","content":"\n## 题目大意\n\n一个 $n$ 个节点的树，每个节点有一个权值 $c_i$，给出 $m$ 组操作，每次操作为：\n\n* $C \\; a \\; b \\; c$：把链 $a-b$ 上的节点的权值全部修改为 $c$。\n* $Q \\; a \\; b$：询问链 $a-b$ 上有几段权值。\n\n$1 \\leqslant n, \\; m \\leqslant 100,000$\n\n$0 \\leqslant c_i \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[【SDOI 2011】染色 - Luogu 2486](https://www.luogu.com.cn/problem/P2486)\n\n## 题解\n\n树链剖分裸题。\n\n一直懒得做，今天做了之后被各种细节错误坑惨了（代码中所有有 `DBG` 的地方几乎都是出过错的地方）。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nstruct Edge;\nstruct Chain;\nstruct Node {\n    Edge *e;\n    Chain *c;\n    Node *fa, *maxChild;\n    int size, dfn, deep;\n    bool vis;\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nstruct Chain {\n    Node *top;\n    Chain(Node *top) : top(top) {}\n};\nvoid addEdge(int u, int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\nvoid dfs1(Node *u) {\n    u->vis = true;\n    u->size = 1;\n#ifdef DBG\n    printf(\"dfs1(%d)\\n\", u->id);\n#endif\n    for (Edge *e = u->e; e; e = e->next) {\n#ifdef DBG\n        printf(\"when dfs1(%d), v: %d\\n\", u->id, e->v->id);\n#endif\n        if (e->v->vis) continue;\n        e->v->fa = u;\n        e->v->deep = u->deep + 1;\n        dfs1(e->v);\n        u->size += e->v->size;\n        if (!u->maxChild || u->maxChild->size < e->v->size) u->maxChild = e->v;\n    }\n#ifdef DBG\n    printf(\"end dfs1(%d)\\n\", u->id);\n#endif\n}\nvoid dfs2(Node *u) {\n    static int dfsClock = 0;\n    u->dfn = ++dfsClock;\n    if (!u->fa || u != u->fa->maxChild) u->c = new Chain(u);\n    else u->c = u->fa->c;\n    if (u->maxChild) dfs2(u->maxChild);\n    for (Edge *e = u->e; e; e = e->next)\n        if (e->v->fa == u && e->v != u->maxChild) dfs2(e->v);\n}\nvoid split() {\n    N[1].deep = 1;\n    dfs1(&N[1]);\n#ifdef DBG\n    puts(\"after dfs1\");\n#endif\n    dfs2(&N[1]);\n}\nstruct SegT {\n    struct Node {\n        int l, r, mid;\n        Node *lc, *rc;\n        int cnt, val, lval, rval, tag;\n        Node(int l, int r, Node *lc, Node *rc) : l(l), r(r), lc(lc), rc(rc), cnt(0), val(0), lval(0), rval(0), tag(-1) {}\n        void maintain() {\n            cnt = lc->cnt + rc->cnt - (lc->rval == rc->lval);\n            lval = lc->lval;\n            rval = rc->rval;\n        }\n        void pushDown() {\n            if (tag != -1) {\n                val = lval = rval = tag;\n                cnt = 1;\n                if (lc) lc->tag = tag;\n                if (rc) rc->tag = tag;\n                tag = -1;\n            }\n        }\n        void update(int pos, int v) {\n#ifdef DBG\n            printf(\"update(%d) in [%d, %d] to %d\\n\", pos, l, r, v);\n#endif\n            pushDown();\n            if (l == r) {\n                val = lval = rval = v;\n                cnt = 1;\n                return;\n            }\n            int mid = l + (r - l) / 2;\n            if (pos <= mid) lc->update(pos, v);\n            else rc->update(pos, v);\n            maintain();\n        }\n        void update(int l, int r, int v) {\n#ifdef DBG\n            printf(\"update[%d, %d] in [%d, %d] to  %d\\n\", l, r, this->l, this->r, v);\n#endif\n            pushDown();\n            if (r < this->l || this->r < l) return;\n            if (l <= this->l && this->r <= r) {\n                tag = v;\n                pushDown();\n                return;\n            }\n            lc->update(l, r, v);\n            rc->update(l, r, v);\n            maintain();\n        }\n        int query(int pos) {\n#ifdef DBG\n            printf(\"queryVal in [%d, %d], val = %d\\n\", l, r, val);\n#endif\n            pushDown();\n            if (l == r) return val;\n            int mid = l + (r - l) / 2;\n            if (pos <= mid) return lc->query(pos);\n            else return rc->query(pos);\n        }\n        int query(int l, int r) {\n#ifdef DBG\n            printf(\"query[%d, %d] in [%d, %d], cnt = %d\\n\", l, r, this->l, this->r, cnt);\n#endif\n            pushDown();\n            if (r < this->l || this->r < l) return 0;\n            if (l <= this->l && this->r <= r) return cnt;\n            int res = lc->query(l, r) + rc->query(l, r);\n            int mid = this->l + (this->r - this->l) / 2;\n            if (l <= mid && mid < r && lc->rval == rc->lval) res--;\n            return res;\n        }\n    } *root;\n    SegT() : root(NULL) {}\n    static Node *build(int l, int r) {\n        if (l == r) return new Node(l, r, NULL, NULL);\n        int mid = l + (r - l) / 2;\n        return new Node(l, r, build(l, mid), build(mid + 1, r));\n    }\n    void update(int pos, int v) {\n        root->update(pos, v);\n    }\n    void update(int l, int r, int v) {\n        root->update(l, r, v);\n    }\n    int query(int pos) {\n        return root->query(pos);\n    }\n    int query(int l, int r) {\n        return root->query(l, r);\n    }\n} segT;\nint n, m, c[MAXN];\nvoid update(int a, int b, int val) {\n    Node *u = &N[a], *v = &N[b];\n    while (u->c != v->c) {\n        if (u->c->top->deep < v->c->top->deep) std::swap(u, v);\n        segT.update(u->c->top->dfn, u->dfn, val);\n        u = u->c->top->fa;\n    }\n    if (u->deep > v->deep) std::swap(u, v);\n    segT.update(u->dfn, v->dfn, val);\n}\nint query(int a, int b) {\n    Node *u = &N[a], *v = &N[b];\n    int res = 0;\n    while (u->c != v->c) {\n        if (u->c->top->deep < v->c->top->deep) std::swap(u, v);\n        res += segT.query(u->c->top->dfn, u->dfn);\n#ifdef DBG\n        printf(\"query(%d, %d), res = %d(before -)\\n\", a, b, res);\n#endif\n        if (segT.query(u->c->top->dfn) == segT.query(u->c->top->fa->dfn)) res--;\n#ifdef DBG\n        printf(\"query(%d, %d), res = %d\\n\", a, b, res);\n#endif\n        u = u->c->top->fa;\n    }\n    if (u->deep > v->deep) std::swap(u, v);\n    res += segT.query(u->dfn, v->dfn);\n    return res;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n#ifdef DBG\n    for (int i = 1; i <= n; i++) N[i].id = i;\n#endif\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &c[i]);\n    for (int i = 1; i < n; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    split();\n#ifdef DBG\n    puts(\"after split\");\n#endif\n    segT.root = SegT::build(1, n);\n    for (int i = 1; i <= n; i++) segT.update(N[i].dfn, c[i]);\n#ifdef DBG\n    puts(\"after build\");\n#endif\n    while (m--) {\n#ifdef DBG\n        printf(\"m = %d\\n\", m);\n#endif\n        char op[2];\n        int a, b;\n        scanf(\"%s %d %d\", op, &a, &b);\n        if (op[0] == 'C') {\n            int c;\n            scanf(\"%d\", &c);\n            update(a, b, c);\n        } else printf(\"%d\\n\", query(a, b));\n    }\n    return 0;\n}\n```","tags":["树链剖分"],"categories":["题解（OI/XCPC）"]},{"title":"[HNOI 2004] L语言","url":"/BZOJ-1212-HNOI-2004-L语言/","content":"\n## 题目大意\n\n称一段文章 $T$ 在某个字典 $D$ 是可以被理解的，是指如果文章 $T$ 可以被分成若干部分，且每一个部分都是字典 $D$ 中的单词。\n\n给定一个字典 $D$（有单词 $n$ 个），判断 $m$ 段文章在字 $D$ 下是否能够被理解。并给出其在字典 $D$ 下能够被理解的最长前缀的位置。\n\n$1 \\leqslant n, \\; m \\leqslant 20$\n\n$1 \\leqslant len \\leqslant 1M$ （每段文章的长度）\n\n## 题目链接\n\n[【HNOI 2004】L 语言 - Luogu 2292](https://www.luogu.com.cn/problem/P2292)\n\n<!-- more -->\n\n## 题解\n\n对字典建立 Trie，在判断每段文章时，记 $f[i]$ 表示文章的前 $i$ 个字符是否可理解。若 $f[i - 1]$ 为真，则可以判断 $f[i - 1 + m]$ 是否为真（$m$ 为字典中单词的长度）。最大的满足 $f[i]$ 为真的 $i$ 就是答案。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int CHARSET_SIZE = 'z' - 'a' + 1;\nconst char BASE_CHAR = 'a';\nconst int MAXLEN = 1048580;\nstruct Trie {\n    struct Node {\n        Node *c[CHARSET_SIZE];\n        bool isWord;\n        Node (bool isWord) : isWord(isWord) {\n            for (int i = 0; i < CHARSET_SIZE; i++) c[i] = NULL;\n        }\n    } *root;\n    Trie() : root(NULL) {}\n    void insert(char *begin, char *end) {\n        Node **u = &root;\n        for (char *p = begin; p != end; p++) {\n            if (!*u) *u = new Node(false);\n            u = &(*u)->c[*p];\n        }\n        if (!*u) *u = new Node(true);\n        else (*u)->isWord = true;\n    }\n} trie;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    static char s[MAXLEN];\n    while (n--) {\n        scanf(\"%s\", s);\n        int len = strlen(s);\n        for (int i = 0; i < len; i++) s[i] -= 'a';\n        trie.insert(s, s + len);\n    }\n    while (m--) {\n        scanf(\"%s\", s + 1);\n        int len = strlen(s + 1);\n        static bool f[MAXLEN];\n        for (int i = 1; i <= len; i++) s[i] -= 'a', f[i] = false;\n        int ans = 0;\n        f[ans] = true;\n        for (int i = 1; i <= len; i++) {\n            if (!f[i - 1]) continue;\n            Trie::Node *u = trie.root;\n            for (int j = i; j <= len; j++) {\n                if (!u->c[s[j]]) break;\n                u = u->c[s[j]];\n                if (u->isWord) f[j] = true, ans = std::max(ans, j);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}\n```","tags":["Trie"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2006] 三色二叉树","url":"/BZOJ-1864-ZJOI-2006-三色二叉树/","content":"\n## 题目大意\n\n对一个二叉树的节点进行红、绿、蓝的染色，父子节点、兄弟节点之间不同色。求最多／少能染多少个绿色节点。\n\n二叉树的给出方式为一个只由 $0$、$1$、$2$ 组成的数字序列。若为 $0$ ，表示叶子节点；若为 $1$，表示有一个子节点，之后的序列描述这个节点的子树；若为 $2$，表示有两个子节点，之后的序列描述子树。\n\n$1 \\leqslant n \\leqslant 500,000$\n\n## 题目链接\n\n[【ZJOI 2006】三色二叉树 - Luogu 2585](https://www.luogu.com.cn/problem/P2585)\n\n<!-- more -->\n\n## 题解\n\n树形 DP。\n\n不用管不是绿色的节点是红色还是蓝色。\n\n记 $f[u, \\; 0/1]$ 表示节点 $u$ 在不是／是绿色时子树的答案，转移为（以最大值为例）：\n$$\n\\begin{align}\nf[u, \\; 1] &= f[u.lc, \\; 0] + f[u.rc, \\; 0] + 1 \\\\\nf[u, \\; 0] &= max(f[u.lc, \\; 0] + f[u.rc, \\; 1], \\; f[u.lc, \\; 1] + f[u.rc, \\; 0]) \n\\end{align}\n$$\n最小值同理。\n\n## 代码\n\n节点和边根本不记录多少东西，就不用结构体了。。。\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 500005;\nint f[MAXN][2];\nint l[MAXN], r[MAXN];\nvoid readTree(int u = 1) {\n    static int nodeIndex = 1;\n    char ch = getchar();\n    if (ch == '0') return;\n    l[u] = ++nodeIndex;\n    readTree(nodeIndex);\n    if (ch == '2') {\n        r[u] = ++nodeIndex;\n        readTree(nodeIndex);\n    }\n}\nvoid dpMax(int u = 1) {\n    if (u == 0) return;\n    dpMax(l[u]);\n    dpMax(r[u]);\n    f[u][1] = f[l[u]][0] + f[r[u]][0] + 1;\n    f[u][0] = std::max(f[l[u]][1] + f[r[u]][0], f[l[u]][0] + f[r[u]][1]);\n}\nvoid dpMin(int u = 1) {\n    if (u == 0) return;\n    dpMin(l[u]);\n    dpMin(r[u]);\n    f[u][1] = f[l[u]][0] + f[r[u]][0] + 1;\n    f[u][0] = std::min(f[l[u]][1] + f[r[u]][0], f[l[u]][0] + f[r[u]][1]);\n}\nint main() {\n    readTree();\n    dpMax();\n    int ansMax = std::max(f[1][1], f[1][0]);\n    memset(f, 0, sizeof (f));\n    dpMin();\n    int ansMin = std::min(f[1][1], f[1][0]);\n    printf(\"%d %d\\n\", ansMax, ansMin);\n    return 0;\n}\n```","tags":["树形DP","DP"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] 单选错位","url":"/BZOJ-2134-单选错位/","content":"\n## 题目大意\n\n有 $n$ 道单选题，每道有选项 $a_i$ 个，每个选项成为正确答案的几率相同。今有一人答对了所有的单选题，但是第 $i$ 道的答案写在了第 $i + 1$ 道的位置上，特别的，第 $n$ 道写在了第 $1$ 道的位置上。求其期望答对的题数。\n\n$a_i$ 由以下方式生成：\n\n```c++\nfor (int i = 2; i <= n; i++) a[i] = ((long long) a[i - 1] * A + B) % 100000001;\nfor (int i = 1; i <= n; i++) a[i] = a[i] % C + 1\n```\n\n$1 \\leqslant n, \\; A, \\; B. \\; C, \\; a_1 \\leqslant 10,000,000$\n\n## 题目链接\n\n[【国家集训队】单选错位 - Luogu 1297](https://www.luogu.com.cn/problem/P1297)\n\n<!-- more -->\n\n## 题解\n\n记 $x = a_i, \\; y = a_{i  + 1}$。\n\n$x > y$：第 $i$ 道的答案有 $\\frac{y}x$ 的概率会有可能成为第 $i + 1$ 道的答案，又由各选项成为答案的几率相同，所以第 $i $ 道的答案填入第 $i + 1$ 道答案正确的概率是 $\\frac{y}x \\times \\frac{1}y = \\frac{1}x$。\n\n同理，$x \\leqslant y$ 时的概率为 $\\frac{1}y$。\n\n综上，答案为：\n$$\n\\sum_{i = 1}^{n} \\frac{1}{max(a_i, \\; a_{i + 1})} \\quad (a_{n + 1} = a_1)\n$$\n\n## 代码\n\n概率与期望入门题？概率与期望对我来说就是恐怖的存在。。。\n\n```c++\n#include <cstdio>\n#include <algorithm>\nint main() {\n    int n, A, B, C, a1;\n    scanf(\"%d %d %d %d %d\", &n, &A, &B, &C, &a1);\n    int x = a1, y;\n    double ans = 0;\n    for (int i = 1; i < n; i++) {\n        y = ((long long) x * A + B) % 100000001;\n        ans += 1.0 / std::max(x % C + 1, y % C + 1);\n        x = y;\n    }\n    ans += 1.0 / std::max(y % C + 1, a1 % C + 1);\n    printf(\"%.3lf\\n\", ans);\n}\n```","tags":["概率与期望"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2008] 硬币购物","url":"/BZOJ-1042-HAOI-2008-硬币购物/","content":"\n## 题目大意\n\n硬币购物一共有 $4$ 种硬币。面值分别为 $c_1$，$c_2$，$c_3$，$c_4$。某人去商店买东西，去了 $tot$ 次。每次带 $d_i$ 枚 $c_i$ 硬币，买 $s_i$ 的价值的东西。请问每次有多少种付款方法。\n\n$1 \\leqslant tot \\leqslant 1,000$\n\n$d_i, \\; s \\leqslant 10,000$\n\n## 题目链接\n\n[【HAOI 2008】硬币购物 - Luogu 1450](https://www.luogu.com.cn/problem/P1450)\n\n<!-- more -->\n\n## 题解\n\nDP + 容斥原理。\n\n记 $f[i, \\; j]$ 为用前 $i$ 种硬币凑出价值 $j$ 的方案数（不考虑硬币数量限制），则转移为：\n\n$$\nf[i, \\; j] = \n\\begin{cases}\n\\begin{align}\nf[i - 1, \\; j] \\quad &j < c_i \\\\\nf[i - 1, \\; j] + f[i - 1, \\; j - c_i] \\quad &j \\geqslant c_i\n\\end{align}\n\\end{cases}\n$$\n现考虑数量限制，用容斥原理：不考虑限制的方案数 - 考虑有一种硬币超过限制的方案数 + 考虑有两种硬币超过限制的方案数 - 考虑有三种硬币超过限制的方案数 + 考虑有四种硬币超过限制的方案数。\n\n对于考虑有一种硬币超过限制的方案数，我们让一种硬币先用 $d_i + 1$ 次，剩下的随意，那方案数就是：\n$$\nf[4, \\; s - (d_i + 1) \\times c_i]\n$$\n\n## 代码\n\n答案会超`int`。\n\n```c++\n#include <cstdio>\nconst int MAXS = 100005;\nint main() {\n    int c[5], tot;\n    scanf(\"%d %d %d %d %d\", &c[1], &c[2], &c[3], &c[4], &tot);\n    static long long f[5][MAXS];\n    f[0][0] = 1;\n    for (int i = 1; i <= 4; i++) for (int j = 0; j < MAXS; j++) {\n        if (j < c[i]) f[i][j] = f[i - 1][j];\n        else f[i][j] = f[i - 1][j] + f[i][j - c[i]];\n    }\n    while (tot--) {\n        int d[5], s;\n        scanf(\"%d %d %d %d %d\", &d[1], &d[2], &d[3], &d[4], &s);\n        long long ans = f[4][s];\n        for (int i = 1; i <= 4; i++) d[i]++;\n        for (int i = 1; i <= 4; i++) {\n            if (s - d[i] * c[i] >= 0) ans -= f[4][s - d[i] * c[i]];\n        }\n        for (int i = 1; i <= 4; i++) for (int j = i + 1; j <= 4; j++) {\n            if (s - d[i] * c[i] - d[j] * c[j] >= 0)\n                ans += f[4][s - d[i] * c[i] - d[j] * c[j]];\n        }\n        int temp = 0;\n        for (int i = 1; i <= 4; i++) temp += d[i] * c[i];\n        for (int i = 1; i <= 4; i++) {\n            if (s - temp + d[i] * c[i] >= 0)\n                ans -= f[4][s - temp + d[i] * c[i]];\n        }\n        if (s - temp >= 0) ans += f[4][s - temp];\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}\n```","tags":["DP","计数","容斥原理"],"categories":["题解（OI/XCPC）"]},{"title":"[POJ 3683] Priest John's Busiest Day","url":"/POJ-3683-Priest-John-s-Busiest-Day/","content":"\n## 题目大意\n\n给定 $n$ 对新人婚礼的时间范围（时间以 `hh:mm` 的形式给出）及婚礼时长，要求婚礼要么在时间范围的一开始举行，要么在最结尾时举行；同一时间只能举行一场婚礼。求是否可以举行所有的婚礼，可行的话输出合法方案。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n## 题目链接\n\n[POJ 3683](http://poj.org/problem?id=3683)\n\n<!-- more -->\n\n## 题解\n\n带输出方案的 2SAT，做一个板子吧。。。\n\n判断可行的部分就不多说了，当两个时间重叠时，变量关系是不同时选择。\n\n输出方案时，对图 Tarjan 缩点，反向连边，拓扑排序（当一个点被标记为选时，对应的点标记为不选并传递标记），最后按标记输出。\n\n## 代码\n\n用静态分配内存 `new(p++)` 神技，把 TLE 的代码（时限 2s）拉到了 172ms。。。\n\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n#include <new>\nconst int MAXN = 1005;\nconst int MAXM = 2000005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dfn, low, belong;\n    bool ins;\n} N[MAXN << 1];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n} _pool1[MAXM], *_cur1 = _pool1;\nvoid addEdge(int u, int v) {\n    N[u].e = new (_cur1++) Edge(&N[u], &N[v]);\n}\nint getV(int x, int k) {\n    return (x << 1) - k;\n}\nstruct TwoSat {\n    std::stack<Node *> s;\n    int dfsClock, sccCnt;\n    void tarjan(Node *u) {\n        s.push(u);\n        u->dfn = u->low = ++dfsClock;\n        u->ins = true;\n        for (Edge *e = u->e; e; e = e->next) {\n            if (e->v->dfn == 0) {\n                tarjan(e->v);\n                u->low = std::min(u->low, e->v->low);\n            } else if (e->v->ins) u->low = std::min(u->low, e->v->dfn);\n        }\n        if (u->dfn == u->low) {\n            Node *c;\n            sccCnt++;\n            while (true) {\n                c = s.top();\n                s.pop();\n                c->ins = false;\n                c->belong = sccCnt;\n                if (c == u) break;\n            }\n        }\n    }\n    bool check(int n) {\n        for (int i = 1; i <= n; i++)\n            if (N[getV(i, 0)].belong == N[getV(i, 1)].belong) return false;\n        return true;\n    }\n    bool operator()(int n) {\n        sccCnt = dfsClock = 0;\n        for (int i = 1; i <= n << 1; i++) if (N[i].dfn == 0) tarjan(&N[i]);\n        return check(n);\n    }\n} ts;\nstruct Pair {\n    int s, t;\n    Pair() {}\n    Pair(int s, int t) : s(s), t(t) {}\n    void print() {\n        printf(\"%.2d:%.2d %.2d:%.2d\\n\", s / 60, s % 60, t / 60, t % 60);\n    }\n} T[MAXN << 1];\nbool cross(const Pair &a, const Pair &b) {\n    return !((a.s >= b.t) || (b.s >= a.t));\n}\nvoid build(int n) {\n    for (int i = 1; i <= n; i++) for (int j = i + 1; j <= n; j++) {\n        for (int I = 0; I < 2; I++) for (int J = 0; J < 2; J++) {\n            if (cross(T[getV(i, I)], T[getV(j, J)])) {\n                addEdge(getV(i, I), getV(j, J ^ 1));\n                addEdge(getV(j, J), getV(i, I ^ 1));\n            }\n        }\n    }\n}\nstruct EdgeC;\nstruct NodeC {\n    EdgeC *e;\n    NodeC *opp;\n    int deg, mark;\n    NodeC() : mark(-1) {}\n} NC[MAXN << 1];\nstruct EdgeC {\n    NodeC *u, *v;\n    EdgeC *next;\n    EdgeC() {}\n    EdgeC(NodeC *u, NodeC *v) : u(u), v(v), next(u->e) {}\n} _pool2[MAXM], *_cur2 = _pool2;\nvoid addEdgeC(int u, int v) {\n    NC[u].e = new (_cur2++) EdgeC(&NC[u], &NC[v]);\n    NC[v].deg++;\n}\nvoid rebuild(int n) {\n    for (int i = 1; i <= n; i++) {\n        for (Edge *e = N[i].e; e; e = e->next) {\n            if (e->u->belong != e->v->belong) addEdgeC(e->v->belong, e->u->belong);\n        }\n    }\n}\nstruct TopoSort {\n    std::stack<NodeC *> s;\n    void dfs(NodeC *u) {\n        if (u->mark != -1) return;\n        u->mark = 0;\n        for (EdgeC *e; e; e = e->next) dfs(e->v);\n    }\n    void operator()(int n) {\n        for (int i = 1; i <= n; i++) if (NC[i].deg == 0) s.push(&NC[i]);\n        while (!s.empty()) {\n            NodeC *u = s.top();\n            s.pop();\n            // printf(\"\"); //加注释本机上会段错误，POJ上无影响。。。\n            if (u->mark != -1) continue;\n            u->mark = 1;\n            dfs(u->opp);\n            for (EdgeC *e = u->e; e; e = e->next) {\n                e->v->deg--;\n                if (e->v->deg == 0) s.push(e->v);\n            }\n        }\n    }\n} topoSort;\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 1; i <= n; i++) {\n        int sh, sm, th, tm, d;\n        scanf(\"%d:%d %d:%d %d\", &sh, &sm, &th, &tm, &d);\n        sh = sh * 60 + sm;\n        th = th * 60 + tm;\n        T[getV(i, 0)] = Pair(sh, sh + d);\n        T[getV(i, 1)] = Pair(th - d, th);\n    }\n    build(n);\n    if (!ts(n)) {\n        puts(\"NO\");\n        return 0;\n    }\n    puts(\"YES\");\n    rebuild(n << 1);\n    for (int i = 1; i <= n; i++) {\n        NC[N[getV(i, 0)].belong].opp = &NC[N[getV(i, 1)].belong];\n        NC[N[getV(i, 1)].belong].opp = &NC[N[getV(i, 0)].belong];\n    }\n    topoSort(ts.sccCnt);\n    for (int i = 1; i <= n; i++) {\n        int x = NC[N[getV(i, 0)].belong].mark;\n        T[getV(i, x ^ 1)].print();\n    }\n    return 0;\n}\n```","tags":["2SAT","模版"],"categories":["题解（OI/XCPC）"]},{"title":"[POJ 3207] Ikki's Story IV - Panda' Trick","url":"/POJ-3207-Ikki-s-Story-IV-Panda-Trick/","content":"\n## 题目大意\n\n有一个环上有 $n$ 个点，有 $m$ 条边连接其上的点，要求边要么在环内，要么在环外，求所有的边是否可以做到不相交。可以输出 `panda is telling the truth...`，不可以输出 `the evil panda is lying again`。\n\n点的编号从 $0$ 开始。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n$1 \\leqslant m \\leqslant 500$\n\n## 题目链接\n\n[POJ 3207](http://poj.org/problem?id=3207)\n\n<!-- more -->\n\n## 题解\n\n完全就是[Planar（平面图）](http://pepcy.cf/BZOJ-1997-HNOI-2010-Planar/)那道题。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\nconst int MAXN = 1005;\nconst int MAXM = 505;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dfn, low, belong;\n    bool ins;\n} N[MAXM << 1];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n    N[u].e = new Edge(&N[u], &N[v]);\n}\nint getV(int x, int k){\n    return (x << 1) - k;\n}\nstruct TwoSat {\n    std::stack<Node *> s;\n    int dfsClock, sccCnt;\n    void tarjan(Node *u) {\n        s.push(u);\n        u->dfn = u->low = ++dfsClock;\n        u->ins = true;\n        for (Edge *e = u->e; e; e = e->next) {\n            if (e->v->dfn == 0) {\n                tarjan(e->v);\n                u->low = std::min(u->low, e->v->low);\n            } else if (e->v->ins) u->low = std::min(u->low, e->v->dfn);\n        }\n        if (u->dfn == u->low) {\n            Node *c;\n            sccCnt++;\n            while (true) {\n                c = s.top();\n                s.pop();\n                c->ins = false;\n                c->belong = sccCnt;\n                if (c == u) break;\n            }\n        }\n    }\n    bool check(int n) {\n        for (int i = 1; i <= n; i++)\n            if (N[getV(i, 0)].belong == N[(getV(i, 1))].belong) return false;\n        return true;\n    }\n    bool operator()(int n) {\n        dfsClock = sccCnt = 0;\n        for (int i = 1; i <= n << 1; i++) if (N[i].dfn == 0) tarjan(&N[i]);\n        return check(n);\n    }\n} ts;\nstruct Pair {\n    int u, v;\n    Pair() {}\n    Pair(int u, int v) : u(u), v(v) {}\n} E[MAXM];\nbool cross(const Pair &a, const Pair &b) {\n    return (a.u < b.u && b.u < a.v && a.v < b.v) || \n           (b.u < a.u && a.u < b.v && b.v < a.v);\n}\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int top = 0;\n    for (int i = 1; i <= m; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        if (u > v) std::swap(u, v);\n        if (v - u <= 1 || (u == 0 && v == n - 1)) continue;\n        E[++top] = Pair(u, v);\n    }\n    m = top;\n    for (int i = 1; i <= m; i++) for (int j = i + 1; j <= m; j++) {\n        if (cross(E[i], E[j])) {\n            addEdge(getV(i, 0), getV(j, 1));\n            addEdge(getV(i, 1), getV(j, 0));\n            addEdge(getV(j, 0), getV(i, 1));\n            addEdge(getV(j, 1), getV(i, 0));\n        }\n    }\n    puts(ts(m) ? \"panda is telling the truth...\" : \"the evil panda is lying again\");\n    return 0;\n}\n```","tags":["2SAT"],"categories":["题解（OI/XCPC）"]},{"title":"2-SAT学习笔记","url":"/2-SAT学习笔记/","content":"\n首先安利一个博客：[传送门](http://blog.csdn.net/jarjingx/article/details/8521690)\n\n## 2-SAT介绍\n\n给出若干布尔变量及一些关于其中两个布尔变量的限制，求是否可行，可行则给出方案。\n\n<!-- more -->\n\n## 算法介绍\n\n### 建图\n\n对每一个布尔变量拆为两个点，分别表示真和假。点之间的有向边表示一个被确定了，另一个也**必须**被确定；当一个变量的两个点都被确定时，产生矛盾，返回不可行。\n\n限制的建边如下：\n\n* 两个变量不同为真\n\n若一个变量为真，则另一个必为假。\n\n用 $a$、$b$ 表示两个变量的真，$a'$、$b'$ 表示假，后同。\n\n$a \\rightarrow b', \\; b \\rightarrow a'$\n\n* 两个变量不同为假\n\n若一个变量为假，则另一个必为真。\n\n$a' \\rightarrow b, \\; b' \\rightarrow a$\n\n* 两个变量值相同\n\n若一个为某一个值，另一个必为同样的值。\n\n$a \\rightarrow b, \\; b \\rightarrow a , \\; a' \\rightarrow b', \\; b' \\rightarrow a'$\n\n* 两个变量值不同\n\n就是限制一加上限制二。。。\n\n### 算法过程\n\n#### 算法一：\n\n对一个变量，先认为它是真，dfs 一遍后若出现矛盾，就认为它是假，若仍有矛盾，则返回不可行。\n\n#### 算法二（常用算法）：\n\n首先，2-SAT 的图有这样的特点：\n\n> 若一个点被确定（选择），则其连出的点也被确定；若一个点被确定不选，则其父节点也不选。\n\n由此，我们得出来这样的结论：\n\n> 同一个强连通分量内的点，要么同时被选，要么同时被不选。\n\n故我们对 2-SAT 建的图跑 Tarjan，若有一个变量的两个点在同一个强连通分量内，则返回不可行。\n\n输出方案时，在 Tarjan 的基础上缩点，建立新图时，连边要连反向边，因为我们要传递的是不选择的标记，而不选择的标记是反向传递的（见前面的那条性质）。新图建完后，对图进行拓扑排序，具体的过程是：把入度为 $0$ 的点放入栈（队列也行，因为取出顺序无所谓），每次取出一个节点（如果还没标记的话，后同）标记为选择，同时标记对应的点为不选择，从对应点开始 dfs，沿路均标记为不选择，对于原来取出的点，其连出的边指向的点入度减一（即相当于删除这条边），当出现入度为 $0$ 的点时，放入栈中。最后按标记输出方案。\n\n## 模版题\n\n[【JSOI 2010】满汉全席 - Luogu 4171](https://www.luogu.com.cn/problem/P4171)（[题解](http://pepcy.cf/BZOJ-1823-JSOI-2010-满汉全席/)）（不输出方案）\n\n[POJ 3683](http://poj.org/problem?id=3683) （[题解](http://pepcy.cf/POJ-3683-Priest-John-s-Busiest-Day/)）（输出方案）","tags":["2SAT","学习笔记"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[HNOI 2010] 平面图判定","url":"/BZOJ-1997-HNOI-2010-Planar/","content":"\n## 题目大意\n\n给定包含一个哈密顿回路的图，求其是否为可平面图。多组询问。\n\n$1 \\leqslant T \\leqslant 100$\n\n$3 \\leqslant n \\leqslant 200$\n\n$m \\leqslant 10,000$\n\n## 题目链接\n\n[【HNOI 2010】平面图判定](https://www.luogu.com.cn/problem/P3209)\n\n<!-- more -->\n\n## 题解\n\n首先给出图论上的一个定理：\n\n> 一个图为可平面图，当且仅当  $m \\leqslant 3n - 6$。\n\n这样我们可以只处理 $m \\leqslant 594$ 的情况。（学校为了数竞党们请来的图论老师对 OI 还是有用的嘛）\n\n剩下的为 2-SAT。\n\n不是构成哈密顿回路的边为布尔变量，边画在回路内部还是外部对应真或假，对于可能会交叉的边必须一内一外。\n\n## 代码\n\n本题是在满汉全席之前写的，所以代码比满汉全席丑。。。（满汉全席是当板子写的，自然要好看一些啊）\n\n另外，一开始没有写 `inq` 数组及相关的内容，居然就 AC 了。。。\n\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 205;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dfn, low, belong;\n    bool inq;\n} N[MAXN * 3 * 2];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n#ifdef DBG\n    printf(\"edge : %d -- %d\\n\", u, v);\n#endif\n    N[u].e = new Edge(&N[u], &N[v]);\n    N[v].e = new Edge(&N[v], &N[u]);\n}\nint vTrue(int x) {\n    return (x << 1) - 1;\n}\nint vFalse(int x) {\n    return x << 1;\n}\nint sccCnt, dfsClock;\nstd::stack<Node *> s;\nvoid tarjan(Node *u) {\n    s.push(u);\n    u->inq = true;\n    u->dfn = u->low = ++dfsClock;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->v->dfn == 0) {\n            tarjan(e->v);\n            u->low = std::min(u->low, e->v->low);\n        } else u->low = std::min(u->low, e->v->dfn);\n    }\n    if (u->dfn == u->low) {\n        Node *c;\n        sccCnt++;\n        while (true) {\n            c = s.top();\n            s.pop();\n            c->belong = sccCnt;\n            c->inq = false;\n            if (c == u) break;\n        }\n    }\n}\nstruct Pair {\n    int u, v;\n    Pair() {}\n    Pair(int u, int v) : u(u), v(v) {}\n} E[MAXN * 3];\nbool cross(const Pair &a, const Pair &b) {\n    return (a.u < b.u && b.u < a.v && a.v < b.v) || \n           (b.u < a.u && a.u < b.v && b.v < a.v);\n}\nint c[MAXN], pos[MAXN];\nbool check(int m) {\n    for (int i = 1; i <= m; i++) \n        if (N[vTrue(i)].belong == N[vFalse(i)].belong) return false;\n    return true;\n}\nvoid clearGraph(int n) {\n    for (int i = 1; i <= n; i++) {\n        for (Edge *&e = N[i].e, *next; e; next = e->next, delete e, e = next);\n        N[i].low = N[i].dfn = N[i].belong = 0;\n        N[i].inq = false;\n    }\n}\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        if (m > 3 * n - 6) {\n            for (int i = 0; i < m; i++) scanf(\"%*d %*d\");\n            for (int i = 0; i < n; i++) scanf(\"%*d\");\n            puts(\"NO\");\n            continue;\n        }\n        for (int i = 1; i <= m; i++) scanf(\"%d %d\", &E[i].u, &E[i].v);\n        for (int i = 1; i <= n; i++) scanf(\"%d\", &c[i]), pos[c[i]] = i;\n        int top = 0;\n        for (int i = 1; i <= m; i++) {\n            E[i].u = pos[E[i].u];\n            E[i].v = pos[E[i].v];\n            if (E[i].u > E[i].v) std::swap(E[i].u, E[i].v);\n            if (E[i].v - E[i].u <= 1 || (E[i].u == 1 && E[i].v == n)) continue;\n            E[++top] = Pair(E[i].u, E[i].v);\n        }\n        m = top;\n#ifdef DBG\n        printf(\"top = %d\\n\", top);\n#endif\n        clearGraph(m << 1);\n        for (int i = 1; i <= m; i++) for (int j = i + 1; j <= m; j++) {\n            if (cross(E[i], E[j])) {\n                addEdge(vTrue(i), vFalse(j));\n                addEdge(vFalse(i), vTrue(j));\n            }\n        }\n        sccCnt = dfsClock = 0;\n        while (!s.empty()) s.pop();\n        for (int i = 1; i <= m << 1; i++) if (N[i].dfn == 0) tarjan(&N[i]);\n#ifdef DBG\n        for (int i = 1; i <= m; i++) \n            printf(\"i = %d, true : %d, false : %d\\n\", \n                   i, N[vTrue(i)].belong, N[vFalse(i)].belong);\n#endif\n        puts(check(m) ? \"YES\" : \"NO\");\n    }\n    return 0;\n}\n```","tags":["2SAT"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2010] 满汉全席","url":"/BZOJ-1823-JSOI-2010-满汉全席/","content":"\n## 题目大意\n\n给定 $n$ 种材料，对于每种材料，有满式、汉式两种做法（一种材料只能选择一种做法）。有 $m$ 个评委，每个评委有两道要求的菜（菜由一种材料加一种做法构成），这两道菜至少要做出一道才能让评委满意。现询问是否能让所有评委满意，能输出 `GOOD`，不能输出 `BAD`。多组询问。\n\n$1 \\leqslant T \\leqslant 50$\n\n$1 \\leqslant n \\leqslant 100$\n\n$1 \\leqslant m \\leqslant 1,000$\n\n## 题目链接\n\n[【JSOI 2010】满汉全席 - Luogu 4171](https://www.luogu.com.cn/problem/P4171)\n\n<!-- more -->\n\n## 题解\n\n2-SAT 裸题。\n\n每种材料为一个布尔变量，两种做法对应变量的真和假，评委对应变量间的关系。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <stack>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 105;\nconst int MAXM = 1005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int dfn, low, belong;\n    bool inq;\n} N[MAXN << 1];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge(Node *u, Node *v) : u(u), v(v), next(u->e) {}\n};\nvoid addEdge(int u, int v) {\n#ifdef DBG\n    printf(\"edge : %d --> %d\\n\", u, v);\n#endif\n    N[u].e = new Edge(&N[u], &N[v]);\n}\nvoid clearGraph(int n) {\n    for (int i = 1; i <= n; i++) {\n        for (Edge *&e = N[i].e, *next; e; next = e->next, delete e, e = next);\n        N[i].low = N[i].dfn = N[i].belong = 0;\n        N[i].inq = false;\n    }\n}\nint getV(int x, int k) {\n    return (x << 1) - k;\n}\nstruct twoSat {\n    std::stack<Node *> s;\n    int dfsClock, sccCnt;\n    void tarjan(Node *u) {\n        s.push(u);\n        u->inq = true;\n        u->dfn = u->low = ++dfsClock;\n        for (Edge *e = u->e; e; e = e->next) {\n            if (e->v->dfn == 0) {\n                tarjan(e->v);\n                u->low = std::min(u->low, e->v->low);\n            } else if (e->v->inq) u->low = std::min(u->low, e->v->dfn);\n        }\n        if (u->dfn == u->low) {\n            Node *c;\n            sccCnt++;\n            while (true) {\n                c = s.top();\n                s.pop();\n                c->belong = sccCnt;\n                c->inq = false;\n                if (c == u) break;\n            }\n        }\n    }\n    bool check(int n) {\n        for (int i = 1; i <= n; i++) \n            if (N[getV(i, 0)].belong == N[getV(i, 1)].belong) return false;\n        return true;\n    }\n    bool operator()(int n) {\n        dfsClock = sccCnt = 0;\n        while (!s.empty()) s.pop();\n        for (int i = 1; i <= n << 1; i++) if (N[i].dfn == 0) tarjan(&N[i]);\n#ifdef DBG\n        printf(\"sccCnt = %d\\n\", sccCnt);\n#endif\n        return check(n);\n    }\n} ts;\nint parseInt(char *s) {\n    int res = 0;\n    for (char *p = s; *p; p++) res = res * 10 + *p - '0';\n    return res;\n}\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, m;\n        scanf(\"%d %d\", &n, &m);\n        clearGraph(n << 1);\n        for (int i = 1; i <= m; i++) {\n            char kx[5], ky[5];\n            int x, y, xv, yv;\n            scanf(\"%s\", kx);\n            x = parseInt(kx + 1);\n            scanf(\"%s\", ky);\n            y = parseInt(ky + 1);\n            xv = kx[0] == 'm';\n            yv = ky[0] == 'm';\n            addEdge(getV(x, xv ^ 1), getV(y, yv));\n            addEdge(getV(y, yv ^ 1), getV(x, xv));\n        }\n        puts(ts(n) ? \"GOOD\" : \"BAD\");\n    }\n    return 0;\n}\n```","tags":["2SAT","模版"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2013] 快餐店","url":"/BZOJ-3242-NOI-2013-快餐店/","content":"\n## 题目大意\n\n给定一个 $n$ 个节点的环套树，每个边有一个边权。现要找一个点，使得所有的点到这个点的距离的最大值最小，这个点可以在节点上，也可以在边上。求最小的最大值。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant w \\leqslant 1,000,000,000$ （边权）\n\n## 题目链接\n\n[【NOI 2013】快餐店 - LibreOJ 2669](https://loj.ac/problem/2669)\n\n[【NOI 2013】快餐店 - UOJ 126](http://uoj.ac/problem/126)\n\n<!-- more -->\n\n## 题解\n\n最大值的点一定有两个，快餐店在其中点。如果是树，答案就是直径除以 $2$；现在要求环套树上的，可以考虑删去环上的一条边成为树，答案中的最小值就是最终答案，然而这样会 TLE。\n\n这些直径中，有的会在环的外面（即链上没有环上的边），另一些则经过环，考虑分开计算。\n\n用类似 DP 的方法从环上的点向环外做 dfs，期间可以求出第一类的最长链。\n\n对于第二种，在环上用类似 DP 的方法求出以环的头／尾（从头和从尾各枚举一遍）为起点的最长链（代码中以数组 `lenFromSt`、`lenFromEd` 表示）、在头／尾与当前枚举到的节点间经过环的最长链（在代码中以 `chainOnCircleFromSt`、`chainOnCircleFromEd` 表示），最后枚举删去环上的哪一条边，利用刚刚算出的四个数组计算出第二类的答案。\n\n感觉不错的题。。。对着题解理解了许久（我好菜啊.jpg）。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    Node *fa;\n    int dfn, len;\n    long long f;\n    bool onCircle;\n} N[MAXN], *C[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n};\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].e = new Edge(&N[v], &N[u], w);\n}\nint circleCnt;\nvoid dfs(Node *u) {\n    static int dfsClock = 0;\n    u->dfn = ++dfsClock;\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->v == u->fa) continue;\n        if (e->v->dfn == 0) {\n            e->v->fa = u;\n            e->v->len = e->w;\n            dfs(e->v);\n        } else if (e->v->dfn > u->dfn) {\n            for (Node *c = e->v; c != u; c = c->fa) {\n                C[++circleCnt] = c;\n                c->onCircle = true;\n#ifdef DBG\n                printf(\"circleCnt = %d, len = %d\\n\", circleCnt, C[circleCnt]->len);\n#endif\n            }\n            C[++circleCnt] = u;\n            u->len = e->w;\n            u->onCircle = true;\n#ifdef DBG\n            printf(\"circleCnt = %d, len = %d\\n\", circleCnt, C[circleCnt]->len);\n#endif\n \n        }\n    }\n}\nlong long ans1;\nvoid dfs(Node *u, Node *fa) {\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->v == fa || e->v->onCircle) continue;\n        dfs(e->v, u);\n        ans1 = std::max(ans1, u->f + e->v->f + e->w);\n        u->f = std::max(u->f, e->v->f + e->w);\n    }\n}\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        addEdge(u, v, w);\n    }\n    dfs(&N[1]);\n    for (int i = 1; i <= circleCnt; i++) dfs(C[i], NULL);\n    long long sum = 0, maxTemp = 0;\n    static long long lenFromSt[MAXN], chainOnCircleFromSt[MAXN];\n    for (int i = 1; i <= circleCnt; i++) {\n        sum += i == 1 ? 0 : C[i - 1]->len;\n        lenFromSt[i] = std::max(lenFromSt[i - 1], sum + C[i]->f);\n        chainOnCircleFromSt[i] = std::max(chainOnCircleFromSt[i - 1], \n                                          C[i]->f + sum + maxTemp);\n        maxTemp = std::max(maxTemp, C[i]->f - sum);\n#ifdef DBG\n        printf(\"from st - (%d): len = %lld, chain = %lld\\n\", i, lenFromSt[i], chainOnCircleFromSt[i]);\n#endif\n    }\n    sum = maxTemp = 0;\n    static long long lenFromEd[MAXN], chainOnCircleFromEd[MAXN];\n    int temp = C[circleCnt]->len;\n#ifdef DBG\n    printf(\"temp = %d\\n\", temp);\n#endif\n    C[circleCnt]->len = 0;\n    for (int i = circleCnt; i; i--) {\n        sum += C[i]->len;\n        lenFromEd[i] = std::max(lenFromEd[i + 1], sum + C[i]->f);\n        chainOnCircleFromEd[i] = std::max(chainOnCircleFromEd[i + 1], \n                                          C[i]->f + sum + maxTemp);\n        maxTemp = std::max(maxTemp, C[i]->f - sum);\n#ifdef DBG\n        printf(\"from ed - (%d): len = %lld, chain = %lld\\n\", i, lenFromEd[i], chainOnCircleFromEd[i]);\n#endif\n    }\n    long long ans2 = chainOnCircleFromSt[circleCnt];\n    for (int i = 1; i < circleCnt; i++) {\n        ans2 = std::min(ans2, \n            std::max(std::max(chainOnCircleFromSt[i], \n                              chainOnCircleFromEd[i + 1]), \n                     lenFromSt[i] + temp + lenFromEd[i + 1]));\n#ifdef DBG\n        printf(\"i = %d\\nmax{%lld, %lld, %lld}\\n\", i ,\n               chainOnCircleFromSt[i], chainOnCircleFromEd[i + 1], \n               lenFromSt[i] + temp + lenFromEd[i + 1]);\n#endif\n    }\n#ifdef DBG\n    printf(\"ans1 = %lld, ans2 = %lld\\n\", ans1, ans2);\n#endif\n    double ans = std::max(ans1, ans2) / 2.0;\n    printf(\"%.1lf\\n\", ans);\n    return 0;\n}\n```","tags":["环套树","DFS","图"],"categories":["题解（OI/XCPC）"]},{"title":"已经没有什么好害怕的了","url":"/BZOJ-3622-已经没有什么好害怕的了/","content":"\n## 题目大意\n\n给定两个长为 $n$ 的序列 $a$ 和 $b$（$2n$ 个数互不相同），求有多少种匹配方案满足 $a_i > b_i$ 的组数比 $a_i < b_i$ 的组数多 $k$ 个。\n\n$1 \\leqslant n \\leqslant 2,000$\n\n## 题目链接\n\n[已经没有什么好害怕的了 - Luogu 4859](https://www.luogu.com.cn/problem/P4859)\n\n## 题解\n\n补完魔圆后再看一遍这道题。。。\n\n首先，$n$ 为奇数时答案为 $0$。\n\n对两个序列排序，定义 $next[i]$ 表示最大的满足 $a_i > b_j$ 的 $j$，考虑 DP，设 $f[i, \\; j]$ 表示已经考虑了 $a$ 中前 $i$ 个数，找到 $j$ 个 $b$ 中的数使得这些数均比 $a$ 中的 $i$ 个数小的方案数（其余不管），则转移为：\n$$\nf[i, \\; j] = f[i - 1, \\; j] + f[i - 1, \\; j - 1] \\times (next[i] - (j - 1)) \\quad f[i, \\; 0] = 1(i = 1, \\; 2, \\; 3 \\dots,\\;n)\n$$\n当然，这不是最终答案，因为在计算 $f$ 时，剩下的是不管的，所以会重算，我们在减去即可。记 $g[n, \\; i]$ 表示 $b$ 中正好有 $i$ 个数比对应的 $a$ 的值小的匹配数，有：\n$$\ng[n, \\; i] = f[n, \\; i] \\times (n - i)! - \\sum_{j = i + 1}^{n} g[n, \\; j] * \\binom{j}{i}\n$$\n计算时，对于每一个 $j$，我们减去有 $j$ 个数小的答案却被记入 $i$ 个数中的个数，也就是在正好 $j$ 个数中选 $i$ 个继续匹配的个数。\n\n## 代码\n\n由于我们只需计算 $g[n, \\; i]$，故数组 $g$ 只需一维。\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 2005;\nconst int MOD = 1e9 + 9;\nint a[MAXN], b[MAXN], next[MAXN];\nlong long fac[MAXN], combin[MAXN][MAXN];\nvoid calc(int n) {\n    fac[0] = 1;\n    for (int i = 1; i <= n; i++) fac[i] = fac[i - 1] * i % MOD;\n    for (int i = 0; i <= n; i++) {\n        combin[i][0] = 1;\n        for (int j = 1; j <= i; j++) \n            combin[i][j] = (combin[i - 1][j] + combin[i - 1][j - 1]) % MOD;\n    }\n}\nlong long f[MAXN][MAXN];\nvoid dp(int n) {\n    f[0][0] = 1;\n    for (int i = 1; i <= n; i++) {\n        f[i][0] = 1;\n        for (int j = 1; j <= i; j++) \n            f[i][j] = (f[i - 1][j] + \n                       f[i - 1][j - 1] * std::max(next[i] - j + 1, 0)) % MOD;\n    }\n}\nint main() {\n    int n, k;\n    scanf(\"%d %d\", &n, &k);\n    if ((n + k) & 1) {\n        puts(\"0\");\n        return 0;\n    }\n    int s = (n + k) >> 1;\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n    for (int i = 1; i <= n; i++) scanf(\"%d\", &b[i]);\n    std::sort(a + 1, a + n + 1);\n    std::sort(b + 1, b + n + 1);\n    for (int i = 1, j = 1; i <= n; i++) {\n        while (j <= n && a[i] > b[j]) j++;\n        next[i] = j - 1;\n    }\n#ifdef DBG\n    puts(\"next :\");\n    for (int i = 1; i <= n; i++) printf(\" %d\", next[i]);\n    puts(\"\");\n#endif\n    dp(n);\n#ifdef DBG\n    puts(\"dp - f :\");\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= i; j++) printf(\"f[%d][%d] = %lld \", i, j, f[i][j]);\n        puts(\"\");\n    }\n#endif\n    calc(n);\n    static long long g[MAXN];\n    for (int i = n; i >= s; i--) {\n        g[i] = f[n][i] * fac[n - i] % MOD;\n        for (int j = i + 1; j <= n; j++) \n            g[i] = (g[i] + MOD - g[j] * combin[j][i] % MOD) % MOD;\n#ifdef DBG\n        printf(\"g[%d] = %lld\\n\", i, g[i]);\n#endif\n    }\n    printf(\"%lld\\n\", g[s]);\n    return 0;\n}\n```","tags":["DP","计数"],"categories":["题解（OI/XCPC）"]},{"title":"[国家集训队] happiness","url":"/BZOJ-2127-happiness/","content":"\n## 题目大意\n\n班级可视为 $n \\times m$ 的矩阵，现进行文理分科。\n\n* 位置 $[i, \\; j]$ 的人选文科会获得满意值 $art[i, \\; j]$，选理科会获得 $science[i, \\; j]$。\n* 位置 $[i, \\; j]$ 的人及其下面的人均选择文科会额外获得满意值 $artColumn[i, \\; j]$，均选择理科会额外获得 $scienceColumn[i, \\; j]$。\n* 位置 $[i, \\; j]$的人及其右面的人均选择文科会额外获得满意值 $artRow[i, \\; j]$，均选择理科会额外获得 $scienceRow[i, \\; j]$。\n\n求最大满意值。\n\n$1 \\leqslant n, \\; m \\leqslant 100$\n\n其他数据 $\\leqslant 5,000$\n\n（直接从文理分科复制过来改了改。。。）\n\n## 题目链接\n\n[【国家集训队】happiness - Luogu 1646](https://www.luogu.com.cn/problem/P1646)\n\n<!-- more -->\n\n## 题解\n\n最大权闭合图。\n\n先让所有人选择文科。\n\n每个人拆为 $5$ 个节点，分别表示改选理科满意值的变化量、改选后文科列额外满意值的损失量、改选后理科列额外满意值的增加量、改选后文科行额外满意值的损失量、改选后理科行额外满意值的增加量，分别记为节点种类 $1 \\sim 5$。对于每一个节点 $1$，向其自己与下面的人的节点 $2$ 连边，向其自己与右面的人的节点 $4$；从其自己与下面的人的节点 $3$、其自己与右面的人的节点 $5$ 向该节点的节点 $1$ 连边。\n\n（继续复制。。。）\n\n文理分科的姊妹篇吗（说来这个的题号在文理分科前啊。。。）。。。\n\n## 代码\n\n代码中的行 R(row) 和列 C(column) 写反了。。。写之前还专门查的。。。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 105;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN * 5];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nstruct Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int operator()(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n} dinic;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int sum = 0;\n    static int a[MAXN][MAXN], b[MAXN][MAXN], aR[MAXN][MAXN], bR[MAXN][MAXN], aC[MAXN][MAXN], bC[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &a[i][j]), sum += a[i][j];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &b[i][j]);\n    for (int i = 1; i < n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &aR[i][j]), sum += aR[i][j];\n    for (int i = 1; i < n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &bR[i][j]);\n    for (int i = 1; i <= n; i++) for (int j = 1; j < m; j++) \n        scanf(\"%d\", &aC[i][j]), sum += aC[i][j];\n    for (int i = 1; i <= n; i++) for (int j = 1; j < m; j++) \n        scanf(\"%d\", &bC[i][j]);\n    int index = 0;\n    static int id[MAXN][MAXN][5];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k < 5; k++) \n        id[i][j][k] = ++index;\n    const int s = 0, t = n * m * 5 + 1;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int x = b[i][j] - a[i][j];\n        if (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n        else addEdge(id[i][j][0], t, -x);\n        if (i != n) {\n            addEdge(id[i][j][1], t, aR[i][j]);\n            addEdge(s, id[i][j][2], bR[i][j]), sum += bR[i][j];\n            addEdge(id[i][j][2], id[i][j][0], INT_MAX);\n            addEdge(id[i][j][2], id[i + 1][j][0], INT_MAX);\n            addEdge(id[i][j][0], id[i][j][1], INT_MAX);\n            addEdge(id[i + 1][j][0], id[i][j][1], INT_MAX);\n        }\n        if (j != m) {\n            addEdge(id[i][j][3], t, aC[i][j]);\n            addEdge(s, id[i][j][4], bC[i][j]), sum += bC[i][j];\n            addEdge(id[i][j][4], id[i][j][0], INT_MAX);\n            addEdge(id[i][j][4], id[i][j + 1][0], INT_MAX);\n            addEdge(id[i][j][0], id[i][j][3], INT_MAX);\n            addEdge(id[i][j + 1][0], id[i][j][3], INT_MAX);\n        }\n    }\n    printf(\"%d\\n\", sum - dinic(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割","最大权闭合图"],"categories":["题解（OI/XCPC）"]},{"title":"文理分科","url":"/BZOJ-3894-文理分科/","content":"\n## 题目大意\n\n班级可视为 $n \\times m$ 的矩阵，现进行文理分科。\n\n* 位置 $[i, \\; j]$ 的人选文科会获得满意值 $art[i, \\; j]$，选理科会获得 $science[i, \\; j]$。\n* 位置 $[i, \\; j]$ 的人及其四周的人均选择文科会额外获得满意值 $artSame[i, \\; j]$，均选择理科会额外获得 $scienceSame[i, \\; j]$。\n\n求最大满意值。\n\n$1 \\leqslant n, \\; m \\leqslant 100$\n\n$其他数据 \\leqslant 500$\n\n## 题目链接\n\n[文理分科 - Luogu 4313](https://www.luogu.com.cn/problem/P4313)\n\n<!-- more -->\n\n## 题解\n\n最大权闭合子图。\n\n先让所有人选择文科。\n\n每个人拆为 $3$ 个节点，分别表示改选理科满意值的变化量、改选后文科额外满意值的损失量、改选后理科额外满意值的增加量，分别记为节点种类 $1$、$2$、$3$。对于每一个节点 $1$，向其自己与周围四人的节点 $2$ 连边，从其自己与周围四人的节点 $3$ 向该节点的节点 $1$ 连边。\n\n话说文科为什么会是 art 啊。。。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\nconst int MAXN = 105;\nstruct Edge;\nstruct Node {\n    Edge *e, *curr;\n    int level;\n} N[MAXN * MAXN * 3];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    int cap, flow;\n    Edge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0), next(u->e) {}\n};\nvoid addEdge(int u, int v, int cap) {\n    N[u].e = new Edge(&N[u], &N[v], cap);\n    N[v].e = new Edge(&N[v], &N[u], 0);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nstruct Dinic {\n    bool makeLevelGraph(Node *s, Node *t, int n) {\n        for (int i = 0; i < n; i++) N[i].level = 0;\n        std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n            for (Edge *e = u->e; e; e = e->next) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    if (e->v == t) return true;\n                    q.push(e->v);\n                }\n            }\n        }\n        return false;\n    }\n    int findPath(Node *s, Node *t, int limit = INT_MAX) {\n        if (s == t) return limit;\n        for (Edge *&e = s->curr; e; e = e->next) {\n            if (e->cap > e->flow && e->v->level == s->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->rev->flow -= flow;\n                    return flow;\n                }\n            }\n        }\n        return 0;\n    }\n    int operator()(int s, int t, int n) {\n        int res = 0;\n        while (makeLevelGraph(&N[s], &N[t], n)) {\n            for (int i = 0; i < n; i++) N[i].curr = N[i].e;\n            int flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n} dinic;\nint main() {\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    int sum = 0;\n    static int sci[MAXN][MAXN], art[MAXN][MAXN], sciSame[MAXN][MAXN], artSame[MAXN][MAXN];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++)\n        scanf(\"%d\", &art[i][j]), sum += art[i][j];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &sci[i][j]);\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &artSame[i][j]), sum += artSame[i][j];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) \n        scanf(\"%d\", &sciSame[i][j]);\n    int index = 0;\n    static int id[MAXN][MAXN][3];\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) for (int k = 0; k < 3; k++) \n        id[i][j][k] = ++index;\n    const int s = 0, t = n * m * 3 + 1;\n    for (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n        int x = sci[i][j] - art[i][j];\n        if (x > 0) addEdge(s, id[i][j][0], x), sum += x;\n        else addEdge(id[i][j][0], t, -x);\n        addEdge(id[i][j][1], t, artSame[i][j]);\n        addEdge(s, id[i][j][2], sciSame[i][j]), sum += sciSame[i][j];\n        addEdge(id[i][j][0], id[i][j][1], INT_MAX);\n        addEdge(id[i][j][2], id[i][j][0], INT_MAX);\n        if (i != 1) {\n            addEdge(id[i][j][0], id[i - 1][j][1], INT_MAX);\n            addEdge(id[i - 1][j][2], id[i][j][0], INT_MAX);\n        }\n        if (i != n) {\n            addEdge(id[i][j][0], id[i + 1][j][1], INT_MAX);\n            addEdge(id[i + 1][j][2], id[i][j][0], INT_MAX);\n        }\n        if (j != 1) {\n            addEdge(id[i][j][0], id[i][j - 1][1], INT_MAX);\n            addEdge(id[i][j - 1][2], id[i][j][0], INT_MAX);\n        }\n        if (j != m) {\n            addEdge(id[i][j][0], id[i][j + 1][1], INT_MAX);\n            addEdge(id[i][j + 1][2], id[i][j][0], INT_MAX);\n        }\n    }\n    printf(\"%d\\n\", sum - dinic(s, t, t + 1));\n    return 0;\n}\n```","tags":["网络流","最小割","最大权闭合图"],"categories":["题解（OI/XCPC）"]},{"title":"上帝与集合的正确用法","url":"/BZOJ-3884-上帝与集合的正确用法/","content":"\n## 题目大意\n\n求：\n$$\n无数个2 \\left\\{ 2 ^{2^{2^{2^{2^{2 \\cdots}}}}} \\right. \\bmod \\; p\n$$\n多组询问。\n\n$1 \\leqslant T \\leqslant 1,000$\n\n$1 \\leqslant p \\leqslant 10,000,000$\n\n## 题目链接\n\n[上帝与集合的正确用法 - Luogu 4139](https://www.luogu.com.cn/problem/P4139)\n\n<!-- more -->\n\n## 题解\n\n对 $p$ 分解为 $p = 2^k q$，$q$ 为奇数，与 $2$ 互质，那么有：\n$$\n\\begin{align}\n2^{2^{2^{2 \\cdots}}} \\bmod \\; p &= 2^k (2^{2^{2^{2 \\cdots}} - k} \\bmod \\; q) \\\\\n&= 2^k (2^{(2^{2^{2 \\cdots}} - k) \\bmod \\; \\varphi (q)} \\bmod \\; q)\n\\end{align}\n$$\n指数部分与原式相同，模数变小（至少除以 $2$），故可以递归计算。模数最终会变为 $1$，而任何数模 $1$ 均为 $0$。\n\n## 代码\n\n```c++\n#include <cstdio>\nint phi(int x) {\n    int res = x;\n    for (int i = 2; i * i <= x; i++) {\n        if (x % i == 0) {\n            res = res / i * (i - 1);\n            while (x % i == 0) x /= i;\n        }\n    }\n    if (x > 1) res = res / x * (x - 1);\n    return res;\n}\nint pow(long long a, int n, int mod) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % mod) if (n & 1) res = res * a % mod;\n    return (int) res % mod;\n}\nint solve(int p) {\n    if (p == 1) return 0;\n    int k = 0;\n    while ((p & 1) == 0) p >>= 1, k++;\n    int phiQ = phi(p);\n    int temp = (solve(phiQ) - k % phiQ + phiQ) % phiQ;\n    int res = pow(2, temp, p);\n    return res << k;\n}\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int p;\n        scanf(\"%d\", &p);\n        printf(\"%d\\n\", solve(p));\n    }\n    return 0;\n}\n```","tags":["数论","欧拉定理"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2012] 随机数生成器","url":"/BZOJ-2875-NOI-2012-随机数生成器/","content":"\n## 题目大意\n\n给定 $m$、$a$、$x_0$、$c$、$n$、$g$，求递推式的第 $n$ 项模 $g$ 的余数：\n$$\nx_{n + 1} \\equiv a x_n + c \\; (\\bmod m)\n$$\n$1 \\leqslant n, \\; m, \\; g \\; \\leqslant 100,000,000$\n\n$0 \\leqslant x_0, \\; a, \\; c \\; \\leqslant 100,000,000$\n\n（数据范围好像是这样。。。）\n\n## 题目链接\n\n[【NOI 2012】随机数生成器 - LibreOJ 2670](https://loj.ac/problem/2670)\n\n<!-- more -->\n\n## 题解\n\n矩阵乘法 + 快速幂。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cstring>\nlong long mod;\nstruct Matrix {\n\tlong long a[2][2];\n\tMatrix(const bool unit) {\n\t\tmemset(a, 0, sizeof (a));\n\t\tif (unit) for (int i = 0; i < 2; i++) a[i][i] = 1;\n\t}\n\tlong long &operator()(const int i, const int j) {\n\t\treturn a[i][j];\n\t}\n\tconst long long &operator()(const int i, const int j) const {\n\t\treturn a[i][j];\n\t}\n};\nlong long mul(long long a, long long b) {\n\tlong long res = 0;\n\tfor (; b; b >>= 1, a = (a + a) % mod) if (b & 1) res = (res + a) % mod;\n\treturn res;\n}\nMatrix operator*(const Matrix &a, const Matrix &b) {\n\tMatrix res(false);\n\tfor (int i = 0; i < 2; i++) \n        for (int j = 0; j < 2; j++) \n            for (int k = 0; k < 2; k++) \n                (res(i, j) += mul(a(i, k), b(k, j))) %= mod;\n\treturn res;\n}\nMatrix pow(Matrix a, long long n) {\n\tMatrix res(true);\n\tfor (; n; n >>= 1, a = a * a) if (n & 1) res = res * a;\n\treturn res;\n}\nint main() {\n\tlong long a, c, x, n, g;\n\tscanf(\"%lld%lld%lld%lld%lld%lld\", &mod, &a, &c, &x, &n, &g);\n\tMatrix init(false);\n\tinit(0, 0) = x;\n\tinit(1, 0) = c;\n\tMatrix shift(false);\n\tshift(0, 0) = a;\n\tshift(0, 1) = 1;\n\tshift(1, 0) = 0;\n\tshift(1, 1) = 1;\n\tMatrix res = pow(shift, n) * init;\n\tprintf(\"%lld\\n\", res(0, 0) % g);\n}\n```","tags":["矩阵乘法"],"categories":["题解（OI/XCPC）"]},{"title":"[JSOI 2008] 魔兽地图","url":"/BZOJ-1017-JSOI-2008-魔兽地图DotR/","content":"\n## 题目大意\n\n给定 $n$ 个装备和数量为 $m$ 的金钱，求可获得的最大力量。其中，每个装备有一个力量值，同时装备分为基本装备和高级装备，基本装备给定了价格和数量限制，高级装备需要一些其他装备来合成（需要哪些、需要几个已给定）。\n\n$1 \\leqslant n \\leqslant 51$\n\n$1 \\leqslant m \\leqslant 2,000$\n\n$1 \\leqslant limit \\leqslant 100$（数量限制）\n\n## 题目链接\n\n[【JSOI 2008】魔兽地图 - Luogu 4037](https://www.luogu.com.cn/problem/P4037)\n\n<!-- more -->\n\n## 题解\n\n树形 DP。\n\n对于每一个节点 $x$，有一个 $f[i, \\; j]$，表示花费 $j$ 的金钱、有 $i$ 个 $x$ 被用于合成高一级的装备时的最大力量。在转移时，定义一个辅助数组 $g[i, \\; j]$，表示当前节点的子节点中，已经考虑了 $i$ 个、花费为 $j$ 的最大力量。记 $tot$ 为一个节点字节点数，则转移为（当前节点为 $x$）：\n\n枚举 $x$ 的合成量 $l$：\n\n$$g[i, \\; j] = max(g[i - 1, \\; j - k] + v.f[l \\times num(v->x), \\; k]), \\; v \\; is \\; son \\; of \\; x$$\n\n再枚举其中的 $i$ 个用于合成高一级装备：\n\n$$x.f[i, \\; j] = max(g[tot, \\; j] + x.price \\times (l - i))$$\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <cstring>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 55;\nconst int MAXLIMIT = 105;\nconst int MAXM = 2005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    int strength, limit, price, deg;\n    int f[MAXLIMIT][MAXM];\n#ifdef DBG\n    int id;\n#endif\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    int w;\n    Edge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->e) {}\n};\nvoid addEdge(int u, int v, int w) {\n    N[u].e = new Edge(&N[u], &N[v], w);\n    N[v].deg++;\n}\nint n, m;\nint g[MAXN][MAXM];\nvoid dp(Node *u) {\n#ifdef DBG\n    printf(\"dp(%d)\\n\", u->id);\n#endif\n    if (!u->e) {\n        u->limit = std::min(u->limit, m / u->price);\n        for (int i = 0; i <= u->limit; i++) {\n            for (int j = i; j <= u->limit; j++) \n                u->f[i][j * u->price] = (j - i) * u->strength;\n        }\n#ifdef DBG\n        printf(\"end dp(%d), limit = %d\\n\", u->id, u->limit);\n#endif\n        return;\n    }\n    u->limit = INT_MAX;\n    for (Edge *e = u->e; e; e = e->next) {\n        dp(e->v);\n        u->limit = std::min(u->limit, e->v->limit / e->w);\n        u->price += e->v->price * e->w;\n    }\n    u->limit = std::min(u->limit, m / u->price);\n#ifdef DBG\n    printf(\"end calcLimit(%d), limit = %d\\n\", u->id, u->limit);\n#endif\n    memset(g, -0x3f3f3f3f, sizeof (g));\n    g[0][0] = 0;\n    for (int l = u->limit; l >=0; l--) {\n        int tot = 0;\n        for (Edge *e = u->e; e; e = e->next) {\n            tot++;\n            for (int i = 0; i <= m; i++) {\n                for (int j = 0; j <= i; j++) \n                    g[tot][i] = std::max(g[tot][i], \n                                         g[tot - 1][i - j] + e->v->f[e->w * l][j]);\n            }\n        }\n        for (int i = 0; i <= l; i++) {\n            for (int j = 0; j <= m; j++) \n                u->f[i][j] = std::max(u->f[i][j], g[tot][j] + (l - i) * u->strength);\n        }\n    }\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n#ifdef DBG\n    for (int i = 1; i <= n; i++) N[i].id = i;\n#endif\n    for (int i = 1; i <= n; i++) {\n        char type[2];\n        scanf(\"%d %c\", &N[i].strength, type);\n        if (type[0] == 'A') {\n            int c;\n            scanf(\"%d\", &c);\n            for (int j = 0; j < c; j++) {\n                int x, num;\n                scanf(\"%d %d\", &x, &num);\n                addEdge(i, x, num);\n            }\n        } else scanf(\"%d %d\", &N[i].price, &N[i].limit);\n    }\n    for (int i = 1; i <= n; i++) memset(N[i].f, -0x3f3f3f3f, sizeof (N[i].f));\n    static int h[MAXN][MAXM];\n    int tot = 0;\n    for (int x = 1; x <= n; x++) {\n#ifdef DBG\n        printf(\"x = %d\\n\", x);\n#endif\n        if (N[x].deg == 0) {\n            dp(&N[x]);\n            tot++;\n#ifdef DBG\n            printf(\"tot = %d\\n\", tot);\n#endif\n            for (int i = 0; i <= m; i++) {\n                for (int j = 0; j <= i; j++) {\n                    for (int k = 0; k <= N[x].limit; k++) {\n                        h[tot][i] = std::max(h[tot][i], \n                                             h[tot - 1][j] + N[x].f[k][i - j]);\n                    }\n                }\n            }\n        }\n    }\n    int ans = 0;\n    for (int i = 0; i <= m; i++) ans = std::max(ans, h[tot][i]);\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["树形DP","DP"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4238] 电压","url":"/BZOJ-4238-电压/","content":"\n## 题目大意\n\n给定一个 $n$ 个节点，$m$ 条边的无向图（可能有重边，可能不连通），求有多少条边满足：边的两个节点同色，对剩下的图可以黑白着色。\n\n$2 \\leqslant n \\leqslant 10,000$\n\n$1 \\leqslant m \\leqslant 20,000$\n\n## 题目链接\n\n[BZOJ 4238](http://www.lydsy.com/JudgeOnline/problem.php?id=4238)\n\n<!-- more -->\n\n## 题解\n\n所求的边一定在所有的奇环上，同时不在任何一个偶环上。\n\n对图进行 dfs，当遇到环时，通过节点深度差判断环的奇偶（差是奇数时是偶环。。。）。具体实现时，为深度大的点的权值 $+ 1$，为小的 $- 1$，子节点 dfs 后用子节点的权值更新父节点。\n\n（我好菜啊，Po 姐的题解我没有看懂。。。T_T）\n\n## 使用静态分配内存加速\n\n当你很喜欢用 `new` 却有担心动态分配内存会超时时，可以使用静态分配内存。\n\n大概就像这样：\n\n```c++\n#include <new>\n\nstruct Edge {\n    Node *u, *v;\n    Edge *next;\n    Edge() {}\n    Edge(Node *u, Node *v) :u(u), v(v), next(u->e) {}\n} _pool[MAXM << 1], *_cur = _pool;\n\nvoid addEdge(int u, int v) {\n    N[u].e = new (_cur++) Edge(&N[u], &N[v]);\n    N[v].e = new (_cur++) Edge(&N[v], &N[u]);\n}\n```\n\n对于这道题，在 BZOJ 上，动态分配内存运行了 4872s，静态分配内存运行了 4044s。（好吧，好像加速得不是太多。。。）\n\n另外，以这种方式创建的对象，**一定不能用 `delete` **。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <new>\nconst int MAXN = 100005;\nconst int MAXM = 200005;\nstruct Edge;\nstruct Node {\n    Edge *e;\n    Node *fa;\n    int circleCnt[2], deep;\n} N[MAXN];\nstruct Edge {\n    Node *u, *v;\n    Edge *next, *rev;\n    bool vis;\n    Edge() {}\n    Edge(Node *u, Node *v) : u(u), v(v), vis(false), next(u->e) {}\n} _pool[MAXM << 1], *_cur = _pool;\nvoid addEdge(int u, int v) {\n    N[u].e = new (_cur++) Edge(&N[u], &N[v]);\n    N[v].e = new (_cur++) Edge(&N[v], &N[u]);\n    N[u].e->rev = N[v].e;\n    N[v].e->rev = N[u].e;\n}\nint n, m;\nint circleCnt[2];\nvoid dfs(Node *u) {\n    for (Edge *e = u->e; e; e = e->next) {\n        if (e->vis) continue;\n        if (e->v->deep == 0) {\n            e->v->deep = u->deep + 1;\n            e->vis = e->rev->vis = true;\n            e->v->fa = u;\n            dfs(e->v);\n            u->circleCnt[0] += e->v->circleCnt[0];\n            u->circleCnt[1] += e->v->circleCnt[1];\n        } else {\n            if (e->v->deep <= u->deep) {\n                int x = ((u->deep - e->v->deep) & 1) ^ 1;\n                u->circleCnt[x]++;\n                e->v->circleCnt[x]--;\n                circleCnt[x]++;\n            }\n        }\n    }\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    while (m--) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(u, v);\n    }\n    for (int i = 1; i <= n; i++) {\n        if (N[i].deep == 0) {\n            N[i].deep = 1;\n            dfs(&N[i]);\n        }\n    }\n    int ans = 0;\n    for (int i = 1; i <= n; i++) {\n        if (N[i].fa && N[i].circleCnt[0] == 0 \n            && N[i].circleCnt[1] == circleCnt[1]) ans++;\n    }\n    if (circleCnt[1] == 1) ans++;\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n```","tags":["DFS","图"],"categories":["题解（OI/XCPC）"]},{"title":"[NOIP 2014] 解方程","url":"/BZOJ-3751-NOIP-2014-解方程/","content":"\n## 题目大意\n\n 已知多项式方程：\n$$\na_0 + a_1 x + a_2 x^2 + \\cdots + a_n x^n = 0\n$$\n求这个方程在 $[1, \\; m]$ 内的整数解（$n$ 和 $m$ 均为正整数）。\n\n$1 \\leqslant n \\leqslant 100$\n\n$|a_i| \\leqslant 10^{10,000}$\n\n$1 \\leqslant m \\leqslant 1,000,000$\n\n## 题目链接\n\n[【NOIP 2014】解方程 - LibreOJ 2503](https://loj.ac/problem/2503)\n\n## 题解\n\n当多项式的值在模 $p$ 意义下为 $0$ 时，我们便认为它的值为 $0$，同时，$x + kp$ 的值也为 $0$，因此，我们只需计算 $[1, \\; p - 1]$ 内的值。当然，这是错的，我们再选几个模数（质数）进行验证，如果值都为 $0$，那么就很有可能是解。同时，模意义下的运算避免了高精度。\n\n质数的选取很烦。。。小了会少一些解，多了会 T。。。（BZOJ 挂的时候在 UOJ 上做的，WA 了好几次。。。等 BZOJ 好了后，UOJ 上能 AC 的在 BZOJ 上 TLE 了。。。）\n\n很有趣的题，应该不会再出的题。。。很好奇当时这道题的得分情况。。。\n\n## 代码\n\n这是 BZOJ 上 AC 的，UOJ 上的质数是 $14939$,$，150193$，$5285237$。\n\n质数哪来的？瞎写的。。。\n\n```c++\n#include <cstdio>\n#include <list>\nconst int MAXN = 105;\nconst int MAXM = 1000005;\nconst int MAXLEN = 10005;\nconst int PRIME_NUM = 2;\nconst int MODS[PRIME_NUM] = {21893, 18341629};\nint n, m;\nint a[MAXN];\nchar s[MAXN][MAXLEN];\nint parseInt(char *s, int mod) {\n    int sgn = 1, res = 0;\n    if (*s == '-') sgn = -1, s++;\n    for (; *s; s++) res = (res * 10 + *s - '0') % mod;\n    return res * sgn;\n}\nint calc(int x, int mod) {\n    long long res = 0, pow = 1;\n    for (int i = 0; i <= n; i++) {\n        res = (res + a[i] * pow) % mod;\n        pow = pow * x % mod;\n    }\n    return (int) res;\n}\nint main() {\n    scanf(\"%d %d\", &n, &m);\n    for (int i = 0; i <= n; i++) scanf(\"%s\", s[i]);\n    std::list<int> roots;\n    int p = MODS[0];\n    for (int i = 0; i <= n; i++) a[i] = parseInt(s[i], p);\n    for (int i = 1; i < p; i++) {\n        int y = calc(i, p);\n        if (y == 0) for (int j = i; j <= m; j += p) roots.push_back(j);\n    }\n    for (int i = 1; i < PRIME_NUM; i++) {\n        int p = MODS[i];\n        for (int j = 0; j <= n; j++) a[j] = parseInt(s[j], p);\n        for (std::list<int>::iterator it = roots.begin(); it != roots.end(); ) {\n            int y = calc(*it, p);\n            if (y != 0) it = roots.erase(it);\n            else it++;\n        }\n    }\n    roots.sort();\n    printf(\"%lu\\n\", roots.size());\n    for (std::list<int>::iterator it = roots.begin(); it != roots.end(); it++) \n        printf(\"%d\\n\", *it);\n    return 0;\n}\n```","tags":["数论","Hash"],"categories":["题解（OI/XCPC）"]},{"title":"BSGS学习笔记","url":"/BSGS学习笔记/","content":"\n## 算法介绍\n\nBSGS（Baby-Step Giant-Step）算法用于求如下方程的解：\n$$\na^x \\equiv b \\; (mod \\; p), \\; p \\ 为质数\n$$\n<!-- more -->\n\n令 $m = \\lceil \\sqrt p \\rceil$。根据费马小定理，有 $a^{p - 1} \\equiv 1\\; (mod\\; p)$，故若方程有解，则必然存在一个解满足 $0 \\leqslant x < p - 1$。设该解为 $x = im + j$，其中 $0 \\leq i,\\ j \\leq m$。\n\n方程可化为：\n$$\n\\begin{align}\na^x &\\equiv b\\; (mod \\; p) \\\\\na^{im + j} &\\equiv b\\; (mod\\; p) \\\\\na^j &\\equiv b a^{-im}\\; (mod\\; p) \\\\\na^j &\\equiv b (a^{-m})^i (mod\\; p) \\\\\n\\end{align}\n$$\n我们只需要找到一组 $i$、$j$ 使得最后一个式子成立即可。\n\n枚举 $j$，求出左边$a^j \\; mod \\; p$ 的所有取值，并将以$(j, \\; a^j)$的映射关系插入到一个表中。\n\n之后，求出$a^m$在模$p$意义下的乘法逆元。枚举 $i$，求出所有的 $b(a^{-m})^i$，每得到一个值后，从表中查找该值，如果存在，取出其对应的$j$，$x = im + j$即为一个解。\n\n时间复杂度为 $O(\\sqrt p)$。\n\n## 模板题\n\n[BZOJ 2242](http://www.lydsy.com/JudgeOnline/problem.php?id=2242) （[题解](http://pepcy.cf/BZOJ-2242-SDOI-2011-计算器/)）","tags":["学习笔记","数论","BSGS"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[SDOI 2011] 计算器","url":"/BZOJ-2242-SDOI-2011-计算器/","content":"\n## 题目大意\n\n你被要求设计一个计算器完成以下三项任务：\n\n1、给定 $y$，$z$，$p$，计算 $y^z \\bmod p$ 的值；\n\n2、给定 $y$，$z$，$p$，计算满足 $xy \\equiv z (\\bmod p)$ 的最小非负整数；\n\n3、给定 $y$，$z$，$p$，计算满足 $y^x \\equiv  z (\\bmod p)$ 的最小非负整数。\n\n无解时输出 `Orz, I cannot find x!`。\n\n多组询问，同一个点的任务相同。\n\n$1 \\leqslant T \\leqslant 10$\n\n$1 \\leqslant y, \\ z, \\ p \\leqslant 1,000,000,000, \\ p\\; 为质数$\n\n## 题目链接\n\n[【SDOI 2011】计算器 - Luogu 2485](https://www.luogu.com.cn/problem/P2485)\n\n<!-- more -->\n\n## 题解\n\n第一个任务直接快速幂。\n\n第二个任务，当且仅当 $y \\equiv 0 (\\bmod p), \\; z \\not\\equiv 0 (\\bmod p)$ 时无解；有解时，计算逆元后直接算就行。\n\n第三个任务，用 BSGS 求。\n\n## 代码\n\n这类题还是都用 `long long` 比较省心啊。。。\n\n```c++\n#include <cstdio>\n#include <cmath>\n#include <map>\nlong long pow(long long a, long long n, long long p) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a % p) if (n & 1) res = res * a % p;\n    return res;\n}\nnamespace Quest1 {\n    void solve(long long a, long long b, long long p) {\n        printf(\"%lld\\n\", pow(a, b, p));\n    }\n}\nvoid exgcd(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) x = 1, y = 0;\n    else exgcd(b, a % b, y, x), y -= x * (a / b);\n}\nlong long inv(long long a, long long p) {\n    long long res, temp;\n    exgcd(a, p, res, temp);\n    return (res % p + p) % p;\n}\nnamespace Quest2 {\n    void solve(long long a, long long b, long long p) {\n        if (b % p != 0 && a % p == 0) puts(\"Orz, I cannot find x!\");\n        else {\n            long long t = inv(a, p);\n            printf(\"%lld\\n\", b * t % p);\n        }\n    }\n}\nnamespace Quest3 {\n    long long bsgs(long long a, long long b, long long p) {\n        a %= p, b %= p;\n        if (a == 0) return b == 0 ? 1 : -1;\n        std::map<long long, long long> map;\n        long long m = ceil(sqrt(p)), t = 1;\n        for (int i = 0; i < m; i++) {\n            if (!map.count(t)) map[t] = i;\n            t = t * a % p;\n        }\n        long long k = inv(t, p), w = b;\n        for (int i = 0; i < m; i++) {\n            if (map.count(w)) return i * m + map[w];\n            w = w * k % p;\n        }\n        return -1;\n    }\n    void solve(long long a, long long b, long long p) {\n        long long ans = bsgs(a, b, p);\n        if (ans == -1) puts(\"Orz, I cannot find x!\");\n        else printf(\"%lld\\n\", ans);\n    }\n}\nint main() {\n    int T, k;\n    scanf(\"%d %d\", &T, &k);\n    while (T--) {\n        long long y, z, p;\n        scanf(\"%lld %lld %lld\", &y, &z, &p);\n        if (k == 1) Quest1::solve(y, z, p);\n        else if (k == 2) Quest2::solve(y, z, p);\n        else Quest3::solve(y, z, p);\n    }\n    return 0;\n}\n```","tags":["数论","BSGS","模版"],"categories":["题解（OI/XCPC）"]},{"title":"[BZOJ 4403] 序列统计","url":"/BZOJ-4403-序列统计/","content":"\n## 题目大意\n\n给定三个正整数 $n$、$l$ 和 $r$，统计长度在 $1$ 到 $n$ 之间，元素大小都在 $l$ 到 $r$ 之间的单调不降序列的数量。输出答案对 $1,000,003$ 取模的结果。多组询问。\n\n$1 \\leqslant T \\leqslant 100$\n\n$1 \\leqslant n, \\ l, \\ r \\leqslant 1,000,000,000$\n\n## 题目链接\n\n[BZOJ 4403](http://www.lydsy.com/JudgeOnline/problem.php?id=4403)\n\n<!-- more -->\n\n## 题解\n\n对于一个固定的序列长度 $i$，所求答案即从 $[1, \\ r - l + 1]$ 中允许重复地选出$i$个数的个数，那么，所求答案即：\n$$\n\\begin{align}\n\\sum_{i = 1}^{n} \\binom{m + i - 1}{i} &= \\sum_{i = 1}^{n} \\binom{m + i - 1}{m - 1}, \\quad m = r - l + 1 \\\\\n&= \\sum_{i = 1}^{n} \\binom{m + i - 1}{m - 1} + \\binom{m}{m} - 1 \\\\\n&= \\sum_{i = 2}^{n} \\binom{m + i - 1}{m - 1} + \\binom{m}{m - 1} + \\binom{m}{m} - 1 \\\\\n&= \\sum_{i = 2}^{n} \\binom{m + i - 1}{m - 1} + \\binom{m + 1}{m} - 1 \\\\\n&= \\sum_{i = 3}^{n} \\binom{m + i - 1}{m - 1} + \\binom{m + 2}{m} - 1 \\\\\n&= \\binom{m + n}{m} - 1\\\\\n\\end{align}\n$$\n然后套 Lucas 定理直接算就行了（模数是质数）。\n\n## 代码\n\n这类题还是都写成 `long long` 比较省心啊。。。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\nconst int MOD = 1e6 + 3;\nlong long fact[MOD];\nlong long calcFact() {\n    fact[0] = 1;\n    for (int i = 1; i < MOD; i++) fact[i] = fact[i - 1] * i % MOD;\n}\nlong long pow(long long a, long long n) {\n    long long res = 1;\n    for (; n; n >>= 1, a = a * a %MOD) if (n & 1) res = res * a % MOD;\n    return res;\n}\nlong long inv(long long x) {\n    return pow(x, MOD - 2);\n}\nlong long combin(long long n, long long m) {\n    if (n < m) return 0;\n    if (n < MOD && m < MOD) return fact[n] * inv(fact[m]) % MOD * inv(fact[n - m]) % MOD;\n    return combin(n / MOD, m / MOD) * combin(n % MOD, m % MOD) % MOD;\n}\nint main() {\n    calcFact();\n    int T;\n    scanf(\"%d\", &T);\n    while (T--) {\n        int n, l, r;\n        scanf(\"%d %d %d\", &n, &l, &r);\n        int m = r - l + 1;\n        printf(\"%lld\\n\", (combin(m + n, m) + MOD - 1) % MOD);\n    }\n    return 0;\n}\n```","tags":["数论","Lucas定理"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2010] 超级钢琴","url":"/BZOJ-2006-NOI-2010-超级钢琴/","content":"\n## 题目大意\n\n给定一个长为 $n$ 的序列，每个位置上有一个权值 $a_i$，找出 $k$ 个不同的长度在 $[l, r]$ 的区间，使得它们的和最大。\n\n$1 \\leqslant n, \\ k \\leqslant 500,000$\n\n$-1,000 \\leqslant a_i \\leqslant 1,000$\n\n## 题目链接\n\n[【NOI 2010】超级钢琴](https://www.luogu.com.cn/problem/P2048)\n\n<!-- more -->\n\n## 题解\n\n当区间的右端点固定时，左端点有一个范围，在前缀和数组中找到这一段的最小值，就可以算出右端点固定时的一个满足条件的区间。用一个优先队列维护一个五元组 $(sum, v, l, r, k)$，其中五元组表示右端点为 $v$，左端点为前缀和上区间 $[l, r]$ 内的第 $k$ 小时的区间和为 $sum$，五元组间的比较以 $sum$ 为关键字。取出一个五元组后，插入其对应的 $k + 1$ 的五元组。询问前缀和上的区间第$k$小用主席树。\n\n## 代码\n\n答案会超过 `int`。\n\n```c++\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 500005;\nstruct PSegT {\n\tstruct Node {\n\t\tint l, r;\n\t\tNode *lc, *rc;\n\t\tint cnt;\n\t\tNode(int l, int r, Node *lc = NULL, Node *rc = NULL) : l(l), r(r), lc(lc), rc(rc), cnt((lc ? lc->cnt : 0) + (rc ? rc->cnt : 0)) {}\n\t\tNode(int l, int r, int cnt) : l(l), r(r), cnt(cnt), lc(NULL), rc(NULL) {}\n\t\tvoid pushDown() {\n\t\t\tif (lc && rc) return;\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\tif (!lc) lc = new Node(l, mid);\n\t\t\tif (!rc) rc = new Node(mid + 1, r);\n\t\t}\n\t\tNode *insert(int val) {\n\t\t\tif (val < l || val > r) return this;\n\t\t\tif (val == l && val == r) return new Node(l, r, this->cnt + 1);\n\t\t\tint mid = l + (r - l) / 2;\n\t\t\tpushDown();\n\t\t\tif (val <= mid) return new Node(l, r, lc->insert(val), rc);\n\t\t\telse return new Node(l, r, lc, rc->insert(val));\n\t\t}\n\t\tint rank() {\n\t\t\treturn lc ? lc->cnt : 0;\n\t\t}\n\t} *roots[MAXN];\n\tint n;\n\tvoid build(int a[], int n) {\n\t\tthis->n = n;\n\t\troots[0] = new Node(0, n - 1);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\troots[i] = roots[i - 1]->insert(a[i - 1]);\n\t\t}\n\t}\n\tint query(int l, int r, int k) {\n#ifdef DBG\n\t\tprintf(\"query in [%d, %d], k = %d\\n\", l, r, k);\n#endif\t\t\n\t\tNode *L = roots[l - 1], *R = roots[r];\n\t\tint min = 0, max = n - 1;\n\t\twhile (min != max) {\n\t\t\tL->pushDown();\n\t\t\tR->pushDown();\n\t\t\tint mid = min + (max - min) / 2, t = R->rank() - L->rank();\n\t\t\tif (k <= t) L = L->lc, R = R->lc, max = mid;\n\t\t\telse k -= t, L = L->rc, R = R->rc, min = mid + 1;\n\t\t}\n\t\treturn min;\n\t}\n} pst;\nint a[MAXN], sum[MAXN];\nint map[MAXN];\nvoid discretization(int n) {\n\tstd::copy(sum, sum + n, map + 1);\n\tstd::sort(map + 1, map + n + 1);\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) printf(\"disc: map[%d] = %d, sum[%d] = %d\\n\", i, map[i], i - 1, sum[i - 1]);\n#endif\t\n\tint *end = std::unique(map + 1, map + n + 1);\n\tfor (int i = 1; i <= n; i++) sum[i - 1] = std::lower_bound(map + 1, end, sum[i - 1]) - map;\n}\nstruct Data {\n\tint sum, v, l, r, k;\n\tbool operator<(const Data &another) const {\n\t\treturn sum < another.sum;\n\t}\n#ifdef DBG\n\tvoid print() {\n\t\tprintf(\"Data : [sum: %d, v: %d, l: %d, r: %d, k: %d]\\n\", sum, v, l, r, k);\n\t}\n#endif\t\n};\nint main() {\n\tint n, k, l, r;\n\tscanf(\"%d %d %d %d\", &n, &k, &l, &r);\n\tfor (int i = 1; i <= n; i++) scanf(\"%d\", &a[i]);\n\tfor (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + a[i];\n\tdiscretization(n + 1);\n\tpst.build(sum, n + 1);\n\tstd::priority_queue<Data> q;\n\tq.push((Data) {map[sum[l]], l, 0, 0, 1});\n\tfor (int i = l + 1; i <= n; i++) {\n\t\tint l2 = i - l;\n\t\tint l1 = i - r;\n\t\tif (l1 < 0) l1 = 0;\n\t\tq.push((Data) {map[sum[i]] - map[pst.query(l1 + 1, l2 + 1, 1)], i, l1 + 1, l2 + 1, 1});\n\t}\n#ifdef DBG\n\tprintf(\"%d\\n\", sum[9]);\n#endif\t\n\tlong long ans = 0;\n\tfor (int i = 1; i <= k; i++) {\n\t\tData t = q.top();\n#ifdef DBG\n\t\tt.print();\n#endif\t\t\n\t\tq.pop();\n\t\tans += t.sum;\n\t\tif (t.r - t.l + 1 >= t.k + 1) q.push((Data) {map[sum[t.v]] - map[pst.query(t.l, t.r, t.k + 1)], t.v, t.l, t.r, t.k + 1});\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n```\n\n","tags":["优先队列","主席树"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2010] 能量采集","url":"/BZOJ-2005-NOI-2010-能量采集/","content":"\n## 题目大意\n\n给定 $n$、$m$，求：\n$$\n\\sum_{i = 1}^{n} \\sum_{j = 1}^{m} 2 \\times gcd(i, j) - 1\n$$\n$1 \\leqslant n, \\ m \\leqslant 100,000$\n\n## 题目链接\n\n[【NOI 2010】能量采集 - Luogu 1447](https://www.luogu.com.cn/problem/P1447)\n\n<!-- more -->\n\n## 题解\n\n莫比乌斯反演。\n\n记 \n\n$$f(x) = \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [gcd(i, j) = x]$$\n\n题目即求 \n\n$$\\sum_{i = 1}^{min(n, m)} i \\times f(i)$$\n\n对于 $f(x)$ 的计算，记\n\n$$F(x) = \\sum_{i = 1}^{n} \\sum_{j = 1}^{m} [x | gcd(i, j)] = \\lfloor \\frac{n}x \\rfloor \\lfloor \\frac{m}i \\rfloor$$\n$$\n\\begin{align}\nF(x) &= \\sum_{x | d} \\mu(\\frac{d}x) f(d) \\\\\n&= \\sum_{i = 1}^{\\lfloor \\frac{n}x \\rfloor} \\mu(i) f(ix) \\\\\nf(x) &= F(x) - \\sum_{i = 2}^{\\lfloor \\frac{n}x \\rfloor} \\mu(i) f(ix) \\\\\n\\end{align}\n$$\n由此计算即可。\n\n另外，在 [【HAOI 2011】problem b](https://www.luogu.com.cn/problem/P2522) 中，我们得到了另一计算 $f(x)$ 的式子，理论上用那个也能算，时间复杂度应该相同，均为 $O(n \\sqrt{n})$（经 VW 学长更正：为 $O(n\\log n)$，调和数的增长是对数的），但本篇的式子编写代码时更简单。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 100005;\nlong long f[MAXN];\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tif (n > m) std::swap(n, m);\n\tlong long ans = 0;\n\tfor (int i = n; i; i--) {\n\t\tf[i] = (long long) (n / i) * (m / i);\n\t\tfor (int j = 2; i * j <= n; j++) f[i] -= f[i * j];\n\t\tans += f[i] * ((i << 1) - 1);\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演"],"categories":["题解（OI/XCPC）"]},{"title":"[ZJOI 2013] 防守战线","url":"/BZOJ-3112-ZJOI-2013-防守战线/","content":"\n## 题目大意\n\n长为 $n$ 的序列，第 $i$ 位上建一座塔需花费 $c_i$，每个位置可建多座塔，有 $m$ 个区间，第 $i$ 个区间内至少要有 $d_i$ 座塔，球最小花费。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n$1 \\leqslant m, \\ c_i, \\ d_i \\leqslant 10,000$\n\n## 题目链接\n\n[【ZJOI 2013】防守阵线](https://www.luogu.com.cn/problem/P3337）\n\n<!-- more -->\n\n## 题解\n\n裸题。\n\n单纯形，对偶原理。\n\n## 代码\n\n注意答案会超过 `int`。\n\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\nconst int MAXN = 1005;\nconst int MAXM = 10005;\nconst double EPS = 1e-7;\nstruct LinearPlanning {\n\tdouble A[MAXN][MAXM], b[MAXN], c[MAXM], v;\n\tint n, m;\n\tvoid pivot(int l, int e) {\n\t\tb[l] /= A[l][e];\n\t\tfor (int i = 1; i <= m; i++) if (i != e) A[l][i] /= A[l][e];\n\t\tA[l][e] = 1 / A[l][e];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (i != l && abs(A[i][e]) > EPS) {\n\t\t\t\tb[i] -= A[i][e] * b[l];\n\t\t\t\tfor (int j = 1; j <= m; j++) if (j != e) A[i][j] -= A[i][e] * A[l][j];\n\t\t\t\tA[i][e] = -A[i][e] * A[l][e];\n\t\t\t}\n\t\t}\n\t\tv += c[e] * b[l];\n\t\tfor (int i = 1; i <= m; i++) if (i != e) c[i] -= c[e] * A[l][i];\n\t\tc[e] = -c[e] * A[l][e];\n\t}\n\tdouble operator()(int n, int m) {\n\t\tthis->n = n;\n\t\tthis->m = m;\n\t\twhile (true) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i <= m; i++) if (c[i] > EPS) break;\n\t\t\tint e = i;\n\t\t\tif (e == m + 1) return v;\n\t\t\tdouble temp = DBL_MAX;\n\t\t\tint l;\n\t\t\tfor (i = 1; i <= n; i++) if (A[i][e] > EPS && b[i] / A[i][e] < temp) temp = b[i] / A[i][e], l = i;\n\t\t\tif (temp == DBL_MAX) return DBL_MAX;\n\t\t\tpivot(l, e);\n\t\t}\n\t}\n} lp;\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &lp.b[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint l, r, d;\n\t\tscanf(\"%d %d %d\", &l, &r, &d);\n\t\tfor (int j = l; j <= r; j++) lp.A[j][i] = 1;\n\t\tlp.c[i] = d;\n\t}\n\tprintf(\"%lld\\n\", (long long) (lp(n, m) + 0.5));\n\treturn 0;\n}\n```","tags":["单纯形"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2008] 志愿者招募","url":"/BZOJ-1061-NOI-2008-志愿者招募/","content":"\n## 题目大意\n\n给定 $n$ 天，第 $i$ 天需要 $a_i$ 个志愿者，有 $m$ 类志愿者，每类志愿者工作时间为 $[s_i, t_i]$，花费为 $c_i$，求最小花费。\n\n$1 \\leqslant n \\leqslant 1,000$\n\n$1 \\leqslant m \\leqslant 10,000$\n\n## 题目链接\n\n[【NOI 2008】志愿者招募 - Luogu 3980](https://www.luogu.com.cn/problem/P3980)\n\n<!-- more -->\n\n## 题解\n\n单纯形裸题。用对偶原理转化。\n\n有关单纯形算法见[单纯型学习笔记](http://pepcy.cf/单纯形算法学习笔记/)。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <cfloat>\n#include <algorithm>\nconst int MAXN = 1005;\nconst int MAXM = 10005;\nconst double EPS = 1e-7;\nstruct LinearPlanning {\n\tdouble A[MAXM][MAXN], b[MAXM], c[MAXN], v;\n\tint n, m;\n\tvoid pivot(int l, int e) {\n\t\tb[l] /= A[l][e];\n\t\tfor (int i = 1; i <= n; i++) if (i != e) A[l][i] /= A[l][e];\n\t\tA[l][e] = 1 / A[l][e];\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tif (i != l && abs(A[i][e]) > EPS) {\n\t\t\t\tb[i] -= A[i][e] * b[l];\n\t\t\t\tfor (int j = 1; j <= n; j++) if (j != e) A[i][j] -= A[i][e] * A[l][j];\n\t\t\t\tA[i][e] = -A[i][e] * A[l][e];\n\t\t\t}\n\t\t}\n\t\tv += c[e] * b[l];\n\t\tfor (int i = 1; i <= n; i++) if (i != e) c[i] -= c[e] * A[l][i];\n\t\tc[e] = -c[e] * A[l][e];\n\t}\n\tdouble operator()(int n, int m) {\n\t\tthis->n = n;\n\t\tthis->m = m;\n\t\twhile (true) {\n\t\t\tint i;\n\t\t\tfor (i = 1; i <= n; i++) if (c[i] > EPS) break;\n\t\t\tint e = i;\n\t\t\tif (e == n + 1) return v;\n\t\t\tdouble temp = DBL_MAX;\n\t\t\tint l;\n\t\t\tfor (i = 1; i <= m; i++) if (A[i][e] > EPS && b[i] / A[i][e] < temp) temp = b[i] / A[i][e], l = i;\n\t\t\tif (temp == DBL_MAX) return DBL_MAX;\n\t\t\tpivot(l, e);\n\t\t}\n\t}\n} lp;\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 1; i <= n; i++) scanf(\"%lf\", &lp.c[i]);\n\tfor (int i = 1; i <= m; i++) {\n\t\tint s, t, c;\n\t\tscanf(\"%d %d %d\", &s, &t, &c);\n\t\tfor (int j = s; j <= t; j++) lp.A[i][j] = 1;\n\t\tlp.b[i] = c;\n\t}\n\tprintf(\"%d\\n\", (int) (lp(n, m) + 0.5));\n\treturn 0;\n}\n```\n","tags":["单纯形","模版"],"categories":["题解（OI/XCPC）"]},{"title":"单纯形算法学习笔记","url":"/单纯形算法学习笔记/","content":"\n## 算法介绍\n\n从 Po 姐那里看到的 wyfcyx 大佬的[《线性规划与单纯形算法》](https://wenku.baidu.com/view/ce5784754a7302768f99391d)，推荐去看一看。\n\n*以下内容来自于那个课件。*\n\n规定一个线性规划的**标准型**：\n\n> 在条件 $Ax \\leqslant b$ 下，最大化 $c^T x$。\n\n<!-- more -->\n\n其中各字符均为矩阵，其意义如下（$n$ 为变量数，$m$ 为限制条件数）：\n\n$A$：限制条件的系数矩阵，大小为 $m \\times n$。\n\n$x$：变量矩阵，大小为 $n \\times 1$。\n\n$b$：限制条件的常数矩阵，大小为 $m \\times 1$。\n\n$c$：目标函数的系数矩阵，大小为 $n \\times 1$。\n\n下面考虑如何把不是标准型的线性规划转化为标准型。\n\n- 目标函数最小化：所有系数取反，转化为最大化，最后对答案取反。\n- 限制条件为大于等于：系数取反。\n- 限制条件为等于：拆成大于等于、小于等于两个限制。\n- 变量限制条件为 $x \\geqslant a$：转化为$x' \\geqslant 0, \\ x' = x - a$。\n- 变量限制条件为 $x \\leqslant a$：转化为$x' \\geqslant 0, \\ x' =  a- x$。\n- 变量无限制：转化为 $x' \\geqslant 0, \\ x'' \\geqslant 0, \\ x = x' - x''$。\n\n线性规划的**松弛型**：\n\n给第i个变量添加辅助变量 $x_{n + i}$，把不等号转化为等号。\n\n$$x_{n + i} + \\sum_{j = 1}^{n} A_{i, j}x_j = b_i, \\ x_{n + i} \\geqslant 0$$\n\n现在，定义一些名称：\n\n**基变量**：把标准型转化为松弛型的辅助变量，有 $m$ 个，其集合记为 $B$。\n\n**原变量**：原来的变量，有 $n$ 个，其集合记为 $N$。（这个在那个课件里叫“非基变量”）\n\n**可行解**：使所有限制满足的一组原变量。\n\n**最优解**：使目标函数最优的一组可行解。\n\n算法过程：\n\n先假定所有的原变量为 $0$ 为一组可行解，考虑目标函数中某个原变量，若其系数大于 $0$ ，那我们增大那个原变量会使目标函数值增大。\n\n若所有原变量的系数均小于等于 $0$，则当前解为最优解，目标函数值的最大值即为目标函数的常数。\n\n若我们已经找到了一个系数大于 $0$ 的原变量，假设是第 $e$ 个，记为 $x_{N_e}$。\n\n关于它的限制有：\n\n$$x_{B_i} + \\sum_{j = 1}^{n} A_{i, j} x_{N_j} = b_i$$\n\n若 $A_{i, e} > 0$，则有：\n\n$$A_{i, e} \\leqslant \\frac{b_i}{A_{i, e}}$$\n\n记找到的最紧的限制条件为第 $l$ 个，其对应基变量为 $x_{B_l}$。\n\n之后进行**转轴操作**，即交换找到的基变量与原变量，同时进行换元之类的操作使得新基变量的系数为 $1$。操作完毕后，我们发现，目标函数的常数项增大了。\n\n**注意**：选择原变量时，应选择编号最小的，否则容易被特殊数据卡出死循环。\n\n转轴操作的代码：\n\n```c++\nvoid pivot(int l, int e) {\n\tb[l] /= A[l][e];\n\tfor (int i = 1; i <= n; i++) if (i != e) A[l][i] /= A[l][e];\n\tA[l][e] = 1 / A[l][e];\n\tfor (int i = 1; i <= m; i++) {\n\t\tif (i != l && abs(A[i][e]) > EPS) {\n\t\t\tb[i] -= A[i][e] * b[l];\n\t\t\tfor (int j = 1; j <= n; j++) if (j != e) A[i][j] -= A[i][e] * A[l][j];\n\t\t\tA[i][e] = -A[i][e] * A[l][e];\n\t\t}\n\t}\n\tv += c[e] * b[l];\n\tfor (int i = 1; i <= n; i++) if (i != e) c[i] -= c[e] * A[l][i];\n\tc[e] = -c[e] * A[l][e];\n}\n```\n\n一次转轴操作的时间复杂度为 $O(nm)$。\n\n之后，我们只要能转轴就转轴，不能时，目标函数的常数项就是答案。\n\n再说一个**对偶原理**，可以用于转化线性规划到标准型（很常用的样子），其内容如下：\n\n> 有两个线性规划：\n>\n> - 在条件 $Ax \\leqslant b$下，最大化 $c^T x$。\n>\n>\n> - 在条件 $A^Ty \\geqslant c$下，最小化 $b^T y$。\n>\n> 它们的最优解相同。\n\n## 模板题\n\n原课件：单纯形算法只能做裸题！（以及网络流相关的黑科技。。。）\n\n[【NOI 2008】志愿者招募 - Luogu 3980](https://www.luogu.com.cn/problem/P3980)\n\n[【ZJOI 2013】防守阵线 - Luogu 3337](https://www.luogu.com.cn/problem/P3337)","tags":["学习笔记","单纯形"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[HAOI 2011] Problem b","url":"/BZOJ-2301-HAOI-2011-Problem-b/","content":"\n## 题目大意\n\n对于给出的 $n$ 个询问，每次求有多少个数对 $(x, y)$，满足 $a \\leqslant x \\leqslant b$，$c \\leqslant y \\leqslant d$，且$gcd(x, y) = k$。\n\n$n, \\ a, \\ b, \\ c, \\ d, \\ k \\leqslant 50,000$\n\n## 题目链接\n\n[【HAOI 2011】problem b - Luogu 2522](https://www.luogu.com.cn/problem/P2522)\n\n## 题解\n\n莫比乌斯反演裸题（本来还有一个更裸，但被权限了。。。）。\n\n首先，通过容斥，我们可以把问题化为求满足 $x \\leqslant n$，$y \\leqslant m$，且 $gcd(x, y) = k$ 的数对个数。即：\n\n$$\\sum_{x = 1}^{n} \\sum_{y = 1}^{m} [gcd(x, \\ y) = k]$$\n\n我们这么对式子进行变换：\n$$\n\\begin{align}\n\\sum_{x = 1}^{n} \\sum_{y = 1}^{m} [gcd(x, \\ y) = k] & = \\sum_{x = 1}^{n'} \\sum_{y = 1}^{m'} [gcd(x, \\ y) = 1] \\quad (n' = \\lfloor \\frac{n}k \\rfloor, \\ m' = \\lfloor \\frac{m}k \\rfloor) \\\\\n& = \\sum_{x = 1}^{n'} \\sum_{y = 1}^{m'} \\sum_{d | gcd(x, y)} \\mu(d) \\\\\n& = \\sum_{i = 1}^{min(n', m')} \\mu(i) \\lfloor \\frac{n'}i \\rfloor \\lfloor \\frac{m'}i \\rfloor\n\\end{align}\n$$\n其中第二行的式子来源于 $\\mu \\ * \\ 1 = e$，$\\mu$ 为莫比乌斯函数，$1$ 为常函数（函数值为 $1$），$e$ 为元函数（除 $x = 1$ 处的值为 $1$ 以外函数值为 $0$），$*$ 为狄利克雷卷积。\n\n注意到，在最后的式子中，$\\lfloor \\frac{n'}i \\rfloor$ 只有 $2\\sqrt{n}$ 个值（$\\lfloor \\frac{m'}i \\rfloor$ 同），所以我们可以预处理出莫比乌斯函数的前缀和，分块进行计算。\n\n## 代码\n\n说来这道题还可以作为线性筛的模板。。。\n\n```c++\n#include <cstdio>\n#include <algorithm>\nconst int MAXN = 100005;\nlong long mu[MAXN], prime[MAXN], primeCnt;\nbool mark[MAXN];\nvoid linearShaker() {\n\tmu[1] = 1;\n\tfor (int i = 2; i < MAXN; i++) {\n\t\tif (!mark[i]) {\n\t\t\tprime[++primeCnt] = i;\n\t\t\tmu[i] = -1;\n\t\t}\n\t\tfor (int j = 1; j <= primeCnt && i * prime[j] < MAXN; j++) {\n\t\t\tmark[i * prime[j]] = true;\n\t\t\tif (i % prime[j] == 0) {\n\t\t\t\tmu[i * prime[j]] = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tmu[i * prime[j]] = -mu[i];\n\t\t}\n\t}\n\tfor (int i = 1; i < MAXN; i++) mu[i] += mu[i - 1];\n}\nlong long calc(int n, int m, int k) {\n\tlong long res = 0;\n\tn /= k, m /= k;\n\tint last;\n\tfor (int i = 1; i <= m && i <= n; i = last + 1) {\n\t\tlast = std::min(n / (n / i), m / (m / i));\n\t\tres += (mu[last] - mu[i - 1]) * (n / i) * (m / i);\n\t}\n\treturn res;\n}\nint main() {\n\tlinearShaker();\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint a, b, c, d, k;\n\t\tscanf(\"%d %d %d %d %d\", &a, &b, &c, &d, &k);\n\t\tprintf(\"%lld\\n\", calc(b, d, k) - calc(a - 1, d, k) - calc(b, c - 1, k) + calc(a - 1, c - 1, k));\n\t}\n\treturn 0;\n}\n```","tags":["数论","线性筛","莫比乌斯反演"],"categories":["题解（OI/XCPC）"]},{"title":"[NOI 2008] 假面舞会","url":"/BZOJ-1064-NOI-2008-假面舞会/","content":"\n## 题目大意\n\n对一个有向图进行染色，要求同一个节点的所有的子节点必须同色，同一个节点的所有父节点必须同色，相连的两个节点不许同色。求最大\\小的颜色数。\n\n$1\\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant m \\leqslant 1,000,000$\n\n$k \\geqslant 3$ （颜色数）\n\n## 题目链接\n\n[【NOI 2008】假面舞会 - Luogu 1477](https://www.luogu.com.cn/problem/P1477)\n\n<!-- more -->\n\n## 题解\n\n感觉这是道神题吧（我好菜啊）。。。\n\n首先，有两种情况：环和树。对于一个单向环，答案为其长度的约数（多个环就是公约数）；对于单向树，答案为任意大于等于 $3$ 的数，最大为树上最长链长。对于不是单向的结构，我们发现，形如 A->B<-C->D 的结构可以由 A->B 替换（显然有 A 与 C 同色，B 与 D 同色），这样，我们可以把所有的结构转化为单向结构。为了方便进行上述操作，我们对于每一条有向边赋权值 $1$，同时添加一条反向边，权值为 $-1$，这样按一个方向绕一圈回来（可由 dfs 实现）的权值和的绝对值就是环对应单向环的长度。\n\n具体实现：进行 dfs 为节点编号，编号为上一个节点的编号 + 边权，当下一个点的编号已确定时，表明找到了一个环，新编号与旧编号的差的绝对值为环对应单向环的长度；对于树，进行 dfs 编号，最大最小编号差 $+1$ 即为最长单向链长。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nstruct Edge;\nstruct Node {\n\tEdge *firstEdge;\n\tint no, wcc;\n#ifdef DBG\n\tint id;\n#endif\t\n\tbool vis;\n} N[MAXN];\nstruct Edge {\n\tNode *u, *v;\n\tEdge *next, *rev;\n\tint w;\n\tbool vis;\n\tEdge(Node *u, Node *v, int w) : u(u), v(v), w(w), next(u->firstEdge) {}\n};\nvoid addEdge(int u, int v, int w = 1) {\n#ifdef DBG\n\tprintf(\"edge: %d --> %d\\n\", u, v);\n#endif\t\n\tN[u].firstEdge = new Edge(&N[u], &N[v], w);\n\tN[v].firstEdge = new Edge(&N[v], &N[u], -w);\n\tN[u].firstEdge->rev = N[v].firstEdge;\n\tN[v].firstEdge->rev = N[u].firstEdge;\n}\nint C[MAXN], circleCnt;\nstruct WCC {\n\tint min, max;\n} wcc[MAXN];\nint wccCnt;\nint n, m;\nvoid findCircle(Node *u, int no = 1) {\n#ifdef DBG\n\tprintf(\"findCircle: node-%d, no-%d\\n\", u->id, no);\n#endif\t\n\tu->no = no;\n\tu->vis = true;\n\tfor (Edge *e = u->firstEdge; e; e = e->next) {\n\t\tif (e->vis) continue;\n#ifdef DBG\n\t\tprintf(\"..egde: %d --> %d, w = %d, to->vis = %d\\n\", u->id, e->v->id, e->w, e->v->vis ? 1 : 0);\n#endif\n\t\te->vis = e->rev->vis = true;\n\t\tif (!e->v->vis) findCircle(e->v, no + e->w);\n\t\telse {\n#ifdef DBG\n\t\t\tprintf(\"..node: %d\\n\", u->id);\n#endif\n\t\t\tif (no + e->w - e->v->no != 0) C[++circleCnt] = abs(no + e->w - e->v->no);\n\t\t}\n\t}\n}\nvoid clear() {\n\tfor (int i = 1; i <= n; i++) {\n\t\tN[i].vis = false;\n\t\tfor (Edge *e = N[i].firstEdge; e; e = e->next) e->vis = false;\n\t}\n}\nvoid findWCC(Node *u) {\n#ifdef DBG\n\tprintf(\"findWCC : node-%d\\n\", u->id);\n#endif\t\n\tu->wcc = wccCnt;\n\tfor (Edge *e = u->firstEdge; e; e = e->next) if (!e->v->wcc) findWCC(e->v);\n}\nvoid dfs(Node *u, int no = 1) {\n\tu->no = no;\n\tu->vis = true;\n\tfor (Edge *e = u->firstEdge; e; e = e->next) {\n\t\tif (!e->v->vis) dfs(e->v, no + e->w);\n\t}\n}\nint gcd(int a, int b) {\n\treturn b == 0 ? a : gcd(b, a % b);\n}\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n#ifdef DBG\n\tfor (int i = 1; i <= n; i++) N[i].id = i;\n#endif\t\n\tfor (int i = 0; i < m; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\tfor (int i = 1; i <= n; i++) {\n\t\tif (!N[i].vis) findCircle(&N[i]);\n\t}\n#ifdef DBG\n\tprintf(\"circleCnt = %d\\n\", circleCnt);\n#endif\n\tif (circleCnt == 0) {\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!N[i].wcc) {\n\t\t\t\twccCnt++;\n\t\t\t\twcc[wccCnt].min = INT_MAX;\n\t\t\t\twcc[wccCnt].max = INT_MIN;\n\t\t\t\tfindWCC(&N[i]);\n\t\t\t}\n\t\t}\n\t\tclear();\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tif (!N[i].vis) dfs(&N[i]);\n\t\t\twcc[N[i].wcc].min = std::min(wcc[N[i].wcc].min, N[i].no);\n\t\t\twcc[N[i].wcc].max = std::max(wcc[N[i].wcc].max, N[i].no);\n\t\t}\n\t\tint ansMax = 0;\n\t\tfor (int i = 1; i <= wccCnt; i++) ansMax += wcc[i].max - wcc[i].min + 1;\n\t\tif (ansMax >= 3) printf(\"%d 3\\n\", ansMax);\n\t\telse puts(\"-1 -1\");\n\t\treturn 0;\n\t}\n\tint gcdC = C[1];\n\tfor (int i = 2; i <= circleCnt; i++) gcdC = gcd(gcdC, C[i]);\n\tint lcdC;\n\tfor (lcdC = 3; lcdC <= gcdC; lcdC++) if (gcdC % lcdC == 0) break;\n\tif (gcdC >= 3) {\n\t\tprintf(\"%d %d\\n\", gcdC, lcdC);\n\t\treturn 0;\n\t}\n\tputs(\"-1 -1\");\n\treturn 0;\n}\n```","tags":["树","DFS"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2005] 王室联邦","url":"/BZOJ-1086-SCOI-2005-王室联邦/","content":"\n## 题目大意\n\n一个 $n$ 个节点的树，将点划分为若干块，每块的大小最少为 $b$，最大为 $3b$。同时，为每一块选一个节点，使得块中所有节点到这个特殊节点的路径上的点（特殊节点本身除外）均在这一块内。给定树，输出任意一种划分方案（可能无解）。\n\n$1 \\leqslant n \\leqslant 1,000, \\ 1 \\leqslant b \\leqslant n$\n\n## 题目链接\n\n[【SCOI 2005】王室联邦 - Luogu 2325](https://www.luogu.com.cn/problem/P2325)\n\n<!-- more -->\n\n## 题解\n\n当且仅当 $b > n$ 时无解。有解时，对树进行 dfs，每当某一点的一些子树大小超过了 $b$，就分成一块，并令该点为新分的块的特殊节点。dfs 后，可能会剩一些节点没有块，再 dfs 一遍划给旁边的块就行了。\n\n## 代码\n\n一开始交的代码没有特判无解，居然就 AC 了。。。\n\n那堆 `DBG` 是因为一开始把 `stack` 写成了 `queue`。。。\n\n```c++\n#include <cstdio>\n#include <stack>\n// #define DBG\nconst int MAXN = 1005;\nstruct Edge;\nstruct Node {\n\tEdge *firstEdge;\n\tint belong, size, id;\n} N[MAXN];\nstruct Edge {\n\tNode *u, *v;\n\tEdge *next;\n\tEdge(Node *u, Node *v) : u(u), v(v), next(u->firstEdge) {}\n};\nint cap[MAXN], proCnt;\nvoid addEdge(int u, int v) {\n#ifdef DBG\n\tprintf(\"edge: %d <--> %d\\n\", u, v);\n#endif\n\tN[u].firstEdge = new Edge(&N[u], &N[v]);\n\tN[v].firstEdge = new Edge(&N[v], &N[u]);\n}\nint b;\nvoid dfs(Node *u, Node *fa = NULL) {\n#ifdef DBG\n\tprintf(\"dfs(%d), fa = %d\\n\", u->id, fa ? fa->id : 0);\n#endif\n\tstatic std::stack<Node *> s;\n\ts.push(u);\n\tfor (Edge *e = u->firstEdge; e; e = e->next) {\n#ifdef DBG\n\t\tprintf(\"dfs-edge: %d --> %d\\n\", u->id, e->v->id);\n#endif\n\t\tif (e->v == fa) continue;\n\t\tdfs(e->v, u);\n#ifdef DBG\n\t\tprintf(\"dfs(%d)size = %d\\n\", u->id, u->size);\n#endif\t\t\n\t\tif (u->size + e->v->size >= b) {\n\t\t\tu->size = 0;\n\t\t\tcap[++proCnt] = u->id;\n\t\t\twhile (s.top() != u) s.top()->belong = proCnt, s.pop();\n\t\t} else u->size += e->v->size;\n\t}\n\tu->size++;\n#ifdef DBG\n\tprintf(\"dfs-end(%d)\\n\", u->id);\n#endif\t\n}\nvoid paint(Node *u, Node *fa = NULL, int p = proCnt) {\n\tif (u->belong) p = u->belong;\n\telse u->belong = p;\n\tfor (Edge *e = u->firstEdge; e; e = e->next) {\n\t\tif (e->v != fa) paint(e->v, u, p);\n\t}\n}\nint main() {\n\tint n;\n\tscanf(\"%d %d\", &n, &b);\n\tif (b > n) {\n\t\tputs(\"0\");\n\t\treturn 0;\n\t}\n\tfor (int i = 1; i <= n; i++) N[i].id = i;\n\tfor (int i = 1; i < n; i++) {\n\t\tint u, v;\n\t\tscanf(\"%d %d\", &u, &v);\n\t\taddEdge(u, v);\n\t}\n\tdfs(&N[1]);\n\tif (!proCnt) cap[++proCnt] = 1;\n\tpaint(&N[1]);\n\tprintf(\"%d\\n\", proCnt);\n\tfor (int i = 1; i <= n; i++) printf(\"%d%c\", N[i].belong, i == n ? '\\n' : ' ');\n\tfor (int i = 1; i <= proCnt; i++) printf(\"%d%c\", cap[i], i == proCnt ? '\\n' : ' ');\n\treturn 0;\n}\n```","tags":["树","DFS"],"categories":["题解（OI/XCPC）"]},{"title":"三维偏序（陌上开花）","url":"/BZOJ-3262-LibreOJ-112-陌上开花/","content":"\n## 题目大意\n\n给定 $n$ 朵花，每种花有三个属性 $a$、$b$、$c$（属性值为 $k$ 以内的正整数）。求有多少花的三个属性比 $d\\ (d = 0, \\ 1, \\ 2 \\dots, \\ n - 1)$ 朵花都大（大于等于）。\n\n$1 \\leqslant n \\leqslant 100,000$\n\n$1 \\leqslant k \\leqslant 200,000$\n\n## 题目链接\n\n[三维偏序 - LibreOJ 112](https://loj.ac/problem/112)\n\n<!-- more -->\n\n## 题解\n\nCDQ 分治模板题。\n\nCDQ 分治：对区间 $[l,  \\ r]$ 分为 $[l, \\ mid]$ 与 $[mid + 1, \\ r]$ 两个区间分别计算，最后计算左区间对右区间的贡献。\n\n一句话概括三维偏序：一维排序，二维归并，三维树状数组。\n\n排序保证了第一维的大小关系，在第一维有序之后的归并保证了第二维的大小关系，建立在权值上的树状数组保证了第三维的大小关系。\n\n具体实现见代码。\n\n另外，这道题可能会有两朵花一模一样，应当在处理前将同一种花归在一起。\n\n## 代码\n\n```c++\n#include <cstdio>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 100005;\nconst int MAXK = 200005;\nstruct Data {\n\tint a, b, c;\n\tint cnt, ans;\n\tbool operator<(const Data &another) const {\n\t\treturn a < another.a || (a == another.a && b < another.b) || (a == another.a && b == another.b && c < another.c);\n\t}\n#ifdef DBG\n\tvoid print() {\n\t\tprintf(\"Data[(%d, %d, %d), cnt = %d, ans = %d]\\n\", a, b, c, cnt, ans);\n\t}\n#endif\t\n} a[MAXN], A[MAXN];\nstruct BinaryIndexedTree {\n\tint c[MAXK], k;\n\tstatic int lowbit(int x) {\n\t\treturn x & -x;\n\t}\n\tvoid update(int pos, int d) {\n\t\tfor (int i = pos; i <= k; i += lowbit(i)) c[i] += d;\n\t}\n\tint query(int pos) {\n\t\tint res = 0;\n\t\tfor (int i = pos; i; i -= lowbit(i)) res += c[i];\n\t\treturn res;\n\t}\n\tvoid clear(int pos) {\n\t\tfor (int i = pos; i <= k; i += lowbit(i)) {\n\t\t\tif (c[i]) c[i] = 0;\n\t\t\telse break;\n\t\t}\n\t}\n\tvoid init(int k) {\n\t\tthis->k = k;\n\t}\n} bit;\nvoid cdq(Data *l, Data *r) {\n\tif (l == r) {\n\t\tl->ans += l->cnt - 1;\n\t\treturn;\n\t}\n\tData *mid = l + (r - l) / 2;\n\tcdq(l, mid);\n\tcdq(mid + 1, r);\n\tstatic Data temp[MAXN];\n\tfor (Data *p = temp, *pl = l, *pr = mid + 1; p <= temp + (r - l); p++) {\n\t\tif (pr > r || (pl <= mid && pl->b <= pr->b)) {\n\t\t\t*p = *pl++;\n\t\t\tbit.update(p->c, p->cnt);\n\t\t} else {\n\t\t\t*p = *pr++;\n\t\t\tp->ans += bit.query(p->c);\n\t\t}\n\t}\n\tfor (Data *p = temp, *q = l; q <= r; q++, p++) {\n\t\t*q = *p;\n\t\tbit.clear(p->c);\n\t}\n}\nint main() {\n\tint n, k;\n\tscanf(\"%d %d\", &n, &k);\n\tfor (int i = 0; i < n; i++) scanf(\"%d %d %d\", &a[i].a, &a[i].b, &a[i].c), a[i].cnt = 1;\n\tstd::sort(a, a + n);\n#ifdef DBG\n\tfor (int i = 0; i < n; i++) a[i].print();\n#endif\t\n\tint cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (i == 0 || !(a[i].a == a[i - 1].a && a[i].b == a[i - 1].b && a[i].c == a[i - 1].c)) A[++cnt] = a[i];\n\t\telse A[cnt].cnt++;\n\t}\n\tbit.init(k);\n\tcdq(A + 1, A + cnt);\n\tstatic int ans[MAXN];\n\tfor (int i = 1; i <= cnt; i++) ans[A[i].ans] += A[i].cnt;\n\tfor (int i = 0; i < n; i++) printf(\"%d\\n\", ans[i]);\n\treturn 0;\n}\n```","tags":["模版","CDQ分治"],"categories":["题解（OI/XCPC）"]},{"title":"[SCOI 2007] 排列","url":"/BZOJ-1072-SCOI-2007-排列/","content":"\n## 题目大意\n\n给一个数字串 $s$ 和正整数 $d$, 统计 $s$ 有多少种不同的排列能被 $d$ 整除（可以有前导 $0$）。多组数据。\n\n$1 \\leqslant T \\leqslant 15$\n\n$1 \\leqslant d \\leqslant 1,000$\n\n$s \\ 的位数 \\leqslant 10$\n\n## 题目链接\n\n[【SCOI 2007】排列 - Luogu 4163](https://www.luogu.com.cn/problem/P4163)\n\n<!-- more -->\n\n## 题解\n\n状压 DP。\n\n先考虑由给定的数字串中的部分数字组成的数的答案，然后在其后加一个还没有考虑的数字进行转移。用二进制的 $1$ 和 $0$ 表示是否考虑了该数，$f[i][j]$ 表示状态为 $i$，模 $d$ 余数为 $j$ 时的答案，转移如下：\n\n$$f[i][j] += f[i \\; | \\; 2^x][(j * 10 + num[x]) \\; mod \\; d], \\; i \\;  \\& \\; 2^x = 0$$\n\n不过这样在有重复数字时会重复计数，最后再除以 $\\prod cnt[i]!, \\; (i = 1, \\ 2, \\ 3 \\dots, \\; 9)$ 即可（类比可重集合全排列，也要除以一个类似的东西）。\n\n## 代码\n\n当数据范围比较小的时候就不想给 `MAXN` 加上 $5$ 或 $10$ 之类的了。。。（这个习惯明明就是为了方便自己从 $1$ 开始标号啊）\n\n```c++\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nconst int MAXN = 10;\nconst int MAXD = 1000;\nchar str[MAXN];\nint num[MAXN], f[1 << MAXN][MAXD], cnt[MAXN], fact[MAXN + 1];\nvoid calcFact() {\n\tfact[0] = 1;\n\tfor (int i = 1; i <= MAXN; i++) fact[i] = fact[i - 1] * i;\n}\nvoid dp(int len, int d) {\n\tmemset(f, 0, sizeof (f));\n\tf[0][0] = 1;\n\tfor (int i = 0; i < (1 << len); i++) {\n\t\tfor (int j = 0; j < d; j++) {\n\t\t\tif (f[i][j]) {\n\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\tif ((i & (1 << k)) == 0)\n\t\t\t\t\t\tf[i | (1 << k)][(j * 10 + num[k]) % d] += f[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint main() {\n\tcalcFact();\n\tint T;\n\tscanf(\"%d\", &T);\n\twhile (T--) {\n\t\tint d;\n\t\tscanf(\"%s%d\", str, &d);\n\t\tint len = strlen(str);\n\t\tmemset(cnt, 0, sizeof (cnt));\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tnum[i] = str[i] - '0';\n\t\t\tcnt[num[i]]++;\n\t\t}\n\t\tdp(len, d);\n\t\tint ans = f[(1 << len) - 1][0];\n\t\tfor (int i = 0; i <= 9; i++) ans /= fact[cnt[i]];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n```","tags":["DP","状压DP"],"categories":["题解（OI/XCPC）"]},{"title":"Dinic 算法整理笔记","url":"/Dinic-算法整理笔记/","content":"\n## 算法介绍\n\nDinic 算法是一种用于解决网络流问题的算法，算法复杂度（上界）为 $O(n^2m)$ ，实际要比这个式子好得多（比如用 Dinic 算二分图时的复杂度是 $O(m\\sqrt{n})$ ）。\n\nDinic 算法通过对残量网络建立层次图，并在层次图上不断寻找增广路来算出最大流。\n\n**残量网络**：原图及其反向边构成的图。\n\n**反向边**：与原边反向的边，原图上的边的反向边的容量为 $0$ ，每一条边在残量网络上均有其反向边。\n\n**层次图**：只保留相邻层次之间的边，且不考虑已达到满流的边的图。\n\n**层次**：可以视作到源点的距离分类。\n\n**增广路**：残量网络上一条从源点到汇点的边，其所有边中的最小容量为其增广容量。\n\n**当前边优化**：建立层次图以后，若某个点有一条边已经增广过了，则这条边在当前层次图之后的增广中不会再用到。\n\n<!-- more -->\n\n## 实现的部分\n\n对于边与点，我们这么储存（链式前向星式）：\n\n```c++\nstruct Edge;\nstruct Node {\n    Edge *firstEdge, *currentEdge;\n    int level;\n} N[MAXN];\nstruct Edge {\n    Node *from, *to;\n    Edge *next, *reversedEdge;\n    int capacity, flow;\n    Edge(Node *from, Node *to, int capacity) : from(from), to(to), capacity(capacity), flow(0), next(from->firstEdge) {}\n};\n```\n\n当图比较稠密时，可以考虑用 `std::vector` 存图，说法来自知乎。。。亲测差不多的样子。。。\n\n## 模板题及其代码\n\n模板题：[最大流 - LibreOJ 101](https://loj.ac/problem/101)\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <vector>\n#include <algorithm>\n\nconst int MAXN = 105;\nconst int MAXM = 5005;\n\nstruct Edge;\nstruct Node;\n\nstruct Node {\n    std::vector<Edge> e;\n    Edge *curr;\n    int level;\n} N[MAXN];\n\nstruct Edge {\n    Node *u,*v;\n    int cap, flow, rev;\n\n    Edge(Node *u, Node *v, int cap, int rev) : u(u), v(v), cap(cap), flow(0), rev(rev) {}\n};\n\nvoid addEdge(int u, int v, int cap) {\n    N[u].e.emplace_back(&N[u], &N[v], cap, N[v].e.size());\n    N[v].e.emplace_back(&N[v], &N[u], 0, N[u].e.size() - 1);\n}\n\nnamespace Dinic {\n    bool level(Node *s, Node *t, int n) {\n        for (int i = 1; i <= n; i++) N[i].level = 0;\n        static std::queue<Node *> q;\n        q.push(s);\n        s->level = 1;\n        while (!q.empty()) {\n            Node *u = q.front();\n            q.pop();\n\n            for (Edge *e = &u->e.front(); e <= &u->e.back(); e++) {\n                if (e->cap > e->flow && e->v->level == 0) {\n                    e->v->level = u->level + 1;\n                    q.push(e->v);\n                }\n            }\n        }\n        return t->level;\n    }\n\n    int findPath(Node *u, Node *t, int limit = INT_MAX) {\n        if (u == t) return limit;\n        int res = 0;\n        for (Edge *&e = u->curr; e <= &u->e.back(); e++) {\n            if (e->cap > e->flow && e->v->level == u->level + 1) {\n                int flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n                if (flow > 0) {\n                    e->flow += flow;\n                    e->v->e[e->rev].flow -= flow;\n                    limit -= flow;\n                    res += flow;\n                    if (limit <= 0) return res;\n                } else e->v->level = -1;\n            }\n        }\n        return res;\n    }\n\n    long long solve(int s, int t, int n) {\n        long long res = 0;\n        while (level(&N[s], &N[t], n)) {\n            for (int i = 1; i <= n; i++) N[i].curr = &N[i].e.front();\n            long long flow;\n            while ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n        }\n        return res;\n    }\n}\n\nint main() {\n    int n, m, s, t;\n    scanf(\"%d %d %d %d\", &n, &m, &s, &t);\n\n    for (int i = 0, u, v, w; i < m; i++) {\n        scanf(\"%d %d %d\", &u, &v, &w);\n        addEdge(u, v, w);\n    }\n\n    printf(\"%lld\\n\", Dinic::solve(s, t, n));\n\n    return 0;\n}\n```","tags":["学习笔记","模版","网络流"],"categories":["学习笔记（OI/XCPC）"]},{"title":"[HNOI 2007] 紧急疏散","url":"/BZOJ-1189-HNOI-2007-紧急疏散/","content":"\n## 题目大意\n\n假设每个房间是一个 $N \\times M$ 的矩形区域。每个格子如果是 `.` ，那么表示这是一块空地；如果是 `X`，那么表示这是一面墙，如果是 `D`，那么表示这是一扇门，人们可以从这儿撤出房间。已知门一定在房间的边界上，并且边界上不会有空地。最初，每块空地上都有一个人，在疏散时，每一秒钟每个人都可以向上下左右四个方向移动一格，当然他也可以站着不动。疏散开始后，每块空地上可以同时站无数个人。但是，每一秒钟只能有一个人移动到门的位置，一旦移动到门的位置，就表示他已经安全撤离了。\n\n如果希望所有的人安全撤离，最短需要多少时间？或者告知根本不可能。\n\n$3 \\leqslant N, \\ M \\leqslant 20$\n\n## 题目链接\n\n[【HNOI 2007】紧急疏散 - Luogu 3191](https://www.luogu.com.cn/problem/P3191)\n\n<!-- more -->\n\n## 题解\n\n二分答案 + 网络流判断可行。\n\n在建图的时候，要注意一些细节。对于要检查的时间 $t$，我们对于每一个空地，从源点向其建一条容量为 $1$ 的边；对于每一个门，拆成 $t$ 个点，每一个点向汇点建一条容量为 $1$ 的边；对于每一个空地，向此时它能到的门的对应时间的点建一条容量为 $1$ 的边（要向最早到达时间及以后时间的点连边，最短时间可由 bfs 求得），跑一遍最大流就是时间 $t$ 下最多能逃离的人数。网上我看到的大部分题解在建图时都没有对门拆点，而是直接从门向汇点建一条容量为$t$的边，这种方法用下面这个数据就能叉掉：\n\n```\n4 5\nXXDXX\nXX.XX\nX...X\nXXDXX\n```\n\n这组数据的答案为 $3$，用不拆点的方法建图得到的答案是 $2$。。。\n\n## 代码\n\n对点的编号纠结了相当长的时间，之后又由于码力太差，调了一下午。。。\n\n```cpp\n#include <cstdio>\n#include <climits>\n#include <vector>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 20;\nint g[MAXN + 1][MAXN + 1];\nstruct Edge;\nstruct Node {\n\tstd::vector<Edge *> E;\n\tstd::vector<Edge *>::iterator currEdge;\n\tint level;\n} N[2 + MAXN * MAXN + MAXN * MAXN * MAXN * MAXN];\nstruct Edge {\n\tNode *u, *v;\n\tEdge *revEdge;\n\tint cap, flow;\n\tEdge(Node *u, Node *v, int cap) : u(u), v(v), cap(cap), flow(0) {}\n};\nvoid addEdge(int u, int v, int cap = 1) {\n#ifdef DBG\n\tprintf(\"edge: %d --> %d\\n\", u, v);\n#endif\t\n\tEdge *a = new Edge(&N[u], &N[v], cap);\n\tEdge *b = new Edge(&N[v], &N[u], 0);\n\ta->revEdge = b;\n\tb->revEdge = a;\n\tN[u].E.push_back(a);\n\tN[v].E.push_back(b);\n}\nstruct Dinic {\n\tbool makeLevelGraph(Node *s, Node *t, int n) {\n\t\tfor (int i = 0; i < n; i++) N[i].level = 0;\n\t\ts->level = 1;\n\t\tstd::queue<Node *> q;\n\t\tq.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tNode *u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (std::vector<Edge *>::iterator it = u->E.begin(); it != u->E.end(); it++) {\n\t\t\t\tEdge *e = *it;\n\t\t\t\tif (e->cap > e->flow && e->v->level == 0) {\n\t\t\t\t\te->v->level = u->level + 1;\n\t\t\t\t\tif (e->v == t) return true;\n\t\t\t\t\tq.push(e->v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\tint findPath(Node *s, Node *t, int limit = INT_MAX) {\n\t\tif (s == t) return limit;\n\t\tfor (std::vector<Edge *>::iterator &it = s->currEdge; it != s->E.end(); it++) {\n\t\t\tEdge *e = *it;\n\t\t\tif (e->cap > e->flow && e->v->level == s->level + 1) {\n\t\t\t\tint flow = findPath(e->v, t, std::min(limit, e->cap - e->flow));\n\t\t\t\tif (flow > 0) {\n\t\t\t\t\te->flow += flow;\n\t\t\t\t\te->revEdge->flow -= flow;\n\t\t\t\t\treturn flow;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint operator()(int s, int t, int n) {\n\t\tint res = 0;\n\t\twhile (makeLevelGraph(&N[s], &N[t], n)) {\n\t\t\tfor (int i = 0; i < n; i++) N[i].currEdge = N[i].E.begin();\n\t\t\tint flow = 0;\n\t\t\twhile ((flow = findPath(&N[s], &N[t])) > 0) res += flow;\n\t\t}\n\t\treturn res;\n\t}\n} dinic;\nint n, m;\nstruct Point {\n\tint x, y, d;\n\tPoint(int x, int y, int d) : x(x), y(y), d(d) {}\n};\nconst int dx[4] = {0, 0, 1, -1}, dy[4] = {1, -1, 0, 0};\nint dist[MAXN * MAXN + 2][MAXN + 1][MAXN + 1], people, door = 1;\nbool isValid(const Point &p) {\n\treturn p.x >= 1 && p.x <= n && p.y >= 1 && p.y <= m && g[p.x][p.y] == 1;\n}\nvoid search(int k, int x, int y) {\n\tstd::queue<Point> q;\n\tq.push(Point(x, y, 0));\n\twhile (!q.empty()) {\n\t\tPoint u = q.front();\n\t\tq.pop();\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tPoint v(u.x + dx[i], u.y + dy[i], 0);\n\t\t\tif (!isValid(v)) continue;\n\t\t\tif (dist[k][v.x][v.y] == INT_MAX) {\n\t\t\t\tdist[k][v.x][v.y] = u.d + 1;\n\t\t\t\tq.push(Point(v.x, v.y, u.d + 1));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid clear(int n) {\n\tfor (int i = 0; i < n; i++) N[i].E.clear();\n}\nvoid build(int N, int T, int s, int t) {\n\tclear(N);\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) {\n\t\tif (g[i][j] == 1) addEdge(s, (i - 1) * m + j);\n\t}\n\tfor (int i = n * m + 1; i < t; i++) addEdge(i, t);\n\tfor (int i = 2; i <= door; i++) for (int j = 1; j <= n; j++) for (int k = 1; k <= m; k++) for (int l = dist[i][j][k]; l <= T; l++)\n\t\taddEdge((j - 1) * m + k, n * m + (door - 1) * (l - 1) + i - 1);\n}\nbool check(int T) {\n#ifdef DBG\n\tprintf(\"check(%d)\\n\", T);\n#endif\t\n\tint N = 2 + n * m + (door - 1) * T;\n\tint s = 0, t = N - 1;\n\tbuild(N, T, s, t);\n\tint flow = dinic(s, t, N);\n#ifdef DBG\n\tprintf(\"check(%d): flow = %d\\n\", T, flow);\n#endif\n\tif (flow == people) return true;\n\telse return false;\n}\nint dichotomy() {\n\tint l = 0, r = m * n;\n\tint res = -1;\n\twhile (l < r) {\n\t\tint mid = l + (r - l) / 2;\n\t\tif (check(mid)) res = mid, r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn res;\n}\nint main() {\n\tscanf(\"%d %d\", &n, &m);\n\tchar str[MAXN + 1];\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%s\", str + 1);\n\t\tfor (int j = 1; j <= m; j++) {\n\t\t\tif (str[j] == '.') g[i][j] = 1, people++;\n\t\t\telse if (str[j] == 'D') g[i][j] = ++door;\n\t\t}\n\t}\n\tfor (int i = 2; i <= door; i++) for (int j = 1; j <= n; j++) for (int k = 1; k <= m; k++) dist[i][j][k] = INT_MAX;\n\tfor (int i = 1; i <= n; i++) for (int j = 1; j <= m; j++) if (g[i][j] > 1) search(g[i][j], i, j);\n#ifdef DBG\n\tfor (int i = 2; i <= door; i++) {\n\t\tprintf(\"Door : %d\\n\", i - 1);\n\t\tfor (int j = 1; j <= n; j++) for (int k = 1; k <= m; k++)\n\t\t\tprintf(\"dist[%d][%d][%d] = %d%c\", i, j, k, dist[i][j][k], k == m ? '\\n' : ' ');\n\t}\n#endif\t\n\tint ans = dichotomy();\n\tif (ans == -1) puts(\"impossible\");\n\telse printf(\"%d\\n\", ans);\n\treturn 0;\n}\n```","tags":["网络流","二分"],"categories":["题解（OI/XCPC）"]},{"title":"[HAOI 2007] 理想的正方形","url":"/BZOJ-1047-HAOI-2007-理想的正方形/","content":"\n## 题目大意\n\n有一个 $a \\times b$ 的整数组成的矩阵，现请你从中找出一个 $n \\times n$ 的正方形区域，使得该区域所有数中的最大值和最小值的差最小。\n\n$2 \\leqslant n \\leqslant a, b \\leqslant 1,000$\n\n## 题目链接\n\n[【HAOI 2007】理想的正方形 - Luogu 2216](https://www.luogu.com.cn/problem/P2216)\n\n<!-- more -->\n\n## 题解\n\n用单调队列。\n\n先横向算出一个 $a \\times (b - n + 1)$ 的矩阵，每一个值表示以此点开始 $n$ 个数中的最大值，在对该矩阵纵向做一遍，最后得到一个 $(a - n + 1) \\times (b - n + 1)$ 的矩阵，每一个指表示以此点为左上角的 $n \\times n$ 的矩阵中的最大值；对最小值做同样的事情，最后直接比较一遍即可。\n\n单调队列：像普通队列一样进出，但调用 `top()` 函数时会返回队列中的最大/小值，具体实现可以参考其他神犇们的博客或我的代码。\n\n## 代码\n\n一开始很逗比地以为最后的矩阵是 $(a - n) \\times (b - n)$ 的。。。举个 $n = 1$ 的例子后发现我傻了。\n\n```c++\n#include <cstdio>\n#include <climits>\n#include <queue>\n#include <algorithm>\n// #define DBG\nconst int MAXN = 1005;\ntemplate <bool isMax>\nstruct MonotoneQueue {\n\tstd::deque<int> q, m;\n\tvoid push(int x) {\n\t\tq.push_back(x);\n\t\tif (isMax) while (!m.empty() && m.back() < x) m.pop_back(); \n\t\telse while (!m.empty() && m.back() > x) m.pop_back();\n\t\tm.push_back(x);\n\t}\n\tint top() {\n\t\treturn m.front();\n\t}\n\tvoid pop() {\n\t\tint x = q.front();\n\t\tq.pop_front();\n\t\tif (x == m.front()) m.pop_front();\n\t}\n};\nint m1[MAXN][MAXN], m2[MAXN][MAXN], mMax[MAXN][MAXN], mMin[MAXN][MAXN];\nint main() {\n\tint a, b, n;\n\tscanf(\"%d %d %d\", &a, &b, &n);\n\tfor (int i = 1; i <= a; i++) for (int j = 1; j <= b; j++) scanf(\"%d\", &m1[i][j]);\n\tfor (int i = 1; i <= a; i++) {\n\t\tMonotoneQueue<true> q;\n\t\tfor (int j = 1; j <= n; j++) q.push(m1[i][j]);\n\t\tm2[i][1] = q.top();\n\t\tfor (int j = n + 1; j <= b; j++) {\n\t\t\tq.pop();\n\t\t\tq.push(m1[i][j]);\n\t\t\tm2[i][j - n + 1] = q.top();\n\t\t}\n\t}\n\tfor (int i = 1; i <= b - n + 1; i++) {\n\t\tMonotoneQueue<true> q;\n\t\tfor (int j = 1; j <= n; j++) q.push(m2[j][i]);\n\t\tmMax[1][i] = q.top();\n\t\tfor (int j = n + 1; j <= a; j++) {\n\t\t\tq.pop();\n\t\t\tq.push(m2[j][i]);\n\t\t\tmMax[j - n + 1][i] = q.top();\n\t\t}\n\t}\n\tfor (int i = 1; i <= a; i++) {\n\t\tMonotoneQueue<false> q;\n\t\tfor (int j = 1; j <= n; j++) q.push(m1[i][j]);\n\t\tm2[i][1] = q.top();\n\t\tfor (int j = n + 1; j <= b; j++) {\n\t\t\tq.pop();\n\t\t\tq.push(m1[i][j]);\n\t\t\tm2[i][j - n + 1] = q.top();\n\t\t}\n\t}\n\tfor (int i = 1; i <= b - n + 1; i++) {\n\t\tMonotoneQueue<false> q;\n\t\tfor (int j = 1; j <= n; j++) q.push(m2[j][i]);\n\t\tmMin[1][i] = q.top();\n\t\tfor (int j = n + 1; j <= a; j++) {\n\t\t\tq.pop();\n\t\t\tq.push(m2[j][i]);\n\t\t\tmMin[j - n + 1][i] = q.top();\n\t\t}\n\t}\n\ta -= n - 1, b -= n - 1;\n#ifdef DBG\n\tputs(\"mMax:\");\n\tfor (int i = 1; i <= a; i++) for (int j = 1; j <= b; j++)\n        printf(\"%d%c\", mMax[i][j], j == b ? '\\n' : ' ');\n\tputs(\"mMin:\");\n\tfor (int i = 1; i <= a; i++) for (int j = 1; j <= b; j++)\n        printf(\"%d%c\", mMin[i][j], j == b ? '\\n' : ' ');\n#endif\t\n\tint ans = INT_MAX;\n\tfor (int i = 1; i <= a; i++) for (int j = 1; j <= b; j++)\n        ans = std::min(ans, mMax[i][j] - mMin[i][j]);\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n```","tags":["单调队列"],"categories":["题解（OI/XCPC）"]},{"title":"[SDOI 2010] 古代猪文","url":"/BZOJ-1951-SDOI-2010-古代猪文/","content":"\n## 题目大意\n\n已知远古时期猪文文字总个数为 $N$，某一朝代流传的文字是远古时期的 $k$ 分之一，其中 $k$ 是 $N$ 的一个正约数（可以是 $1$ 和 $N$），不过具体是哪 $k$ 分之一，以及 $k$ 是多少并不知道。考虑到所有可能的 $k$，显然当 $k$ 等于某个定值时，该朝的猪文文字个数为 $\\frac{N}k$。如果所有可能的$k$的所有情况数加起来为 $P$ 的话，那么研究古代文字的代价将会是 $G^P$。 现在他想知道猪王国研究古代文字的代价是多少。答案对 $999911659$ 取模。\n\n输入 $N、G$。\n\n$N, G \\leqslant 1,000,000,000$。\n\n## 题目链接\n\n[【SDOI 2010】古代猪文 - Luogu 2480](https://www.luogu.com.cn/problem/P2480)\n\n<!-- more -->\n\n## 题解\n\n首先，显然题目是让我们求这么一个东西：\n\n$$G^{ \\sum_{k | N} \\binom{N}{k}} \\bmod \\; 999911659$$\n\n好吧，这个东西的指数一看就很大，怎么办呢？由欧拉定理，我们易得：\n\n$$a^{b} \\equiv a^{b \\bmod \\; \\varphi(p)} (\\bmod \\; p), \\; \\gcd(a, \\ p) = 1$$\n\n另外，我们有：\n\n$$a^{b} \\equiv (a \\bmod \\; p)^{b} \\; (\\bmod \\; p)$$\n\n不过，当 $G = P$ 且 $\\varphi(P) \\ | \\ b$ 时，显然有答案为 $0$，但用以上二式会得到 $0^0 = 1$，故我们应当适当改造一下式子一，把指数改为 $b \\bmod \\; \\varphi(p) + \\varphi(p)$ 即可。（根据 Po 姐的博客，我们知道还真有这么一个点来卡这个。。。）\n\n在此题中，显然有 $\\varphi(p) = 999911658$，显然不是质数，因此我们要对其进行质因数分解，用中国剩余定理合并答案。（因为不是质数，所以在计算组合数时可能会不存在逆元）分解结果如下：\n\n$$999911658 = 2 \\times3 \\times 4679 \\times 35617$$\n\n（在 Linux 下，我们可以进入终端，在终端中输入 `factor 999911658`即可进行质因数分解）\n\n然后是中国剩余定理合并答案，其内容是：\n\n已知 $x \\equiv a_i \\ (\\bmod \\; m_i), \\ gcd(m_1, m_2, \\dots, m_n) = 1$，则 $x$ 在模 $M$（$M$ 的含义见下）意义下有唯一解，且可由以下方法求得：\n\n$$M = \\prod m_i, \\ M_i = \\frac{M}{m_i}, \\ t_i = M_i^{-1} (\\bmod \\; m_i)$$\n\n$$x = \\sum a_i t_i M_i \\bmod \\; M$$\n\n计算组合数时，$N$、$k$ 也很大，需要用到 Lucas 定理：\n\n$$\\binom{sp + a}{tq + b} = \\binom{p}{q} \\ \\binom{a}{b}$$\n\n然后直接算就行了。。。一道题，考了三个数论定理，还有一个坑。。。\n\n## 代码\n\n代码注释中的英文看看就好。。。\n\n```c++\n#include <cstdio>\n// #define DBG\ntypedef long long ll;\nconst ll MOD = 999911659;\nconst ll PHI_MOD = 999911658;\nll divisorOfP[4] = {2, 3, 4679, 35617};\nll fac[4][35617], inv[4][35617];\nll ans[5];\nvoid linearShaker(ll p, ll fac[], ll inv[]) {\n\tfac[0] = 1;\n\tfor (int i = 1; i < p; i++) fac[i] = fac[i - 1] * i % p;\n\tinv[1] = 1;\n\tfor (int i = 2; i < p; i++) inv[i] = (p - p / i) * inv[p % i] % p;\n\tinv[0] = 1;\n\tfor (int i = 1; i <= p; i++) inv[i] = inv[i] * inv[i - 1] % p;\n}\nll n, g;\nll combin(ll n, ll m, ll p, ll fac[], ll inv[]) {\n\tif (n < m) return 0;\n\tif (n < p && m < p) return fac[n] * inv[m] % p * inv[n - m] % p;\n\t//Lucas Theorem\n\t//\\binom{sp + a}{tq + b} = \\binom{a}{b} * \\binom{p}{q}\n\treturn combin(n % p, m % p, p, fac, inv) * combin(n / p, m / p, p, fac, inv) % p;\n}\nvoid calc(ll x) {\n#ifdef DBG\n\tprintf(\"calc(%lld)\\n\", x);\n#endif\t\n\tfor (int i = 0; i < 4; i++) {\n\t\tans[i] += combin(n, x, divisorOfP[i], fac[i], inv[i]);\n\t\tans[i] %= divisorOfP[i];\n\t}\n}\nll pow(ll a, ll n, ll p) {\n\tll res = 1;\n\tfor (; n; n >>= 1, a = a * a % p) if (n & 1) res = res * a % p;\n\treturn res;\n}\nll calcInv(ll n, ll p) {\n\treturn pow(n, p - 2, p);\n}\n//Chinese Remainder Theorem(CRT)\n//known : x mod m_i = a_i\n//calc x\n//def M = \\prod_{i} m_i, M_i = M / m_i, t_i * M_i = 1 (mod m_i)\n//when mod M, there is only one root of the equation\n//x = \\sum_{i} a_i * t_i * M_i\nll ChineseRemainderTheorem() {\n\tll res = 0;\n\tfor (int i = 0; i < 4; i++) {\n\t\tll x = calcInv(PHI_MOD / divisorOfP[i], divisorOfP[i]);\n\t\tll temp = (x % PHI_MOD * (PHI_MOD / divisorOfP[i]) % PHI_MOD + PHI_MOD) % PHI_MOD;\n\t\tres += temp * ans[i] % PHI_MOD;\n\t\tres %= PHI_MOD;\n\t}\n\treturn res;\n}\nll pow(ll a, ll n) {\n\tll res = 1;\n\tfor (; n; n >>= 1, a = a * a % MOD) if (n & 1) res = res * a % MOD;\n\treturn res;\n}\nint main() {\n\tfor (int i = 0; i < 4; i++) linearShaker(divisorOfP[i], fac[i], inv[i]);\n\tscanf(\"%lld %lld\", &n, &g);\n\tfor (int i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tcalc(i);\n\t\t\tif (i * i != n) calc(n / i);\n\t\t}\n\t}\n\tans[4] = ChineseRemainderTheorem();\n#ifdef DBG\n\tfor (int i = 0; i < 4; i++) printf(\"a_%d = %lld\\n\", i + 1, ans[i]);\n\tprintf(\"\\\\sum_{d | n} \\\\binom{N}{k} = %lld\\n\", ans[4]);\n#endif\n\t//Euler Theorem\n\t//a^b mod p = a^(b mod phi(p)) mod p, gcd(a, p) = 1, a, p != 0\n\t//(come from : a^phi(p) mod p = 1, gcd(a, p) = 1, a, p != 0)\n\t//to deal with the situation when a = 0, use a^(b^phi(p) + phi(p)) mod p\n\tans[4] = pow(g % MOD, ans[4] + PHI_MOD);\n\tprintf(\"%lld\\n\", ans[4]);\n\treturn 0;\n}\n```","tags":["数论","欧拉定理","Lucas定理","中国剩余定理"],"categories":["题解（OI/XCPC）"]},{"title":"Markdown学习笔记","url":"/Markdown-学习笔记/","content":"\n## 基本语法\n\n### 标题\n\nMarkdown支持两种标题的语法，类Setext和类Atx形式。\n\n类Setext采用底线形式，具体地说，是用一行若干个`=`表示一级标题，若干个`-`表示次级标题。\n\n```markdown\n一级标题\n=======\n次级标题\n-------\n```\n\n类Atx形式是在标题前加入一到六个`#`表示一到六级标题。这也是本人采用的方法。\n\n```markdown\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n```\n\n<!-- more -->\n\n以下几种类Atx形式表示的标题亦可：\n\n```markdown\n# 标题文本 #\n## 标题文本 #\n###标题文本\n#### 标题文本 ######\n```\n\n### 换行\n\n在需要插入空行的地方输入多于两个空格后回车会被认为是一个空行。\n\n### 强调\n\n强调有 **粗体**、*斜体* 两种。\n\n粗体的语法为，使用`**`或`__`包围要加粗的文字。\n\n斜体则只需用每侧使用一个符号。\n\n**注意：在强调时，符号两侧不得同时有空白**\n\n如果要书写普通的\\*或\\_，使用`\\`即可。\n\n### 引用\n\n引用的样式看起来是这个样子的：\n\n> 引用文本\n\n其语法为：\n\n```markdown\n> 引用文本\n```\n\n如果要使用多行引用，在第一行的行首插入`>`即可；在每一行的行首插入`>`亦可。\n\n引用内可以使用Markdown语法。因此，引用可以嵌套。\n\n### 列表\n\n无序列表的语法是在列表项目前加入一个`*`、`+`或`-`。\n\n```markdown\n* 列表项目\n\n+ 列表项目\n\n- 列表项目\n```\n\n有序列表使用一个数字加一个英文句点。\n\n```markdown\n1. 项目1 \n2. 项目2\n3. 项目3\n```\n\n不过，你输入的数字并不会影响显示的数字，一下两种写法的显示结果与上面的写法相同：\n\n```markdown\n1. 项目1\n1. 项目2\n1. 项目3\n\n3. 项目1\n1. 项目2\n9. 项目3\n```\n\n不过建议以正常的”1、2、3……“的顺序书写有序列表。\n\n有时，我们写的文本会被误认为是有序列表，此时可以在点号前加入`\\`。\n\n如果在项目中加入引用，应当缩进一次，代码块则是两次。\n\n### 代码块与代码\n\n插入代码块有两种语法。一是在每一行代码前缩进一次，二是用三个反引号包围。\n\n（本人使用的Markdown编辑器Typora并不支持第一种语法的样子T_T）\n\n如果采用Typora编辑Markdown，则可以使用以下语法：\n\n```markdown\n​```语言名\n```\n\n若是在文本内容中需要插入简单的一句代码，用`` `包围即可，这样产生的区段叫代码区段。\n\n如果要在代码区段中插入反引号，则使用多个反引号进行包围。\n\n（由于本段在po上博客时格式挂了许多次，所以本段用文字“反引号”而非符号本身表示符号）\n\n### 分割线\n\n用一行三个及以上的`*`、`-`或`_`表示一条分割线。符号间不得有除空格以外的内容。\n\n### 链接\n\n使用`[显示的文本](链接网址 \"链接的标题\")`可以书写带有链接的文字，这种语法被称作行内式。\n\n另有一种语法为参考式：\n\n```markdown\n[显示的文本][链接标签]\n\n[链接标签]: 链接网址 \"链接的标题\"\n```\n\n链接标签可以包含字母、数字、空格、标点符号。\n\n**注意：链接标签并不大小写敏感。**\n\n使用参考式语法时，链接的标题除了用`\"`包围外，还可以使用`'`或括号包围。\n\n### 图片\n\n采用与链接几乎相同的语法，只不过在链接的语法前加入了一个`!`。\n\n**Markdown并不支持指定图片的长和高。**\n\n### 表格\n\n表格的语法……举个栗子：\n\n```markdown\n|A|B|C|\n|:---|:--:|---:|\n|aaa|bbb|ccc|\n```\n\n显示结果为：\n\n| A    |  B   |    C |\n| :--- | :--: | ---: |\n| aaa  | bbb  |  ccc |\n\n其中`:---`、`:--:`、`---:`表示对齐方式。\n\n### 反斜线\n\n当需要普通地书写一些具有特殊含义的符号时，在符号前插入`\\`进行转意。\n\n------\n\n## $\\LaTeX$公式\n\n在行内添加公式用`$`包围（或者使用`\\(LaTeX内容\\)`），公式单独占一行则用`$$`包围（或者使用`\\[LaTeX内容\\]`）。\n\n### $\\LaTeX$公式的部分语法\n\n#### $\\LaTeX$本身的符号：\n\n```LaTeX\n\\LaTeX\n```\n\n#### 希腊字母\n\n小写希腊字母：\\ + 希腊字母的英文（小写），比如$\\alpha$为alpha。\n\n大写希腊字母：\\ + 希腊字母的英文（首字母大写）。\n\n**注意：并不是所有字母都能显示其对应大写字母**\n\n有其对应大写字母的希腊字母为：$\\gamma$—$\\Gamma$（gamma）、$\\delta$—$\\Delta$（delta）、$\\theta$—$\\Theta$（theta）、$\\lambda$—$\\Lambda$（lambda）、$\\xi$—$\\Xi$（xi）、$\\pi$—$\\Pi$（pi）、$\\sigma$—$\\Sigma$（sigma）、$\\upsilon$—$\\Upsilon$（upsilon）、$\\phi$—$\\Phi$（phi）。\n\n有一些小写字母有特别的写法，在其英文前加var：\n\n| 一般写法（不加var） |  特殊写法（加var）   |  字母英文   |\n| :---------: | :-----------: | :-----: |\n| $\\epsilon$  | $\\varepsilon$ | epsilon |\n|  $\\theta$   |  $\\vartheta$  |  theta  |\n|    $\\pi$    |   $\\varpi$    |   pi    |\n|  $\\sigma$   |  $\\varsigma$  |  sigma  |\n|   $\\phi$    |   $\\varphi$   |   phi   |\n\n#### 分数\n\n```latex\n\\frac{分子}{分母}\n```\n\n栗子：$\\frac{1}{2}$\n\n```latex\n\\frac{1}{2}\n```\n\n#### 乘号与除号\n\n*以上内容编辑于2017.3.28*\n\n乘号：$\\times$\n\n```latex\n\\times\n```\n\n点乘：$\\cdot$\n\n```latex\n\\cdot\n```\n\n除号：$\\div$\n\n```latex\n\\div\n```\n\n#### 上下标\n\n上标：\n\n```latex\na^2\na^{x + y}\n```\n\n下标：\n\n```latex\na_i\na_{x - y}\n```\n\n#### 求和与连乘\n\n```latex\n\\sum_{}^{}\n\\prod_{}^{}\n```\n\n#### 根号\n\n```latex\n\\sqrt{根底数}\n\\sqrt[根指数]{根底数}\n```\n\n#### 关系符号\n\n等号、小于号、大于号：直接输入\n\n不等号：$\\neq$\n\n```latex\n\\neq\n```\n\n小于等于：$\\leqslant$\n\n```latex\n\\leqslant\n```\n\n大于等于$\\geqslant$\n\n```latex\n\\geqslant\n```\n\n#### 省略号\n\n底部省略号：$\\dots$\n\n```latex\n\\dots\n```\n\n中部省略号：$\\cdots$\n\n```latex\n\\cdots\n```\n\n#### 排列与组合\n\n使用C、P（或A）表示组合数与排列数，以上下标语法输入即可。\n\n组合数另一种表示方式：$\\binom{n}{m}$\n\n```latex\n\\binom{n}{m}\n```\n\n排列的另一种表示方式：$n^{\\underline{m}}$\n\n```latex\nn^{underline{m}}\n```\n\n#### 同余\n\n$\\equiv$\n\n```latex\n\\equiv\n```\n\n以上的东西应该够用了。。。\n\n*以上内容编辑于2017.3.29*","tags":["学习笔记","Markdown"]}]